<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DEBUG_WITH_NEW_LOGS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DEBUG_WITH_NEW_LOGS.md" />
              <option name="updatedContent" value="#  DEBUG LOGS - Enhanced Version&#10;&#10;## ✅ Đã thêm logs chi tiết để debug&#10;&#10;### Logs mới được thêm vào:&#10;&#10;#### 1. Loading conversations:&#10;```&#10; Loading conversations on mount&#10;```&#10;&#10;#### 2. Effect 2 trigger (QUAN TRỌNG):&#10;```&#10; Effect 2 triggered: {isConnected: true/false, conversationsLength: X, trackedIds: [...]}&#10;```&#10;&#10;**Các trường hợp:**&#10;&#10;##### Case A: Waiting for connection&#10;```&#10; Effect 2 triggered: {isConnected: false, conversationsLength: X, trackedIds: [...]}&#10;⏸️ Waiting for connection...&#10;```&#10;&#10;##### Case B: Waiting for conversations&#10;```&#10; Effect 2 triggered: {isConnected: true, conversationsLength: 0, trackedIds: [...]}&#10;⏸️ No conversations yet, waiting...&#10;```&#10;&#10;##### Case C: Ready to subscribe&#10;```&#10; Effect 2 triggered: {isConnected: true, conversationsLength: 2, trackedIds: []}&#10;✅ Ready to subscribe! Processing conversations...&#10;⏭️ Skipping conv1 (already subscribed) [hoặc]&#10; New conversation detected: conv1, will subscribe&#10; SideChat subscribed to conversation conv1&#10; Subscribe summary: 2 new, 0 skipped, 2 total tracked&#10;```&#10;&#10;---&#10;&#10;##  Hướng dẫn test với logs mới:&#10;&#10;### Test sau reload:&#10;&#10;#### Bước 1: Mở Console (F12) và Clear&#10;&#10;#### Bước 2: RELOAD trang (F5)&#10;&#10;#### Bước 3: Kiểm tra logs theo thứ tự:&#10;&#10;##### ✅ Logs NÊN có (đúng):&#10;```&#10;1.  Loading conversations on mount&#10;2.  Subscribe effect running (on connection change): {isConnected: false, trackedIds: []}&#10;3. ✅ WebSocket connected&#10;4.  Subscribe effect running (on connection change): {isConnected: true, trackedIds: []}&#10;5.  Effect 2 triggered: {isConnected: true, conversationsLength: 0, trackedIds: []}&#10;6. ⏸️ No conversations yet, waiting...&#10;7. (Conversations load xong)&#10;8.  Effect 2 triggered: {isConnected: true, conversationsLength: 2, trackedIds: []}&#10;9. ✅ Ready to subscribe! Processing conversations...&#10;10.  New conversation detected: CONV_ID_1, will subscribe&#10;11.  SideChat subscribed to conversation CONV_ID_1&#10;12.  New conversation detected: CONV_ID_2, will subscribe&#10;13.  SideChat subscribed to conversation CONV_ID_2&#10;14.  Subscribe summary: 2 new, 0 skipped, 2 total tracked&#10;```&#10;&#10;##### ❌ Logs KHÔNG nên có (sai):&#10;```&#10; Effect 2 triggered: {isConnected: true, conversationsLength: 2, trackedIds: ['conv1', 'conv2']}&#10;⏭️ Skipping conv1 (already subscribed)&#10;⏭️ Skipping conv2 (already subscribed)&#10; Subscribe summary: 0 new, 2 skipped, 2 total tracked&#10;```&#10;→ Nếu thấy: Ref CHƯA được clear! Bug!&#10;&#10;---&#10;&#10;##  Scenarios để debug:&#10;&#10;### Scenario 1: Ref không được clear sau reload&#10;&#10;**Logs:**&#10;```&#10; Cleaning up all subscriptions due to unmount/disconnect&#10;(Reload)&#10; Effect 2 triggered: {trackedIds: ['conv1', 'conv2']} ← Vẫn còn data!&#10;⏭️ Skipping conv1 (already subscribed)&#10; Subscribe summary: 0 new, 2 skipped&#10;```&#10;&#10;**Vấn đề:** Cleanup không chạy hoặc ref không được clear&#10;&#10;**Kiểm tra:**&#10;- Có thấy &quot; Cleaning up&quot; TRƯỚC khi reload không?&#10;- Nếu không → cleanup không chạy&#10;&#10;### Scenario 2: Effect 2 không chạy sau khi conversations load&#10;&#10;**Logs:**&#10;```&#10; Loading conversations on mount&#10; Effect 2 triggered: {conversationsLength: 0, trackedIds: []}&#10;⏸️ No conversations yet, waiting...&#10;(Sau đó KHÔNG có log Effect 2 nữa)&#10;```&#10;&#10;**Vấn đề:** Effect 2 không chạy lại sau khi conversations được set&#10;&#10;**Nguyên nhân có thể:**&#10;- Dependency `[conversations, isConnected]` không trigger re-run&#10;- Hoặc conversations object reference không thay đổi&#10;&#10;**Kiểm tra:**&#10;```javascript&#10;// Thêm log vào loadConversations:&#10;console.log(' Conversations loaded:', processedData.length, 'conversations');&#10;setConversations(processedData);&#10;console.log('✅ State updated');&#10;```&#10;&#10;### Scenario 3: WebSocket chưa connect khi conversations load&#10;&#10;**Logs:**&#10;```&#10; Loading conversations on mount&#10; Effect 2 triggered: {isConnected: false, conversationsLength: 2, trackedIds: []}&#10;⏸️ Waiting for connection...&#10;(Sau đó)&#10;✅ WebSocket connected&#10; Effect 2 triggered: {isConnected: true, conversationsLength: 2, trackedIds: []}&#10;✅ Ready to subscribe!&#10;...&#10;```&#10;&#10;**Kết quả:** ✅ OK - Effect 2 chạy lại khi isConnected thay đổi&#10;&#10;---&#10;&#10;##  Checklist Debug:&#10;&#10;Sau khi reload, check các điều sau:&#10;&#10;### 1. ✅ Cleanup chạy&#10;```&#10; Cleaning up all subscriptions due to unmount/disconnect&#10;```&#10;Nếu KHÔNG thấy → Component không unmount đúng cách&#10;&#10;### 2. ✅ Ref được clear&#10;```&#10; Effect 2 triggered: {trackedIds: []} ← EMPTY ARRAY!&#10;```&#10;Nếu có data → Cleanup không clear ref&#10;&#10;### 3. ✅ Conversations được load&#10;```&#10; Effect 2 triggered: {conversationsLength: X} ← X &gt; 0&#10;```&#10;Nếu = 0 → Conversations chưa load hoặc load fail&#10;&#10;### 4. ✅ WebSocket connected&#10;```&#10; Effect 2 triggered: {isConnected: true}&#10;```&#10;Nếu false → WebSocket chưa connect&#10;&#10;### 5. ✅ Subscribe thành công&#10;```&#10; New conversation detected: ...&#10; SideChat subscribed to conversation ...&#10; Subscribe summary: X new, 0 skipped&#10;```&#10;Nếu &quot;0 new, X skipped&quot; → Không subscribe → BUG!&#10;&#10;### 6. ✅ Nhận message&#10;```&#10; SideChat received new message for conv ...&#10;✏️ Updating last message for conv ...&#10;```&#10;&#10;---&#10;&#10;##  Nếu vẫn không hoạt động:&#10;&#10;### Paste FULL logs theo format:&#10;&#10;```&#10;=== BEFORE RELOAD ===&#10;(Copy tất cả logs trước khi reload)&#10;&#10;=== RELOAD (F5) ===&#10;&#10;=== AFTER RELOAD ===&#10;(Copy tất cả logs sau reload)&#10;&#10;=== SEND MESSAGE TEST ===&#10;(Copy logs khi gửi message test)&#10;&#10;=== UI STATUS ===&#10;Last message có update không? YES/NO&#10;```&#10;&#10;Với logs chi tiết này, tôi sẽ xác định chính xác vấn đề ở đâu!&#10;&#10;---&#10;&#10;##  Quick Fix Commands (nếu cần):&#10;&#10;### Force clear ref manually (trong console):&#10;```javascript&#10;// Không thể access trực tiếp, nhưng có thể force reload:&#10;window.location.reload(true); // Hard reload&#10;```&#10;&#10;### Check WebSocket status:&#10;```javascript&#10;console.log('WS Connected:', webSocketService?.stompClient?.connected);&#10;console.log('Subscriptions:', webSocketService?.subscriptions?.size);&#10;console.log('Callbacks:', &#10;    Array.from(webSocketService?.callbacks?.entries() || [])&#10;        .map(([k, v]) =&gt; `${k}: ${v.size}`)&#10;);&#10;```&#10;&#10;---&#10;&#10;**RELOAD VÀ CHECK LOGS NGAY!** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/LOGS_ANALYSIS_SUCCESS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LOGS_ANALYSIS_SUCCESS.md" />
              <option name="updatedContent" value="# ✅ LOGS ANALYSIS - Subscribe Hoạt Động Đúng!&#10;&#10;##  Phân tích logs của user:&#10;&#10;### ✅ FLOW HOÀN TOÀN ĐÚNG:&#10;&#10;```&#10;Step 1: Component mount, WebSocket chưa connect&#10; Effect 2 triggered: {...}&#10;⏸️ Waiting for connection...&#10;&#10;Step 2: WebSocket connect&#10;✅ WebSocket connected&#10; Subscribe effect running (on connection change)&#10;&#10;Step 3: Effect 2 chạy lại (vì isConnected thay đổi)&#10; Effect 2 triggered: {...}&#10;✅ Ready to subscribe! Processing conversations...&#10;&#10;Step 4: Subscribe thành công&#10; New conversation detected: 68ffb2652ed5a9bf4f944657&#10; SideChat subscribed to conversation 68ffb2652ed5a9bf4f944657&#10; New conversation detected: 69038f9d461bf27ce3b78d95&#10; SideChat subscribed to conversation 69038f9d461bf27ce3b78d95&#10;&#10;Step 5: Tổng kết&#10; Subscribe summary: 2 new, 0 skipped, 2 total tracked&#10;```&#10;&#10;### ✅ KẾT LUẬN:&#10;**SUBSCRIBE ĐÃ HOẠT ĐỘNG ĐÚNG SAU RELOAD!**&#10;&#10;---&#10;&#10;##  Next Test: Nhận message&#10;&#10;Bây giờ cần test xem callbacks có hoạt động không:&#10;&#10;### Test steps:&#10;1. ✅ Đã reload - PASS&#10;2. ✅ Đã subscribe - PASS&#10;3. ⏳ **ĐANG CHỜ:** Gửi message từ user khác&#10;4. ⏳ **CHECK:** Logs có hiển thị &quot; SideChat received&quot; không?&#10;5. ⏳ **CHECK:** Last message có update trong UI không?&#10;&#10;---&#10;&#10;##  Expected logs khi nhận message:&#10;&#10;### Khi user khác gửi message vào conversation 68ffb...:&#10;&#10;```&#10; SideChat received new message for conv 68ffb2652ed5a9bf4f944657: {&#10;  id: &quot;...&quot;,&#10;  conversationId: &quot;68ffb2652ed5a9bf4f944657&quot;,&#10;  content: &quot;Test message&quot;,&#10;  senderId: &quot;...&quot;,&#10;  timestamp: &quot;...&quot;&#10;}&#10;✏️ Updating last message for conv 68ffb2652ed5a9bf4f944657: Test message&#10; Effect 2 triggered: {isConnected: true, conversationsLength: 2, trackedIds: Array(2)}&#10;⏭️ Skipping 68ffb2652ed5a9bf4f944657 (already subscribed)&#10;⏭️ Skipping 69038f9d461bf27ce3b78d95 (already subscribed)&#10; Subscribe summary: 0 new, 2 skipped, 2 total tracked&#10;```&#10;&#10;### UI:&#10;- ✅ Last message hiển thị &quot;Test message&quot;&#10;- ✅ Update ngay lập tức (real-time)&#10;&#10;---&#10;&#10;##  Nếu KHÔNG thấy &quot; SideChat received&quot;:&#10;&#10;### Có thể vấn đề:&#10;&#10;#### 1. Backend không broadcast đúng topic&#10;**Check backend logs** khi gửi message, NÊN thấy:&#10;```&#10;Broadcasting message to /topic/conversation/68ffb2652ed5a9bf4f944657&#10;```&#10;&#10;#### 2. Message format sai&#10;**Check message object** có đúng format không:&#10;```javascript&#10;{&#10;  id: &quot;...&quot;,&#10;  conversationId: &quot;68ffb2652ed5a9bf4f944657&quot;,&#10;  content: &quot;...&quot;,&#10;  senderId: &quot;...&quot;,&#10;  timestamp: &quot;...&quot;&#10;}&#10;```&#10;&#10;#### 3. WebSocket subscription không đúng&#10;**Check trong console:**&#10;```javascript&#10;webSocketService.subscriptions.has('/topic/conversation/68ffb2652ed5a9bf4f944657')&#10;// Should be: true&#10;```&#10;&#10;#### 4. Callback không được register&#10;**Check callbacks:**&#10;```javascript&#10;Array.from(webSocketService.callbacks.entries()).forEach(([dest, cbs]) =&gt; {&#10;    console.log(`${dest}: ${cbs.size} callbacks`);&#10;});&#10;// Should see: /topic/conversation/68ffb2652ed5a9bf4f944657: 2 callbacks (hoặc 1)&#10;```&#10;&#10;---&#10;&#10;##  Manual test (nếu cần):&#10;&#10;### Subscribe manually để test:&#10;```javascript&#10;webSocketService.subscribe('/topic/conversation/68ffb2652ed5a9bf4f944657', (msg) =&gt; {&#10;    console.log(' MANUAL TEST CALLBACK:', msg);&#10;});&#10;```&#10;&#10;Sau đó gửi message → NÊN thấy &quot; MANUAL TEST CALLBACK&quot;&#10;&#10;Nếu thấy → Backend OK, vấn đề ở callback registration&#10;Nếu KHÔNG thấy → Backend không broadcast hoặc topic sai&#10;&#10;---&#10;&#10;##  Action Items:&#10;&#10;### ✅ DONE:&#10;- [x] Subscribe sau reload - WORKING!&#10;&#10;### ⏳ TODO:&#10;- [ ] Gửi message test từ user khác&#10;- [ ] Check logs có &quot; SideChat received&quot; không&#10;- [ ] Check UI có update last message không&#10;- [ ] Paste logs để phân tích tiếp&#10;&#10;---&#10;&#10;##  Progress:&#10;&#10;**Subscribe: ✅ WORKING**  &#10;**Receive message: ⏳ TESTING**&#10;&#10;Đã gần xong rồi! Chỉ cần verify callbacks hoạt động là OK! &#10;&#10;---&#10;&#10;**Next:** GỬI MESSAGE TEST VÀ PASTE LOGS!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map-fe/src/components/Chat/ChatWindow.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/components/Chat/ChatWindow.jsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;import './ChatWindows.css';&#10;&#10;export default function ChatWindow({ conversation, minimized, currentUserId, onClose, onMinimize, onNewMessage, unreadCount = 0, onMarkAsRead }) {&#10;    const [messages, setMessages] = useState([]);&#10;    const [inputValue, setInputValue] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [hasMore, setHasMore] = useState(true);&#10;    const [currentPage, setCurrentPage] = useState(0);&#10;    const [typingUsers, setTypingUsers] = useState([]);&#10;    const [isSending, setIsSending] = useState(false);&#10;&#10;    const messagesEndRef = useRef(null);&#10;    const messagesContainerRef = useRef(null);&#10;    const lastScrollHeightRef = useRef(0);&#10;    const isLoadingMoreRef = useRef(false);&#10;    const inputRef = useRef(null);&#10;    const navigate = useNavigate();&#10;&#10;    // Get display info&#10;    const getDisplayInfo = useCallback(() =&gt; {&#10;        if (!conversation) return { name: '', avatar: '', status: '' };&#10;&#10;        if (conversation.isGroup) {&#10;            return {&#10;                name: conversation.groupName || 'Nhóm',&#10;                avatar: conversation.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conversation.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.isOnline ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    }, [conversation, currentUserId]);&#10;&#10;    const displayInfo = getDisplayInfo();&#10;&#10;    // Load initial messages&#10;    const loadMessages = useCallback(async (page = 0) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        try {&#10;            setIsLoading(true);&#10;            const response = await ChatService.getMessages(conversation.id, { page, size: 20 });&#10;&#10;            if (page === 0) {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    }&#10;                    return msg;&#10;                }).reverse();&#10;                setMessages(processedMessages);&#10;            } else {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    } // ✅ thêm dấu đóng if&#10;                    return msg;&#10;                }).reverse();&#10;&#10;                setMessages(prev =&gt; [...processedMessages, ...prev]);&#10;            }&#10;&#10;            setHasMore(!response.last);&#10;            setCurrentPage(page);&#10;        } catch (error) {&#10;            console.error('Failed to load messages:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;            isLoadingMoreRef.current = false;&#10;        }&#10;    }, [conversation?.id]);&#10;&#10;    // Load more messages on scroll&#10;    const handleScroll = useCallback(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (!container || isLoadingMoreRef.current || !hasMore) return;&#10;&#10;        if (container.scrollTop === 0) {&#10;            isLoadingMoreRef.current = true;&#10;            lastScrollHeightRef.current = container.scrollHeight;&#10;            loadMessages(currentPage + 1);&#10;        }&#10;    }, [currentPage, hasMore, loadMessages]);&#10;&#10;    // Maintain scroll position after loading more&#10;    useEffect(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (container &amp;&amp; lastScrollHeightRef.current &gt; 0) {&#10;            const newScrollHeight = container.scrollHeight;&#10;            container.scrollTop = newScrollHeight - lastScrollHeightRef.current;&#10;            lastScrollHeightRef.current = 0;&#10;        }&#10;    }, [messages]);&#10;&#10;    // Scroll to bottom for new messages&#10;    const scrollToBottom = useCallback((smooth = false) =&gt; {&#10;        if (messagesContainerRef.current) {&#10;            messagesContainerRef.current.scrollTo({&#10;                top: messagesContainerRef.current.scrollHeight,&#10;                behavior: smooth ? 'smooth' : 'auto'&#10;            });&#10;        }&#10;    }, []);&#10;&#10;    // Load messages on conversation change&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id) {&#10;            setMessages([]);&#10;            setCurrentPage(0);&#10;            setHasMore(true);&#10;            loadMessages(0);&#10;        }&#10;    }, [conversation?.id, loadMessages]);&#10;&#10;    // Mark as read when conversation opens or unminimizes&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id &amp;&amp; !minimized) {&#10;            ChatService.markAsRead(conversation.id).catch(console.error);&#10;            if (onMarkAsRead) {&#10;                onMarkAsRead(conversation.id);&#10;            }&#10;        }&#10;    }, [conversation?.id, minimized, onMarkAsRead]);&#10;&#10;    // Subscribe to WebSocket updates&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Subscribe to new messages&#10;        webSocketService.subscribeToConversation(&#10;            conversation.id,&#10;            (message) =&gt; {&#10;                // New message&#10;                let processedMessage = message;&#10;&#10;                // Handle location messages&#10;                if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                    try {&#10;                        const locationData = JSON.parse(message.content.substring(9));&#10;                        processedMessage = {&#10;                            ...message,&#10;                            content: locationData,&#10;                            isLocation: true&#10;                        };&#10;                    } catch (e) {&#10;                        console.error('Failed to parse location message:', e);&#10;                    }&#10;                }&#10;&#10;                setMessages(prev =&gt; [...prev, processedMessage]);&#10;                scrollToBottom(true);&#10;&#10;                // Notify parent&#10;                if (onNewMessage) {&#10;                    onNewMessage(processedMessage);&#10;                }&#10;&#10;                // Mark as read if window is open&#10;                if (!minimized) {&#10;                    webSocketService.sendMarkAsRead({ conversationId: conversation.id });&#10;                }&#10;            },&#10;            (typingDTO) =&gt; {&#10;                // Typing indicator&#10;                console.log('ChatWindow received typing:', typingDTO);&#10;                if (typingDTO.userId !== currentUserId) {&#10;                    if (typingDTO.typing) {&#10;                        const user = conversation.isGroup&#10;                            ? conversation.members?.find(m =&gt; m.userId === typingDTO.userId)&#10;                            : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                        const avatar = user?.avatarUrl || '/channels/myprofile.jpg';&#10;                        const name = user?.fullName || typingDTO.username || 'User';&#10;                        setTypingUsers(prev =&gt; {&#10;                            const newUsers = prev.some(u =&gt; u.userId === typingDTO.userId) ? prev : [...prev, { userId: typingDTO.userId, avatar, name }];&#10;                            console.log('typingUsers after add:', newUsers);&#10;                            return newUsers;&#10;                        });&#10;                    } else {&#10;                        setTypingUsers(prev =&gt; {&#10;                            console.log('before remove, typingUsers:', prev.map(u =&gt; u.userId));&#10;                            const newUsers = prev.filter(u =&gt; u.userId !== typingDTO.userId);&#10;                            console.log('after remove, typingUsers:', newUsers.map(u =&gt; u.userId));&#10;                            return newUsers;&#10;                        });&#10;                    }&#10;                    // Dispatch event to update SideChat&#10;                    console.log('ChatWindow dispatching typingStatus:', { conversationId: conversation.id, isTyping: typingDTO.typing, userId: typingDTO.userId });&#10;                    window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                        detail: { conversationId: conversation.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;                    }));&#10;                }&#10;            },&#10;            (updatedMessage) =&gt; {&#10;                // Message edited/deleted&#10;                setMessages(prev =&gt; prev.map(msg =&gt;&#10;                    msg.id === updatedMessage.id ? updatedMessage : msg&#10;                ));&#10;            }&#10;        );&#10;&#10;        return () =&gt; {&#10;            // Cleanup subscriptions when conversation changes&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}`);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/typing`);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/update`);&#10;        };&#10;    }, [conversation?.id, currentUserId, minimized, onNewMessage, scrollToBottom]);&#10;&#10;    // Send typing indicator&#10;    const sendTypingIndicator = useCallback((isTyping) =&gt; {&#10;        if (!conversation?.id) return;&#10;        console.log('sendTypingIndicator called with isTyping:', isTyping, 'conversationId:', conversation.id);&#10;        webSocketService.sendTypingStatus({&#10;            conversationId: conversation.id,&#10;            isTyping&#10;        });&#10;    }, [conversation?.id]);&#10;&#10;    // Handle input change&#10;    const handleInputChange = useCallback((e) =&gt; {&#10;        const newValue = e.target.value;&#10;        console.log('handleInputChange: newValue:', JSON.stringify(newValue), 'trim:', newValue.trim(), 'length:', newValue.length);&#10;        setInputValue(newValue);&#10;&#10;        // Send typing indicator based on whether there's text&#10;        const shouldType = newValue.length &gt; 0;&#10;        console.log('shouldType:', shouldType);&#10;        if (shouldType) {&#10;            sendTypingIndicator(true);&#10;        } else {&#10;            sendTypingIndicator(false);&#10;        }&#10;    }, [sendTypingIndicator]);&#10;&#10;    // Send message&#10;    const handleSend = useCallback(async () =&gt; {&#10;        const messageText = inputValue.trim();&#10;        if (!messageText || isSending || !conversation?.id) return;&#10;&#10;        try {&#10;            setIsSending(true);&#10;&#10;            // Send via REST API - backend will save to DB and broadcast via WebSocket&#10;            await ChatService.sendMessage(conversation.id, {&#10;                content: messageText,&#10;                messageType: 'TEXT'&#10;            });&#10;&#10;            setInputValue('');&#10;            sendTypingIndicator(false);&#10;&#10;            // Focus back to input&#10;            setTimeout(() =&gt; inputRef.current?.focus(), 0);&#10;        } catch (error) {&#10;            console.error('Failed to send message:', error);&#10;        } finally {&#10;            setIsSending(false);&#10;        }&#10;    }, [inputValue, isSending, conversation?.id, sendTypingIndicator]);&#10;&#10;    // Handle key press&#10;    const handleKeyPress = useCallback((e) =&gt; {&#10;        if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {&#10;            e.preventDefault();&#10;            handleSend();&#10;        }&#10;    }, [handleSend]);&#10;&#10;    // Linkify text&#10;    const linkify = (text) =&gt; {&#10;        if (!text) return '';&#10;        const urlRegex = /(https?:\/\/[^\s]+)/g;&#10;        return text.replace(urlRegex, (url) =&gt; {&#10;            return `&lt;a href=&quot;${url}&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;message-link&quot;&gt;${url}&lt;/a&gt;`;&#10;        });&#10;    };&#10;&#10;    // Format message time&#10;    const formatTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        const now = new Date();&#10;        const diffInHours = (now - date) / (1000 * 60 * 60);&#10;&#10;        if (diffInHours &lt; 24) {&#10;            return date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });&#10;        } else {&#10;            return date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div&#10;            className={`chat-window ${minimized ? 'minimized' : 'open'}`}&#10;            data-conversation-id={conversation?.id}&#10;            data-friend-id={conversation?.id}&#10;        &gt;&#10;            &lt;div className={`chat-window-header ${unreadCount &gt; 0 ? 'unread' : ''}`} onClick={onMinimize}&gt;&#10;                &lt;img&#10;                    src={displayInfo.avatar}&#10;                    alt=&quot;Avatar&quot;&#10;                    className=&quot;chat-window-avatar&quot;&#10;                    onClick={(e) =&gt; {&#10;                        e.stopPropagation();&#10;                        if (!conversation.isGroup) {&#10;                            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                            if (otherUser?.userId) {&#10;                                navigate(`/profile/${otherUser.userId}`);&#10;                            }&#10;                        }&#10;                    }}&#10;                /&gt;&#10;                &lt;div className=&quot;chat-window-info&quot;&gt;&#10;                    &lt;div className=&quot;chat-window-name&quot;&gt;{displayInfo.name}&lt;/div&gt;&#10;                    &lt;div className=&quot;chat-window-status&quot;&gt;{displayInfo.status}&lt;/div&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;chat-window-controls&quot;&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-minimize&quot;&#10;                        title=&quot;Thu nhỏ&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onMinimize();&#10;                        }}&#10;                    &gt;&#10;                        −&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-close&quot;&#10;                        title=&quot;Đóng&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onClose();&#10;                        }}&#10;                    &gt;&#10;                        ×&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div&#10;                className=&quot;chat-window-messages&quot;&#10;                ref={messagesContainerRef}&#10;                onScroll={handleScroll}&#10;            &gt;&#10;                {isLoading &amp;&amp; currentPage === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-loading&quot;&gt;Đang tải tin nhắn...&lt;/div&gt;&#10;                )}&#10;&#10;                {hasMore &amp;&amp; !isLoading &amp;&amp; currentPage &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;load-more-messages&quot;&gt;&#10;                        &lt;button onClick={() =&gt; loadMessages(currentPage + 1)}&gt;&#10;                            Tải thêm tin nhắn&#10;                        &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {messages.map((msg, index) =&gt; {&#10;                    const isSent = msg.senderId === currentUserId;&#10;                    const showAvatar = !isSent &amp;&amp; (index === 0 || messages[index - 1].senderId !== msg.senderId);&#10;&#10;                    return (&#10;                        &lt;div&#10;                            key={msg.id || index}&#10;                            className={`chat-window-message ${isSent ? 'sent' : 'received'}`}&#10;                        &gt;&#10;                            {showAvatar &amp;&amp; !isSent &amp;&amp; (&#10;                                &lt;img&#10;                                    src={msg.senderAvatar || displayInfo.avatar}&#10;                                    alt=&quot;Avatar&quot;&#10;                                    className=&quot;chat-window-message-avatar&quot;&#10;                                /&gt;&#10;                            )}&#10;                            {!showAvatar &amp;&amp; !isSent &amp;&amp; &lt;div className=&quot;chat-window-message-avatar-spacer&quot; /&gt;}&#10;&#10;                            &lt;div className=&quot;chat-window-message-content&quot;&gt;&#10;                                {!isSent &amp;&amp; showAvatar &amp;&amp; (&#10;                                    &lt;div className=&quot;chat-window-message-sender&quot;&gt;{msg.senderName}&lt;/div&gt;&#10;                                )}&#10;                                {msg.isLocation ? (&#10;                                    &lt;div className=&quot;location-message-card&quot;&gt;&#10;                                        &lt;div className=&quot;location-card-image&quot;&gt;&#10;                                            &lt;img src={msg.content.image} alt={msg.content.name} /&gt;&#10;                                            &lt;div className=&quot;location-card-overlay&quot;&gt;&lt;/div&gt;&#10;                                        &lt;/div&gt;&#10;                                        &lt;div className=&quot;location-card-content&quot;&gt;&#10;                                            &lt;div className=&quot;location-card-title&quot;&gt;{msg.content.name}&lt;/div&gt;&#10;                                            &lt;div className=&quot;location-card-description&quot;&gt;{msg.content.description}&lt;/div&gt;&#10;                                            &lt;button&#10;                                                className=&quot;location-card-button&quot;&#10;                                                onClick={() =&gt; window.focusLocation?.(msg.content.coordinates[0], msg.content.coordinates[1], msg.content.name)}&#10;                                            &gt;&#10;                                                ️ Xem trên bản đồ&#10;                                            &lt;/button&gt;&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                ) : (&#10;                                    &lt;div&#10;                                        className=&quot;chat-window-message-text&quot;&#10;                                        dangerouslySetInnerHTML={{ __html: linkify(msg.content) }}&#10;                                    /&gt;&#10;                                )}&#10;                                &lt;div className=&quot;chat-window-message-time&quot;&gt;&#10;                                    {formatTime(msg.timestamp)}&#10;                                    {msg.edited &amp;&amp; &lt;span className=&quot;edited-indicator&quot;&gt; (đã chỉnh sửa)&lt;/span&gt;}&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    );&#10;                })}&#10;&#10;                {typingUsers.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-window-message received typing-indicator-message&quot;&gt;&#10;                        {console.log('rendering typing indicator, typingUsers length:', typingUsers.length, 'users:', typingUsers.map(u =&gt; u.userId))}&#10;                        &lt;img src={typingUsers[0].avatar} alt=&quot;Avatar&quot; className=&quot;chat-window-message-avatar&quot; /&gt;&#10;                        &lt;div className=&quot;typing-indicator&quot;&gt;&#10;                            &lt;div className=&quot;typing-dots&quot;&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div ref={messagesEndRef} /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className=&quot;chat-window-input-container&quot;&gt;&#10;                &lt;input&#10;                    type=&quot;text&quot;&#10;                    placeholder=&quot;Aa&quot;&#10;                    className=&quot;chat-window-input&quot;&#10;                    value={inputValue}&#10;                    onInput={handleInputChange}&#10;                    onKeyPress={handleKeyPress}&#10;                    onFocus={() =&gt; { if (inputValue.length &gt; 0) sendTypingIndicator(true); }}&#10;                    onBlur={() =&gt; sendTypingIndicator(false)}&#10;                    disabled={isSending}&#10;                    ref={inputRef}&#10;                /&gt;&#10;                &lt;button&#10;                    className=&quot;chat-window-send&quot;&#10;                    onClick={handleSend}&#10;                    disabled={!inputValue.trim() || isSending}&#10;                &gt;&#10;                    {isSending ? '...' : '→'}&#10;                &lt;/button&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;import './ChatWindows.css';&#10;&#10;export default function ChatWindow({ conversation, minimized, currentUserId, onClose, onMinimize, onNewMessage, unreadCount = 0, onMarkAsRead }) {&#10;    const [messages, setMessages] = useState([]);&#10;    const [inputValue, setInputValue] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [hasMore, setHasMore] = useState(true);&#10;    const [currentPage, setCurrentPage] = useState(0);&#10;    const [typingUsers, setTypingUsers] = useState([]);&#10;    const [isSending, setIsSending] = useState(false);&#10;&#10;    const messagesEndRef = useRef(null);&#10;    const messagesContainerRef = useRef(null);&#10;    const lastScrollHeightRef = useRef(0);&#10;    const isLoadingMoreRef = useRef(false);&#10;    const inputRef = useRef(null);&#10;    const navigate = useNavigate();&#10;&#10;    // Get display info&#10;    const getDisplayInfo = useCallback(() =&gt; {&#10;        if (!conversation) return { name: '', avatar: '', status: '' };&#10;&#10;        if (conversation.isGroup) {&#10;            return {&#10;                name: conversation.groupName || 'Nhóm',&#10;                avatar: conversation.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conversation.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.isOnline ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    }, [conversation, currentUserId]);&#10;&#10;    const displayInfo = getDisplayInfo();&#10;&#10;    // Load initial messages&#10;    const loadMessages = useCallback(async (page = 0) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        try {&#10;            setIsLoading(true);&#10;            const response = await ChatService.getMessages(conversation.id, { page, size: 20 });&#10;&#10;            if (page === 0) {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    }&#10;                    return msg;&#10;                }).reverse();&#10;                setMessages(processedMessages);&#10;            } else {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    } // ✅ thêm dấu đóng if&#10;                    return msg;&#10;                }).reverse();&#10;&#10;                setMessages(prev =&gt; [...processedMessages, ...prev]);&#10;            }&#10;&#10;            setHasMore(!response.last);&#10;            setCurrentPage(page);&#10;        } catch (error) {&#10;            console.error('Failed to load messages:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;            isLoadingMoreRef.current = false;&#10;        }&#10;    }, [conversation?.id]);&#10;&#10;    // Load more messages on scroll&#10;    const handleScroll = useCallback(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (!container || isLoadingMoreRef.current || !hasMore) return;&#10;&#10;        if (container.scrollTop === 0) {&#10;            isLoadingMoreRef.current = true;&#10;            lastScrollHeightRef.current = container.scrollHeight;&#10;            loadMessages(currentPage + 1);&#10;        }&#10;    }, [currentPage, hasMore, loadMessages]);&#10;&#10;    // Maintain scroll position after loading more&#10;    useEffect(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (container &amp;&amp; lastScrollHeightRef.current &gt; 0) {&#10;            const newScrollHeight = container.scrollHeight;&#10;            container.scrollTop = newScrollHeight - lastScrollHeightRef.current;&#10;            lastScrollHeightRef.current = 0;&#10;        }&#10;    }, [messages]);&#10;&#10;    // Scroll to bottom for new messages&#10;    const scrollToBottom = useCallback((smooth = false) =&gt; {&#10;        if (messagesContainerRef.current) {&#10;            messagesContainerRef.current.scrollTo({&#10;                top: messagesContainerRef.current.scrollHeight,&#10;                behavior: smooth ? 'smooth' : 'auto'&#10;            });&#10;        }&#10;    }, []);&#10;&#10;    // Load messages on conversation change&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id) {&#10;            setMessages([]);&#10;            setCurrentPage(0);&#10;            setHasMore(true);&#10;            loadMessages(0);&#10;        }&#10;    }, [conversation?.id, loadMessages]);&#10;&#10;    // Mark as read when conversation opens or unminimizes&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id &amp;&amp; !minimized) {&#10;            ChatService.markAsRead(conversation.id).catch(console.error);&#10;            if (onMarkAsRead) {&#10;                onMarkAsRead(conversation.id);&#10;            }&#10;        }&#10;    }, [conversation?.id, minimized, onMarkAsRead]);&#10;&#10;    // Subscribe to WebSocket updates&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Create callbacks with stable references for cleanup&#10;        const messageCallback = (message) =&gt; {&#10;            console.log(' ChatWindow received new message:', message);&#10;            // New message&#10;            let processedMessage = message;&#10;&#10;            // Handle location messages&#10;            if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                try {&#10;                    const locationData = JSON.parse(message.content.substring(9));&#10;                    processedMessage = {&#10;                        ...message,&#10;                        content: locationData,&#10;                        isLocation: true&#10;                    };&#10;                } catch (e) {&#10;                    console.error('Failed to parse location message:', e);&#10;                }&#10;            }&#10;&#10;            setMessages(prev =&gt; [...prev, processedMessage]);&#10;            scrollToBottom(true);&#10;&#10;            // Notify parent&#10;            if (onNewMessage) {&#10;                onNewMessage(processedMessage);&#10;            }&#10;&#10;            // Mark as read if window is open&#10;            if (!minimized) {&#10;                webSocketService.sendMarkAsRead({ conversationId: conversation.id });&#10;            }&#10;        };&#10;&#10;        const typingCallback = (typingDTO) =&gt; {&#10;            // Typing indicator&#10;            console.log('ChatWindow received typing:', typingDTO);&#10;            if (typingDTO.userId !== currentUserId) {&#10;                if (typingDTO.typing) {&#10;                    const user = conversation.isGroup&#10;                        ? conversation.members?.find(m =&gt; m.userId === typingDTO.userId)&#10;                        : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                    const avatar = user?.avatarUrl || '/channels/myprofile.jpg';&#10;                    const name = user?.fullName || typingDTO.username || 'User';&#10;                    setTypingUsers(prev =&gt; {&#10;                        const newUsers = prev.some(u =&gt; u.userId === typingDTO.userId) ? prev : [...prev, { userId: typingDTO.userId, avatar, name }];&#10;                        console.log('typingUsers after add:', newUsers);&#10;                        return newUsers;&#10;                    });&#10;                } else {&#10;                    setTypingUsers(prev =&gt; {&#10;                        console.log('before remove, typingUsers:', prev.map(u =&gt; u.userId));&#10;                        const newUsers = prev.filter(u =&gt; u.userId !== typingDTO.userId);&#10;                        console.log('after remove, typingUsers:', newUsers.map(u =&gt; u.userId));&#10;                        return newUsers;&#10;                    });&#10;                }&#10;                // Dispatch event to update SideChat&#10;                console.log('ChatWindow dispatching typingStatus:', { conversationId: conversation.id, isTyping: typingDTO.typing, userId: typingDTO.userId });&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conversation.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;                }));&#10;            }&#10;        };&#10;&#10;        const updateCallback = (updatedMessage) =&gt; {&#10;            // Message edited/deleted&#10;            setMessages(prev =&gt; prev.map(msg =&gt;&#10;                msg.id === updatedMessage.id ? updatedMessage : msg&#10;            ));&#10;        };&#10;&#10;        // Subscribe with callback references&#10;        console.log(' ChatWindow subscribing to conversation:', conversation.id);&#10;        webSocketService.subscribeToConversation(&#10;            conversation.id,&#10;            messageCallback,&#10;            typingCallback,&#10;            updateCallback&#10;        );&#10;&#10;        return () =&gt; {&#10;            // Cleanup: Unsubscribe ONLY ChatWindow's callbacks (not SideChat's!)&#10;            console.log(' ChatWindow cleanup: unsubscribing callbacks for', conversation.id);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}`, messageCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/typing`, typingCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/update`, updateCallback);&#10;        };&#10;    }, [conversation?.id, currentUserId, minimized, onNewMessage, scrollToBottom]);&#10;&#10;    // Send typing indicator&#10;    const sendTypingIndicator = useCallback((isTyping) =&gt; {&#10;        if (!conversation?.id) return;&#10;        console.log('sendTypingIndicator called with isTyping:', isTyping, 'conversationId:', conversation.id);&#10;        webSocketService.sendTypingStatus({&#10;            conversationId: conversation.id,&#10;            isTyping&#10;        });&#10;    }, [conversation?.id]);&#10;&#10;    // Handle input change&#10;    const handleInputChange = useCallback((e) =&gt; {&#10;        const newValue = e.target.value;&#10;        console.log('handleInputChange: newValue:', JSON.stringify(newValue), 'trim:', newValue.trim(), 'length:', newValue.length);&#10;        setInputValue(newValue);&#10;&#10;        // Send typing indicator based on whether there's text&#10;        const shouldType = newValue.length &gt; 0;&#10;        console.log('shouldType:', shouldType);&#10;        if (shouldType) {&#10;            sendTypingIndicator(true);&#10;        } else {&#10;            sendTypingIndicator(false);&#10;        }&#10;    }, [sendTypingIndicator]);&#10;&#10;    // Send message&#10;    const handleSend = useCallback(async () =&gt; {&#10;        const messageText = inputValue.trim();&#10;        if (!messageText || isSending || !conversation?.id) return;&#10;&#10;        try {&#10;            setIsSending(true);&#10;&#10;            // Send via REST API - backend will save to DB and broadcast via WebSocket&#10;            await ChatService.sendMessage(conversation.id, {&#10;                content: messageText,&#10;                messageType: 'TEXT'&#10;            });&#10;&#10;            setInputValue('');&#10;            sendTypingIndicator(false);&#10;&#10;            // Focus back to input&#10;            setTimeout(() =&gt; inputRef.current?.focus(), 0);&#10;        } catch (error) {&#10;            console.error('Failed to send message:', error);&#10;        } finally {&#10;            setIsSending(false);&#10;        }&#10;    }, [inputValue, isSending, conversation?.id, sendTypingIndicator]);&#10;&#10;    // Handle key press&#10;    const handleKeyPress = useCallback((e) =&gt; {&#10;        if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {&#10;            e.preventDefault();&#10;            handleSend();&#10;        }&#10;    }, [handleSend]);&#10;&#10;    // Linkify text&#10;    const linkify = (text) =&gt; {&#10;        if (!text) return '';&#10;        const urlRegex = /(https?:\/\/[^\s]+)/g;&#10;        return text.replace(urlRegex, (url) =&gt; {&#10;            return `&lt;a href=&quot;${url}&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;message-link&quot;&gt;${url}&lt;/a&gt;`;&#10;        });&#10;    };&#10;&#10;    // Format message time&#10;    const formatTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        const now = new Date();&#10;        const diffInHours = (now - date) / (1000 * 60 * 60);&#10;&#10;        if (diffInHours &lt; 24) {&#10;            return date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });&#10;        } else {&#10;            return date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div&#10;            className={`chat-window ${minimized ? 'minimized' : 'open'}`}&#10;            data-conversation-id={conversation?.id}&#10;            data-friend-id={conversation?.id}&#10;        &gt;&#10;            &lt;div className={`chat-window-header ${unreadCount &gt; 0 ? 'unread' : ''}`} onClick={onMinimize}&gt;&#10;                &lt;img&#10;                    src={displayInfo.avatar}&#10;                    alt=&quot;Avatar&quot;&#10;                    className=&quot;chat-window-avatar&quot;&#10;                    onClick={(e) =&gt; {&#10;                        e.stopPropagation();&#10;                        if (!conversation.isGroup) {&#10;                            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                            if (otherUser?.userId) {&#10;                                navigate(`/profile/${otherUser.userId}`);&#10;                            }&#10;                        }&#10;                    }}&#10;                /&gt;&#10;                &lt;div className=&quot;chat-window-info&quot;&gt;&#10;                    &lt;div className=&quot;chat-window-name&quot;&gt;{displayInfo.name}&lt;/div&gt;&#10;                    &lt;div className=&quot;chat-window-status&quot;&gt;{displayInfo.status}&lt;/div&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;chat-window-controls&quot;&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-minimize&quot;&#10;                        title=&quot;Thu nhỏ&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onMinimize();&#10;                        }}&#10;                    &gt;&#10;                        −&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-close&quot;&#10;                        title=&quot;Đóng&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onClose();&#10;                        }}&#10;                    &gt;&#10;                        ×&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div&#10;                className=&quot;chat-window-messages&quot;&#10;                ref={messagesContainerRef}&#10;                onScroll={handleScroll}&#10;            &gt;&#10;                {isLoading &amp;&amp; currentPage === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-loading&quot;&gt;Đang tải tin nhắn...&lt;/div&gt;&#10;                )}&#10;&#10;                {hasMore &amp;&amp; !isLoading &amp;&amp; currentPage &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;load-more-messages&quot;&gt;&#10;                        &lt;button onClick={() =&gt; loadMessages(currentPage + 1)}&gt;&#10;                            Tải thêm tin nhắn&#10;                        &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {messages.map((msg, index) =&gt; {&#10;                    const isSent = msg.senderId === currentUserId;&#10;                    const showAvatar = !isSent &amp;&amp; (index === 0 || messages[index - 1].senderId !== msg.senderId);&#10;&#10;                    return (&#10;                        &lt;div&#10;                            key={msg.id || index}&#10;                            className={`chat-window-message ${isSent ? 'sent' : 'received'}`}&#10;                        &gt;&#10;                            {showAvatar &amp;&amp; !isSent &amp;&amp; (&#10;                                &lt;img&#10;                                    src={msg.senderAvatar || displayInfo.avatar}&#10;                                    alt=&quot;Avatar&quot;&#10;                                    className=&quot;chat-window-message-avatar&quot;&#10;                                /&gt;&#10;                            )}&#10;                            {!showAvatar &amp;&amp; !isSent &amp;&amp; &lt;div className=&quot;chat-window-message-avatar-spacer&quot; /&gt;}&#10;&#10;                            &lt;div className=&quot;chat-window-message-content&quot;&gt;&#10;                                {!isSent &amp;&amp; showAvatar &amp;&amp; (&#10;                                    &lt;div className=&quot;chat-window-message-sender&quot;&gt;{msg.senderName}&lt;/div&gt;&#10;                                )}&#10;                                {msg.isLocation ? (&#10;                                    &lt;div className=&quot;location-message-card&quot;&gt;&#10;                                        &lt;div className=&quot;location-card-image&quot;&gt;&#10;                                            &lt;img src={msg.content.image} alt={msg.content.name} /&gt;&#10;                                            &lt;div className=&quot;location-card-overlay&quot;&gt;&lt;/div&gt;&#10;                                        &lt;/div&gt;&#10;                                        &lt;div className=&quot;location-card-content&quot;&gt;&#10;                                            &lt;div className=&quot;location-card-title&quot;&gt;{msg.content.name}&lt;/div&gt;&#10;                                            &lt;div className=&quot;location-card-description&quot;&gt;{msg.content.description}&lt;/div&gt;&#10;                                            &lt;button&#10;                                                className=&quot;location-card-button&quot;&#10;                                                onClick={() =&gt; window.focusLocation?.(msg.content.coordinates[0], msg.content.coordinates[1], msg.content.name)}&#10;                                            &gt;&#10;                                                ️ Xem trên bản đồ&#10;                                            &lt;/button&gt;&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                ) : (&#10;                                    &lt;div&#10;                                        className=&quot;chat-window-message-text&quot;&#10;                                        dangerouslySetInnerHTML={{ __html: linkify(msg.content) }}&#10;                                    /&gt;&#10;                                )}&#10;                                &lt;div className=&quot;chat-window-message-time&quot;&gt;&#10;                                    {formatTime(msg.timestamp)}&#10;                                    {msg.edited &amp;&amp; &lt;span className=&quot;edited-indicator&quot;&gt; (đã chỉnh sửa)&lt;/span&gt;}&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    );&#10;                })}&#10;&#10;                {typingUsers.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-window-message received typing-indicator-message&quot;&gt;&#10;                        {console.log('rendering typing indicator, typingUsers length:', typingUsers.length, 'users:', typingUsers.map(u =&gt; u.userId))}&#10;                        &lt;img src={typingUsers[0].avatar} alt=&quot;Avatar&quot; className=&quot;chat-window-message-avatar&quot; /&gt;&#10;                        &lt;div className=&quot;typing-indicator&quot;&gt;&#10;                            &lt;div className=&quot;typing-dots&quot;&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div ref={messagesEndRef} /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className=&quot;chat-window-input-container&quot;&gt;&#10;                &lt;input&#10;                    type=&quot;text&quot;&#10;                    placeholder=&quot;Aa&quot;&#10;                    className=&quot;chat-window-input&quot;&#10;                    value={inputValue}&#10;                    onInput={handleInputChange}&#10;                    onKeyPress={handleKeyPress}&#10;                    onFocus={() =&gt; { if (inputValue.length &gt; 0) sendTypingIndicator(true); }}&#10;                    onBlur={() =&gt; sendTypingIndicator(false)}&#10;                    disabled={isSending}&#10;                    ref={inputRef}&#10;                /&gt;&#10;                &lt;button&#10;                    className=&quot;chat-window-send&quot;&#10;                    onClick={handleSend}&#10;                    disabled={!inputValue.trim() || isSending}&#10;                &gt;&#10;                    {isSending ? '...' : '→'}&#10;                &lt;/button&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map-fe/src/components/Chat/SideChat.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/components/Chat/SideChat.jsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useCallback, useRef } from 'react';&#10;import './Chat.css';&#10;import './ChatWindows.css';&#10;import './LocationMessage.css';&#10;import ChatWindow from './ChatWindow';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;&#10;export default function SideChat() {&#10;    const [isChatOpen, setIsChatOpen] = useState(false);&#10;    const [activeFriend, setActiveFriend] = useState(null);&#10;    const [openChatWindows, setOpenChatWindows] = useState(new Map());&#10;    const [conversations, setConversations] = useState([]);&#10;    const [searchQuery, setSearchQuery] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isConnected, setIsConnected] = useState(false);&#10;    const [currentUserId, setCurrentUserId] = useState(null);&#10;    const wsConnectedRef = useRef(false);&#10;    const conversationIdsRef = useRef(new Set()); // Track conversation IDs to detect new conversations&#10;&#10;    // Load conversations from backend&#10;    const loadConversations = useCallback(async () =&gt; {&#10;        try {&#10;            setIsLoading(true);&#10;            const data = await ChatService.getUserConversations();&#10;            // Parse location messages in lastMessage&#10;            const processedData = data.map(conv =&gt; {&#10;                if (conv.lastMessageContent?.startsWith('LOCATION:')) {&#10;                    return {&#10;                        ...conv,&#10;                        lastMessageContent: 'Vị trí'&#10;                    };&#10;                }&#10;                return conv;&#10;            }).map(conv =&gt; ({ ...conv, typingUsers: [] })); // Add typingUsers array&#10;            setConversations(processedData);&#10;        } catch (error) {&#10;            console.error('Failed to load conversations:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, []);&#10;&#10;    // Connect to WebSocket&#10;    useEffect(() =&gt; {&#10;        const conversationIdsRefCurrent = conversationIdsRef.current; // Copy ref for cleanup&#10;&#10;        if (!wsConnectedRef.current) {&#10;            webSocketService.connect(&#10;                () =&gt; {&#10;                    console.log('✅ WebSocket connected');&#10;                    setIsConnected(true);&#10;                    wsConnectedRef.current = true;&#10;&#10;                    // Lấy userId từ WebSocket service (đã được fetch từ backend)&#10;                    const userId = webSocketService.getCurrentUserId();&#10;                    setCurrentUserId(userId);&#10;&#10;                    // Subscribe to user queue for unread counts&#10;                    webSocketService.subscribeToUserQueue(&#10;                        (unreadDTO) =&gt; {&#10;                            // Update unread count for conversation&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === unreadDTO.conversationId&#10;                                    ? { ...conv, unreadCount: unreadDTO.count }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('WebSocket error:', error);&#10;                        }&#10;                    );&#10;&#10;                    // Subscribe to conversation updates&#10;                    webSocketService.subscribeToConversationUpdates(&#10;                        (updateDTO) =&gt; {&#10;                            // Update conversation with new last message and unread count&#10;                            let lastMessageContent = updateDTO.lastMessageContent;&#10;                            if (updateDTO.lastMessageContent?.startsWith('LOCATION:')) {&#10;                                lastMessageContent = 'Vị trí';&#10;                            }&#10;&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === updateDTO.conversationId&#10;                                    ? {&#10;                                        ...conv,&#10;                                        lastMessageContent: lastMessageContent,&#10;                                        lastMessageSenderId: updateDTO.lastMessageSenderId,&#10;                                        lastMessageAt: updateDTO.lastMessageAt,&#10;                                        unreadCount: updateDTO.unreadCount&#10;                                    }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('Conversation update error:', error);&#10;                        }&#10;                    );&#10;                },&#10;                (error) =&gt; {&#10;                    console.error('WebSocket connection failed:', error);&#10;                    setIsConnected(false);&#10;                    wsConnectedRef.current = false;&#10;                }&#10;            );&#10;        }&#10;&#10;        return () =&gt; {&#10;            if (wsConnectedRef.current) {&#10;                webSocketService.disconnect();&#10;                wsConnectedRef.current = false;&#10;                // Clear subscription tracking to force re-subscribe on next connect&#10;                conversationIdsRefCurrent.clear();&#10;                console.log(' WebSocket disconnected, cleared subscription tracking');&#10;            }&#10;        };&#10;    }, []);&#10;&#10;    // Load conversations on mount&#10;    useEffect(() =&gt; {&#10;        loadConversations();&#10;    }, [loadConversations]);&#10;&#10;    // Subscribe to all conversations for both messages and typing&#10;    // Only re-run when isConnected changes, NOT when conversations state updates&#10;    useEffect(() =&gt; {&#10;        if (!isConnected) return;&#10;&#10;        console.log(' Subscribe effect running (on connection change):', {&#10;            isConnected,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        // This effect should NOT re-run when conversations state changes&#10;        // We'll use a separate effect to handle new conversations&#10;&#10;        // Cleanup when component unmounts or connection changes&#10;        return () =&gt; {&#10;            console.log(' Cleaning up all subscriptions due to unmount/disconnect');&#10;            // Clear all tracked IDs to force re-subscribe on reconnect&#10;            conversationIdsRef.current.clear();&#10;        };&#10;    }, [isConnected]);&#10;&#10;    // Separate effect to subscribe to NEW conversations when they appear&#10;    useEffect(() =&gt; {&#10;        if (!isConnected || conversations.length === 0) return;&#10;&#10;        console.log(' Checking for new conversations to subscribe:', {&#10;            conversationsCount: conversations.length,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        conversations.forEach(conv =&gt; {&#10;            // Only subscribe to NEW conversations (not already in ref)&#10;            if (conversationIdsRef.current.has(conv.id)) {&#10;                // Already subscribed, do nothing&#10;                return;&#10;            }&#10;&#10;            console.log(` New conversation detected: ${conv.id}, will subscribe`);&#10;&#10;            // Create message callback with closure over conv.id&#10;            const messageCallback = (message) =&gt; {&#10;                console.log(' SideChat received new message for conv', conv.id, ':', message);&#10;&#10;                // Process location messages&#10;                let lastMessageContent = message.content;&#10;                if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                    lastMessageContent = 'Vị trí';&#10;                } else if (message.isLocation) {&#10;                    lastMessageContent = 'Vị trí';&#10;                }&#10;&#10;                // Update conversation's last message&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        console.log(`✏️ Updating last message for conv ${conv.id}:`, lastMessageContent);&#10;                        return {&#10;                            ...c,&#10;                            lastMessageContent: lastMessageContent,&#10;                            lastMessageSenderId: message.senderId,&#10;                            lastMessageAt: message.timestamp || new Date().toISOString(),&#10;                        };&#10;                    }&#10;                    return c;&#10;                }));&#10;            };&#10;&#10;            // Create typing callback&#10;            const typingCallback = (typingDTO) =&gt; {&#10;                console.log('SideChat received typing:', typingDTO);&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conv.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;                }));&#10;            };&#10;&#10;            // Subscribe to messages AND typing for this conversation&#10;            webSocketService.subscribeToConversation(&#10;                conv.id,&#10;                messageCallback,&#10;                typingCallback,&#10;                null&#10;            );&#10;&#10;            // Mark as subscribed (IMPORTANT: callbacks will persist via WebSocketService)&#10;            conversationIdsRef.current.add(conv.id);&#10;&#10;            console.log(` SideChat subscribed to conversation ${conv.id}`);&#10;        });&#10;&#10;        // NO cleanup function here - subscriptions persist across state updates&#10;        // Cleanup only happens in the isConnected effect above&#10;    }, [conversations, isConnected]);&#10;&#10;    // Listen for openChatWindow event from Profile Page&#10;    useEffect(() =&gt; {&#10;        const handleOpenChatWindow = (event) =&gt; {&#10;            const { conversation, minimized } = event.detail;&#10;&#10;            if (!conversation) return;&#10;&#10;            // Add to conversations list if not exists&#10;            setConversations(prev =&gt; {&#10;                const exists = prev.find(c =&gt; c.id === conversation.id);&#10;                if (!exists) {&#10;                    return [conversation, ...prev];&#10;                }&#10;                return prev;&#10;            });&#10;&#10;            // Open chat window&#10;            setOpenChatWindows(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                newMap.set(conversation.id, { ...conversation, minimized: minimized || false });&#10;                return newMap;&#10;            });&#10;&#10;            setActiveFriend(conversation.id);&#10;        };&#10;&#10;        window.addEventListener('openChatWindow', handleOpenChatWindow);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('openChatWindow', handleOpenChatWindow);&#10;        };&#10;    }, []);&#10;&#10;    // Listen for typing status updates from ChatWindow&#10;    useEffect(() =&gt; {&#10;        const handleTypingStatus = (event) =&gt; {&#10;            const { conversationId, isTyping, userId } = event.detail;&#10;            console.log('SideChat handling typingStatus:', { conversationId, isTyping, userId });&#10;            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                if (conv.id === conversationId) {&#10;                    let newTypingUsers = [...conv.typingUsers];&#10;                    if (isTyping) {&#10;                        if (!newTypingUsers.includes(userId)) {&#10;                            newTypingUsers.push(userId);&#10;                        }&#10;                    } else {&#10;                        newTypingUsers = newTypingUsers.filter(id =&gt; id !== userId);&#10;                    }&#10;                    console.log('Updated typingUsers for conv', conv.id, ':', newTypingUsers);&#10;                    return { ...conv, typingUsers: newTypingUsers };&#10;                }&#10;                return conv;&#10;            }));&#10;        };&#10;&#10;        window.addEventListener('typingStatus', handleTypingStatus);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('typingStatus', handleTypingStatus);&#10;        };&#10;    }, []);&#10;&#10;    const handleChatToggle = useCallback(() =&gt; {&#10;        setIsChatOpen(prev =&gt; !prev);&#10;    }, []);&#10;&#10;    const handleCloseChatPopup = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleOverlayClick = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleFriendClick = useCallback(async (conversation) =&gt; {&#10;        setActiveFriend(conversation.id);&#10;        setIsChatOpen(false);&#10;&#10;        // Mark as read&#10;        try {&#10;            await ChatService.markAsRead(conversation.id);&#10;            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                conv.id === conversation.id ? { ...conv, unreadCount: 0 } : conv&#10;            ));&#10;        } catch (error) {&#10;            console.error('Failed to mark as read:', error);&#10;        }&#10;&#10;        // Open chat window&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            if (!newMap.has(conversation.id)) {&#10;                newMap.set(conversation.id, { ...conversation, minimized: false });&#10;            } else {&#10;                const existing = newMap.get(conversation.id);&#10;                newMap.set(conversation.id, { ...existing, minimized: false });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleCloseChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            newMap.delete(conversationId);&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleMinimizeChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            const chatWindow = newMap.get(conversationId);&#10;            if (chatWindow) {&#10;                newMap.set(conversationId, { ...chatWindow, minimized: !chatWindow.minimized });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    // Handle new messages from WebSocket&#10;    const handleNewMessage = useCallback((conversationId, message) =&gt; {&#10;        let lastMessageContent = message.content;&#10;        if (message.content?.startsWith('LOCATION:')) {&#10;            lastMessageContent = 'Vị trí';&#10;        }&#10;&#10;        setConversations(prev =&gt; prev.map(conv =&gt; {&#10;            if (conv.id === conversationId) {&#10;                return {&#10;                    ...conv,&#10;                    lastMessageContent: lastMessageContent,&#10;                    lastMessageTime: message.timestamp,&#10;                    lastMessageSender: message.senderName,&#10;                };&#10;            }&#10;            return conv;&#10;        }));&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        const chatToggle = document.getElementById('chatToggle');&#10;        if (chatToggle) {&#10;            chatToggle.addEventListener('click', handleChatToggle);&#10;            return () =&gt; chatToggle.removeEventListener('click', handleChatToggle);&#10;        }&#10;    }, [handleChatToggle]);&#10;&#10;    useEffect(() =&gt; {&#10;        const handleEscape = (e) =&gt; {&#10;            if (e.key === 'Escape' &amp;&amp; isChatOpen) {&#10;                setIsChatOpen(false);&#10;            }&#10;        };&#10;&#10;        document.addEventListener('keydown', handleEscape);&#10;        return () =&gt; document.removeEventListener('keydown', handleEscape);&#10;    }, [isChatOpen]);&#10;&#10;    // Filter conversations based on search query&#10;    const filteredConversations = conversations.filter(conv =&gt; {&#10;        const displayName = conv.isGroup ? conv.groupName : conv.otherUser?.displayName || '';&#10;        return displayName.toLowerCase().includes(searchQuery.toLowerCase());&#10;    });&#10;&#10;    // Get display info for conversation&#10;    const getConversationDisplay = (conv) =&gt; {&#10;        if (conv.isGroup) {&#10;            return {&#10;                name: conv.groupName || 'Nhóm',&#10;                avatar: conv.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conv.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conv.otherUser || conv.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.online ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    };&#10;&#10;    // Format last message display&#10;    const getLastMessageDisplay = (conv) =&gt; {&#10;        if (conv.typingUsers &amp;&amp; conv.typingUsers.length &gt; 0) {&#10;            return (&#10;                &lt;span className=&quot;typing-indicator-text&quot;&gt;&#10;                    &lt;span className=&quot;typing-dots-inline&quot;&gt;&#10;                        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&#10;                    &lt;/span&gt;&#10;                    {' '}đang nhập&#10;                &lt;/span&gt;&#10;            );&#10;        }&#10;&#10;        if (conv.lastMessageContent) {&#10;            const prefix = conv.lastMessageSenderId === currentUserId ? 'Bạn: ' : '';&#10;            return `${prefix}${conv.lastMessageContent}`;&#10;        }&#10;&#10;        return 'Bắt đầu trò chuyện';&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            {/* Chat Popup Overlay */}&#10;            &lt;div&#10;                className={`chat-popup-overlay ${isChatOpen ? 'is-active' : ''}`}&#10;                id=&quot;chatPopupOverlay&quot;&#10;                onClick={handleOverlayClick}&#10;                role=&quot;button&quot;&#10;                tabIndex={0}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleOverlayClick()}&#10;                aria-label=&quot;Close chat&quot;&#10;            /&gt;&#10;&#10;            {/* Side Chat */}&#10;            &lt;div className={`side-chat ${isChatOpen ? 'is-active' : ''}`} id=&quot;sideChat&quot;&gt;&#10;                &lt;div className=&quot;chat-header&quot;&gt;&#10;                    &lt;h3&gt;Đoạn chat&lt;/h3&gt;&#10;                    &lt;button className=&quot;chat-close-btn&quot; id=&quot;chatCloseBtn&quot; onClick={handleCloseChatPopup}&gt;×&lt;/button&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Search Box */}&#10;                &lt;div className=&quot;chat-search-box&quot;&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        placeholder=&quot;Tìm kiếm đoạn chat...&quot;&#10;                        value={searchQuery}&#10;                        onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;                        className=&quot;chat-search-input&quot;&#10;                    /&gt;&#10;                    {searchQuery &amp;&amp; (&#10;                        &lt;button&#10;                            className=&quot;chat-search-clear&quot;&#10;                            onClick={() =&gt; setSearchQuery('')}&#10;                        &gt;&#10;                            ×&#10;                        &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;chat-friends-list&quot;&gt;&#10;                    {isLoading ? (&#10;                        &lt;div className=&quot;chat-loading&quot;&gt;Đang tải...&lt;/div&gt;&#10;                    ) : filteredConversations.length === 0 ? (&#10;                        &lt;div className=&quot;chat-empty&quot;&gt;Không có đoạn chat nào&lt;/div&gt;&#10;                    ) : (&#10;                        filteredConversations.map((conv) =&gt; {&#10;                            const display = getConversationDisplay(conv);&#10;                            return (&#10;                                &lt;div&#10;                                    key={conv.id}&#10;                                    className={`friend-item ${activeFriend === conv.id ? 'active' : ''}`}&#10;                                    onClick={() =&gt; handleFriendClick(conv)}&#10;                                    role=&quot;button&quot;&#10;                                    tabIndex={0}&#10;                                    onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleFriendClick(conv)}&#10;                                    data-friend={conv.id}&#10;                                &gt;&#10;                                    &lt;img src={display.avatar} alt=&quot;Avatar&quot; className=&quot;friend-avatar&quot; /&gt;&#10;                                    &lt;div className=&quot;friend-info&quot;&gt;&#10;                                        &lt;div className=&quot;friend-name&quot;&gt;{display.name}&lt;/div&gt;&#10;                                        &lt;div className=&quot;friend-status&quot;&gt;&#10;                                            {getLastMessageDisplay(conv)}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                    {conv.unreadCount &gt; 0 &amp;&amp; (&#10;                                        &lt;div className=&quot;unread-count&quot;&gt;{conv.unreadCount}&lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            );&#10;                        })&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {!isConnected &amp;&amp; (&#10;                    &lt;div className=&quot;chat-connection-status&quot;&gt;&#10;                        &lt;span className=&quot;connection-indicator offline&quot;&gt;●&lt;/span&gt;&#10;                        {' '}Đang kết nối lại...&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Chat Windows Container */}&#10;            &lt;div className=&quot;chat-windows-container&quot; id=&quot;chatWindowsContainer&quot;&gt;&#10;                {Array.from(openChatWindows.entries()).map(([conversationId, chatData]) =&gt; {&#10;                    const conversation = conversations.find(c =&gt; c.id === conversationId) || chatData;&#10;                    return (&#10;                        &lt;ChatWindow&#10;                            key={conversationId}&#10;                            conversation={conversation}&#10;                            minimized={chatData.minimized}&#10;                            currentUserId={currentUserId}&#10;                            unreadCount={conversation.unreadCount || 0}&#10;                            onClose={() =&gt; handleCloseChatWindow(conversationId)}&#10;                            onMinimize={() =&gt; handleMinimizeChatWindow(conversationId)}&#10;                            onNewMessage={(message) =&gt; handleNewMessage(conversationId, message)}&#10;                        /&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useCallback, useRef } from 'react';&#10;import './Chat.css';&#10;import './ChatWindows.css';&#10;import './LocationMessage.css';&#10;import ChatWindow from './ChatWindow';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;&#10;export default function SideChat() {&#10;    const [isChatOpen, setIsChatOpen] = useState(false);&#10;    const [activeFriend, setActiveFriend] = useState(null);&#10;    const [openChatWindows, setOpenChatWindows] = useState(new Map());&#10;    const [conversations, setConversations] = useState([]);&#10;    const [searchQuery, setSearchQuery] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isConnected, setIsConnected] = useState(false);&#10;    const [currentUserId, setCurrentUserId] = useState(null);&#10;    const wsConnectedRef = useRef(false);&#10;    const conversationIdsRef = useRef(new Set()); // Track conversation IDs to detect new conversations&#10;&#10;    // Load conversations from backend&#10;    const loadConversations = useCallback(async () =&gt; {&#10;        try {&#10;            setIsLoading(true);&#10;            const data = await ChatService.getUserConversations();&#10;            // Parse location messages in lastMessage&#10;            const processedData = data.map(conv =&gt; {&#10;                if (conv.lastMessageContent?.startsWith('LOCATION:')) {&#10;                    return {&#10;                        ...conv,&#10;                        lastMessageContent: 'Vị trí'&#10;                    };&#10;                }&#10;                return conv;&#10;            }).map(conv =&gt; ({ ...conv, typingUsers: [] })); // Add typingUsers array&#10;            setConversations(processedData);&#10;        } catch (error) {&#10;            console.error('Failed to load conversations:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, []);&#10;&#10;    // Connect to WebSocket&#10;    useEffect(() =&gt; {&#10;        const conversationIdsRefCurrent = conversationIdsRef.current; // Copy ref for cleanup&#10;&#10;        if (!wsConnectedRef.current) {&#10;            webSocketService.connect(&#10;                () =&gt; {&#10;                    console.log('✅ WebSocket connected');&#10;                    setIsConnected(true);&#10;                    wsConnectedRef.current = true;&#10;&#10;                    // Lấy userId từ WebSocket service (đã được fetch từ backend)&#10;                    const userId = webSocketService.getCurrentUserId();&#10;                    setCurrentUserId(userId);&#10;&#10;                    // Subscribe to user queue for unread counts&#10;                    webSocketService.subscribeToUserQueue(&#10;                        (unreadDTO) =&gt; {&#10;                            // Update unread count for conversation&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === unreadDTO.conversationId&#10;                                    ? { ...conv, unreadCount: unreadDTO.count }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('WebSocket error:', error);&#10;                        }&#10;                    );&#10;&#10;                    // Subscribe to conversation updates&#10;                    webSocketService.subscribeToConversationUpdates(&#10;                        (updateDTO) =&gt; {&#10;                            // Update conversation with new last message and unread count&#10;                            let lastMessageContent = updateDTO.lastMessageContent;&#10;                            if (updateDTO.lastMessageContent?.startsWith('LOCATION:')) {&#10;                                lastMessageContent = 'Vị trí';&#10;                            }&#10;&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === updateDTO.conversationId&#10;                                    ? {&#10;                                        ...conv,&#10;                                        lastMessageContent: lastMessageContent,&#10;                                        lastMessageSenderId: updateDTO.lastMessageSenderId,&#10;                                        lastMessageAt: updateDTO.lastMessageAt,&#10;                                        unreadCount: updateDTO.unreadCount&#10;                                    }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('Conversation update error:', error);&#10;                        }&#10;                    );&#10;                },&#10;                (error) =&gt; {&#10;                    console.error('WebSocket connection failed:', error);&#10;                    setIsConnected(false);&#10;                    wsConnectedRef.current = false;&#10;                }&#10;            );&#10;        }&#10;&#10;        return () =&gt; {&#10;            if (wsConnectedRef.current) {&#10;                webSocketService.disconnect();&#10;                wsConnectedRef.current = false;&#10;                // Clear subscription tracking to force re-subscribe on next connect&#10;                conversationIdsRefCurrent.clear();&#10;                console.log(' WebSocket disconnected, cleared subscription tracking');&#10;            }&#10;        };&#10;    }, []);&#10;&#10;    // Load conversations on mount - CRITICAL: Load BEFORE subscribing&#10;    useEffect(() =&gt; {&#10;        console.log(' Loading conversations on mount');&#10;        loadConversations();&#10;    }, [loadConversations]);&#10;&#10;    // Subscribe to all conversations for both messages and typing&#10;    // Only re-run when isConnected changes, NOT when conversations state updates&#10;    useEffect(() =&gt; {&#10;        if (!isConnected) return;&#10;&#10;        console.log(' Subscribe effect running (on connection change):', {&#10;            isConnected,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        // This effect should NOT re-run when conversations state changes&#10;        // We'll use a separate effect to handle new conversations&#10;&#10;        // Cleanup when component unmounts or connection changes&#10;        return () =&gt; {&#10;            console.log(' Cleaning up all subscriptions due to unmount/disconnect');&#10;            // Clear all tracked IDs to force re-subscribe on reconnect&#10;            conversationIdsRef.current.clear();&#10;        };&#10;    }, [isConnected]);&#10;&#10;    // Separate effect to subscribe to NEW conversations when they appear&#10;    useEffect(() =&gt; {&#10;        console.log(' Effect 2 triggered:', {&#10;            isConnected,&#10;            conversationsLength: conversations.length,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        if (!isConnected) {&#10;            console.log('⏸️ Waiting for connection...');&#10;            return;&#10;        }&#10;        &#10;        if (conversations.length === 0) {&#10;            console.log('⏸️ No conversations yet, waiting...');&#10;            return;&#10;        }&#10;&#10;        console.log('✅ Ready to subscribe! Processing conversations...');&#10;&#10;        let subscribedCount = 0;&#10;        let skippedCount = 0;&#10;&#10;        conversations.forEach(conv =&gt; {&#10;            // Only subscribe to NEW conversations (not already in ref)&#10;            if (conversationIdsRef.current.has(conv.id)) {&#10;                // Already subscribed, do nothing&#10;                console.log(`⏭️ Skipping ${conv.id} (already subscribed)`);&#10;                skippedCount++;&#10;                return;&#10;            }&#10;&#10;            console.log(` New conversation detected: ${conv.id}, will subscribe`);&#10;&#10;            // Create message callback with closure over conv.id&#10;            const messageCallback = (message) =&gt; {&#10;                console.log(' SideChat received new message for conv', conv.id, ':', message);&#10;&#10;                // Process location messages&#10;                let lastMessageContent = message.content;&#10;                if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                    lastMessageContent = 'Vị trí';&#10;                } else if (message.isLocation) {&#10;                    lastMessageContent = 'Vị trí';&#10;                }&#10;&#10;                // Update conversation's last message&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        console.log(`✏️ Updating last message for conv ${conv.id}:`, lastMessageContent);&#10;                        return {&#10;                            ...c,&#10;                            lastMessageContent: lastMessageContent,&#10;                            lastMessageSenderId: message.senderId,&#10;                            lastMessageAt: message.timestamp || new Date().toISOString(),&#10;                        };&#10;                    }&#10;                    return c;&#10;                }));&#10;            };&#10;&#10;            // Create typing callback&#10;            const typingCallback = (typingDTO) =&gt; {&#10;                console.log('SideChat received typing:', typingDTO);&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conv.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;                }));&#10;            };&#10;&#10;            // Subscribe to messages AND typing for this conversation&#10;            webSocketService.subscribeToConversation(&#10;                conv.id,&#10;                messageCallback,&#10;                typingCallback,&#10;                null&#10;            );&#10;&#10;            // Mark as subscribed (IMPORTANT: callbacks will persist via WebSocketService)&#10;            conversationIdsRef.current.add(conv.id);&#10;            subscribedCount++;&#10;&#10;            console.log(` SideChat subscribed to conversation ${conv.id}`);&#10;        });&#10;&#10;        console.log(` Subscribe summary: ${subscribedCount} new, ${skippedCount} skipped, ${conversationIdsRef.current.size} total tracked`);&#10;&#10;        // NO cleanup function here - subscriptions persist across state updates&#10;        // Cleanup only happens in the isConnected effect above&#10;    }, [conversations, isConnected]);&#10;&#10;    // Listen for openChatWindow event from Profile Page&#10;    useEffect(() =&gt; {&#10;        const handleOpenChatWindow = (event) =&gt; {&#10;            const { conversation, minimized } = event.detail;&#10;&#10;            if (!conversation) return;&#10;&#10;            // Add to conversations list if not exists&#10;            setConversations(prev =&gt; {&#10;                const exists = prev.find(c =&gt; c.id === conversation.id);&#10;                if (!exists) {&#10;                    return [conversation, ...prev];&#10;                }&#10;                return prev;&#10;            });&#10;&#10;            // Open chat window&#10;            setOpenChatWindows(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                newMap.set(conversation.id, { ...conversation, minimized: minimized || false });&#10;                return newMap;&#10;            });&#10;&#10;            setActiveFriend(conversation.id);&#10;        };&#10;&#10;        window.addEventListener('openChatWindow', handleOpenChatWindow);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('openChatWindow', handleOpenChatWindow);&#10;        };&#10;    }, []);&#10;&#10;    // Listen for typing status updates from ChatWindow&#10;    useEffect(() =&gt; {&#10;        const handleTypingStatus = (event) =&gt; {&#10;            const { conversationId, isTyping, userId } = event.detail;&#10;            console.log('SideChat handling typingStatus:', { conversationId, isTyping, userId });&#10;            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                if (conv.id === conversationId) {&#10;                    let newTypingUsers = [...conv.typingUsers];&#10;                    if (isTyping) {&#10;                        if (!newTypingUsers.includes(userId)) {&#10;                            newTypingUsers.push(userId);&#10;                        }&#10;                    } else {&#10;                        newTypingUsers = newTypingUsers.filter(id =&gt; id !== userId);&#10;                    }&#10;                    console.log('Updated typingUsers for conv', conv.id, ':', newTypingUsers);&#10;                    return { ...conv, typingUsers: newTypingUsers };&#10;                }&#10;                return conv;&#10;            }));&#10;        };&#10;&#10;        window.addEventListener('typingStatus', handleTypingStatus);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('typingStatus', handleTypingStatus);&#10;        };&#10;    }, []);&#10;&#10;    const handleChatToggle = useCallback(() =&gt; {&#10;        setIsChatOpen(prev =&gt; !prev);&#10;    }, []);&#10;&#10;    const handleCloseChatPopup = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleOverlayClick = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleFriendClick = useCallback(async (conversation) =&gt; {&#10;        setActiveFriend(conversation.id);&#10;        setIsChatOpen(false);&#10;&#10;        // Mark as read&#10;        try {&#10;            await ChatService.markAsRead(conversation.id);&#10;            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                conv.id === conversation.id ? { ...conv, unreadCount: 0 } : conv&#10;            ));&#10;        } catch (error) {&#10;            console.error('Failed to mark as read:', error);&#10;        }&#10;&#10;        // Open chat window&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            if (!newMap.has(conversation.id)) {&#10;                newMap.set(conversation.id, { ...conversation, minimized: false });&#10;            } else {&#10;                const existing = newMap.get(conversation.id);&#10;                newMap.set(conversation.id, { ...existing, minimized: false });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleCloseChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            newMap.delete(conversationId);&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleMinimizeChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            const chatWindow = newMap.get(conversationId);&#10;            if (chatWindow) {&#10;                newMap.set(conversationId, { ...chatWindow, minimized: !chatWindow.minimized });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    // Handle new messages from WebSocket&#10;    const handleNewMessage = useCallback((conversationId, message) =&gt; {&#10;        let lastMessageContent = message.content;&#10;        if (message.content?.startsWith('LOCATION:')) {&#10;            lastMessageContent = 'Vị trí';&#10;        }&#10;&#10;        setConversations(prev =&gt; prev.map(conv =&gt; {&#10;            if (conv.id === conversationId) {&#10;                return {&#10;                    ...conv,&#10;                    lastMessageContent: lastMessageContent,&#10;                    lastMessageTime: message.timestamp,&#10;                    lastMessageSender: message.senderName,&#10;                };&#10;            }&#10;            return conv;&#10;        }));&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        const chatToggle = document.getElementById('chatToggle');&#10;        if (chatToggle) {&#10;            chatToggle.addEventListener('click', handleChatToggle);&#10;            return () =&gt; chatToggle.removeEventListener('click', handleChatToggle);&#10;        }&#10;    }, [handleChatToggle]);&#10;&#10;    useEffect(() =&gt; {&#10;        const handleEscape = (e) =&gt; {&#10;            if (e.key === 'Escape' &amp;&amp; isChatOpen) {&#10;                setIsChatOpen(false);&#10;            }&#10;        };&#10;&#10;        document.addEventListener('keydown', handleEscape);&#10;        return () =&gt; document.removeEventListener('keydown', handleEscape);&#10;    }, [isChatOpen]);&#10;&#10;    // Filter conversations based on search query&#10;    const filteredConversations = conversations.filter(conv =&gt; {&#10;        const displayName = conv.isGroup ? conv.groupName : conv.otherUser?.displayName || '';&#10;        return displayName.toLowerCase().includes(searchQuery.toLowerCase());&#10;    });&#10;&#10;    // Get display info for conversation&#10;    const getConversationDisplay = (conv) =&gt; {&#10;        if (conv.isGroup) {&#10;            return {&#10;                name: conv.groupName || 'Nhóm',&#10;                avatar: conv.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conv.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conv.otherUser || conv.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.online ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    };&#10;&#10;    // Format last message display&#10;    const getLastMessageDisplay = (conv) =&gt; {&#10;        if (conv.typingUsers &amp;&amp; conv.typingUsers.length &gt; 0) {&#10;            return (&#10;                &lt;span className=&quot;typing-indicator-text&quot;&gt;&#10;                    &lt;span className=&quot;typing-dots-inline&quot;&gt;&#10;                        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&#10;                    &lt;/span&gt;&#10;                    {' '}đang nhập&#10;                &lt;/span&gt;&#10;            );&#10;        }&#10;&#10;        if (conv.lastMessageContent) {&#10;            const prefix = conv.lastMessageSenderId === currentUserId ? 'Bạn: ' : '';&#10;            return `${prefix}${conv.lastMessageContent}`;&#10;        }&#10;&#10;        return 'Bắt đầu trò chuyện';&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            {/* Chat Popup Overlay */}&#10;            &lt;div&#10;                className={`chat-popup-overlay ${isChatOpen ? 'is-active' : ''}`}&#10;                id=&quot;chatPopupOverlay&quot;&#10;                onClick={handleOverlayClick}&#10;                role=&quot;button&quot;&#10;                tabIndex={0}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleOverlayClick()}&#10;                aria-label=&quot;Close chat&quot;&#10;            /&gt;&#10;&#10;            {/* Side Chat */}&#10;            &lt;div className={`side-chat ${isChatOpen ? 'is-active' : ''}`} id=&quot;sideChat&quot;&gt;&#10;                &lt;div className=&quot;chat-header&quot;&gt;&#10;                    &lt;h3&gt;Đoạn chat&lt;/h3&gt;&#10;                    &lt;button className=&quot;chat-close-btn&quot; id=&quot;chatCloseBtn&quot; onClick={handleCloseChatPopup}&gt;×&lt;/button&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Search Box */}&#10;                &lt;div className=&quot;chat-search-box&quot;&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        placeholder=&quot;Tìm kiếm đoạn chat...&quot;&#10;                        value={searchQuery}&#10;                        onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;                        className=&quot;chat-search-input&quot;&#10;                    /&gt;&#10;                    {searchQuery &amp;&amp; (&#10;                        &lt;button&#10;                            className=&quot;chat-search-clear&quot;&#10;                            onClick={() =&gt; setSearchQuery('')}&#10;                        &gt;&#10;                            ×&#10;                        &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;chat-friends-list&quot;&gt;&#10;                    {isLoading ? (&#10;                        &lt;div className=&quot;chat-loading&quot;&gt;Đang tải...&lt;/div&gt;&#10;                    ) : filteredConversations.length === 0 ? (&#10;                        &lt;div className=&quot;chat-empty&quot;&gt;Không có đoạn chat nào&lt;/div&gt;&#10;                    ) : (&#10;                        filteredConversations.map((conv) =&gt; {&#10;                            const display = getConversationDisplay(conv);&#10;                            return (&#10;                                &lt;div&#10;                                    key={conv.id}&#10;                                    className={`friend-item ${activeFriend === conv.id ? 'active' : ''}`}&#10;                                    onClick={() =&gt; handleFriendClick(conv)}&#10;                                    role=&quot;button&quot;&#10;                                    tabIndex={0}&#10;                                    onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleFriendClick(conv)}&#10;                                    data-friend={conv.id}&#10;                                &gt;&#10;                                    &lt;img src={display.avatar} alt=&quot;Avatar&quot; className=&quot;friend-avatar&quot; /&gt;&#10;                                    &lt;div className=&quot;friend-info&quot;&gt;&#10;                                        &lt;div className=&quot;friend-name&quot;&gt;{display.name}&lt;/div&gt;&#10;                                        &lt;div className=&quot;friend-status&quot;&gt;&#10;                                            {getLastMessageDisplay(conv)}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                    {conv.unreadCount &gt; 0 &amp;&amp; (&#10;                                        &lt;div className=&quot;unread-count&quot;&gt;{conv.unreadCount}&lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            );&#10;                        })&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {!isConnected &amp;&amp; (&#10;                    &lt;div className=&quot;chat-connection-status&quot;&gt;&#10;                        &lt;span className=&quot;connection-indicator offline&quot;&gt;●&lt;/span&gt;&#10;                        {' '}Đang kết nối lại...&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Chat Windows Container */}&#10;            &lt;div className=&quot;chat-windows-container&quot; id=&quot;chatWindowsContainer&quot;&gt;&#10;                {Array.from(openChatWindows.entries()).map(([conversationId, chatData]) =&gt; {&#10;                    const conversation = conversations.find(c =&gt; c.id === conversationId) || chatData;&#10;                    return (&#10;                        &lt;ChatWindow&#10;                            key={conversationId}&#10;                            conversation={conversation}&#10;                            minimized={chatData.minimized}&#10;                            currentUserId={currentUserId}&#10;                            unreadCount={conversation.unreadCount || 0}&#10;                            onClose={() =&gt; handleCloseChatWindow(conversationId)}&#10;                            onMinimize={() =&gt; handleMinimizeChatWindow(conversationId)}&#10;                            onNewMessage={(message) =&gt; handleNewMessage(conversationId, message)}&#10;                        /&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>