<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/social-map-fe/src/components/Chat/ChatWindow.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/components/Chat/ChatWindow.jsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;import './ChatWindows.css';&#10;&#10;export default function ChatWindow({ conversation, minimized, currentUserId, onClose, onMinimize, onNewMessage, unreadCount = 0, onMarkAsRead }) {&#10;    const [messages, setMessages] = useState([]);&#10;    const [inputValue, setInputValue] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [hasMore, setHasMore] = useState(true);&#10;    const [currentPage, setCurrentPage] = useState(0);&#10;    const [typingUsers, setTypingUsers] = useState([]);&#10;    const [isSending, setIsSending] = useState(false);&#10;&#10;    const messagesEndRef = useRef(null);&#10;    const messagesContainerRef = useRef(null);&#10;    const lastScrollHeightRef = useRef(0);&#10;    const isLoadingMoreRef = useRef(false);&#10;    const inputRef = useRef(null);&#10;    const navigate = useNavigate();&#10;&#10;    // Track if user is currently typing to avoid unnecessary cleanup messages&#10;    const isTypingRef = useRef(false);&#10;&#10;    // Get display info&#10;    const getDisplayInfo = useCallback(() =&gt; {&#10;        if (!conversation) return { name: '', avatar: '', status: '' };&#10;&#10;        if (conversation.isGroup) {&#10;            return {&#10;                name: conversation.groupName || 'Nhóm',&#10;                avatar: conversation.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conversation.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.isOnline ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    }, [conversation, currentUserId]);&#10;&#10;    const displayInfo = getDisplayInfo();&#10;&#10;    // Load initial messages&#10;    const loadMessages = useCallback(async (page = 0) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        try {&#10;            setIsLoading(true);&#10;            const response = await ChatService.getMessages(conversation.id, { page, size: 20 });&#10;&#10;            if (page === 0) {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    }&#10;                    return msg;&#10;                }).reverse();&#10;                setMessages(processedMessages);&#10;            } else {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    } // ✅ thêm dấu đóng if&#10;                    return msg;&#10;                }).reverse();&#10;&#10;                setMessages(prev =&gt; [...processedMessages, ...prev]);&#10;            }&#10;&#10;            setHasMore(!response.last);&#10;            setCurrentPage(page);&#10;        } catch (error) {&#10;            console.error('Failed to load messages:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;            isLoadingMoreRef.current = false;&#10;        }&#10;    }, [conversation?.id]);&#10;&#10;    // Load more messages on scroll&#10;    const handleScroll = useCallback(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (!container || isLoadingMoreRef.current || !hasMore) return;&#10;&#10;        if (container.scrollTop === 0) {&#10;            isLoadingMoreRef.current = true;&#10;            lastScrollHeightRef.current = container.scrollHeight;&#10;            loadMessages(currentPage + 1);&#10;        }&#10;    }, [currentPage, hasMore, loadMessages]);&#10;&#10;    // Maintain scroll position after loading more&#10;    useEffect(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (container &amp;&amp; lastScrollHeightRef.current &gt; 0) {&#10;            const newScrollHeight = container.scrollHeight;&#10;            container.scrollTop = newScrollHeight - lastScrollHeightRef.current;&#10;            lastScrollHeightRef.current = 0;&#10;        }&#10;    }, [messages]);&#10;&#10;    // Scroll to bottom for new messages&#10;    const scrollToBottom = useCallback((smooth = false) =&gt; {&#10;        if (messagesContainerRef.current) {&#10;            messagesContainerRef.current.scrollTo({&#10;                top: messagesContainerRef.current.scrollHeight,&#10;                behavior: smooth ? 'smooth' : 'auto'&#10;            });&#10;        }&#10;    }, []);&#10;&#10;    // Load messages on conversation change&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id) {&#10;            setMessages([]);&#10;            setCurrentPage(0);&#10;            setHasMore(true);&#10;            loadMessages(0);&#10;        }&#10;    }, [conversation?.id, loadMessages]);&#10;&#10;    // Mark as read when conversation opens or unminimizes&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id &amp;&amp; !minimized) {&#10;            ChatService.markAsRead(conversation.id).catch(console.error);&#10;            if (onMarkAsRead) {&#10;                onMarkAsRead(conversation.id);&#10;            }&#10;        }&#10;    }, [conversation?.id, minimized, onMarkAsRead]);&#10;&#10;    // Subscribe to WebSocket updates&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Create callbacks with stable references for cleanup&#10;        const messageCallback = (message) =&gt; {&#10;            console.log(' ChatWindow received new message:', message);&#10;            // New message&#10;            let processedMessage = message;&#10;&#10;            // Handle location messages&#10;            if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                try {&#10;                    const locationData = JSON.parse(message.content.substring(9));&#10;                    processedMessage = {&#10;                        ...message,&#10;                        content: locationData,&#10;                        isLocation: true&#10;                    };&#10;                } catch (e) {&#10;                    console.error('Failed to parse location message:', e);&#10;                }&#10;            }&#10;&#10;            setMessages(prev =&gt; [...prev, processedMessage]);&#10;            scrollToBottom(true);&#10;&#10;            // Notify parent&#10;            if (onNewMessage) {&#10;                onNewMessage(processedMessage);&#10;            }&#10;&#10;            // Mark as read if window is open&#10;            if (!minimized) {&#10;                webSocketService.sendMarkAsRead({ conversationId: conversation.id });&#10;            }&#10;        };&#10;&#10;        const typingCallback = (typingDTO) =&gt; {&#10;            // Typing indicator&#10;            console.log(' ChatWindow received typing from WebSocket:', typingDTO, 'currentUserId:', currentUserId);&#10;&#10;            // Handle both 'typing' and 'isTyping' field names from backend&#10;            const isTyping = typingDTO.typing ?? typingDTO.isTyping ?? false;&#10;&#10;            if (typingDTO.userId !== currentUserId) {&#10;                if (isTyping) {&#10;                    // User started typing&#10;                    const user = conversation.isGroup&#10;                        ? conversation.members?.find(m =&gt; m.userId === typingDTO.userId)&#10;                        : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                    const avatar = user?.avatarUrl || '/channels/myprofile.jpg';&#10;                    const name = user?.fullName || typingDTO.username || 'User';&#10;&#10;                    setTypingUsers(prev =&gt; {&#10;                        const alreadyTyping = prev.some(u =&gt; u.userId === typingDTO.userId);&#10;                        if (alreadyTyping) {&#10;                            console.log(`⏭️ User ${typingDTO.userId} already in typingUsers, skipping`);&#10;                            return prev;&#10;                        }&#10;                        const newUsers = [...prev, { userId: typingDTO.userId, avatar, name }];&#10;                        console.log(`✍️ Added user ${typingDTO.userId} (${name}) to typingUsers:`, newUsers);&#10;                        return newUsers;&#10;                    });&#10;                } else {&#10;                    // User stopped typing&#10;                    setTypingUsers(prev =&gt; {&#10;                        const newUsers = prev.filter(u =&gt; u.userId !== typingDTO.userId);&#10;                        console.log(`⏹️ Removed user ${typingDTO.userId} from typingUsers. Before:`, prev.length, 'After:', newUsers.length);&#10;                        return newUsers;&#10;                    });&#10;                }&#10;&#10;                // Dispatch event to update SideChat (if needed)&#10;                console.log(' ChatWindow dispatching typingStatus event');&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conversation.id, isTyping: isTyping, userId: typingDTO.userId }&#10;                }));&#10;            } else {&#10;                console.log('⏭️ Skipping typing from self (currentUser)');&#10;            }&#10;        };&#10;&#10;        const updateCallback = (updatedMessage) =&gt; {&#10;            // Message edited/deleted&#10;            setMessages(prev =&gt; prev.map(msg =&gt;&#10;                msg.id === updatedMessage.id ? updatedMessage : msg&#10;            ));&#10;        };&#10;&#10;        // Subscribe with callback references&#10;        console.log(' ChatWindow subscribing to conversation:', conversation.id);&#10;        webSocketService.subscribeToConversation(&#10;            conversation.id,&#10;            messageCallback,&#10;            typingCallback,&#10;            updateCallback&#10;        );&#10;&#10;        return () =&gt; {&#10;            // Cleanup: Send typing stopped ONLY if user was typing&#10;            if (isTypingRef.current) {&#10;                console.log(' ChatWindow cleanup: user was typing, sending stopped');&#10;                webSocketService.sendTypingStatus({&#10;                    conversationId: conversation.id,&#10;                    isTyping: false&#10;                });&#10;                isTypingRef.current = false;&#10;            }&#10;&#10;            // Unsubscribe ONLY ChatWindow's callbacks (not SideChat's!)&#10;            console.log(' ChatWindow cleanup: unsubscribing callbacks for', conversation.id);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}`, messageCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/typing`, typingCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/update`, updateCallback);&#10;        };&#10;    }, [conversation?.id, currentUserId]);&#10;&#10;    // Handle page reload/close - cleanup typing indicator&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        const handleBeforeUnload = () =&gt; {&#10;            // Only send if user was actually typing&#10;            if (isTypingRef.current) {&#10;                console.log('⚠️ Page unloading, user was typing, sending stopped');&#10;                if (webSocketService?.stompClient?.connected) {&#10;                    webSocketService.sendTypingStatus({&#10;                        conversationId: conversation.id,&#10;                        isTyping: false&#10;                    });&#10;                }&#10;            }&#10;        };&#10;&#10;        window.addEventListener('beforeunload', handleBeforeUnload);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('beforeunload', handleBeforeUnload);&#10;        };&#10;    }, [conversation?.id]);&#10;&#10;    // Send typing indicator&#10;    const sendTypingIndicator = useCallback((isTyping) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Track typing state&#10;        isTypingRef.current = isTyping;&#10;&#10;        console.log('⌨️ sendTypingIndicator called:', {&#10;            isTyping,&#10;            conversationId: conversation.id,&#10;            wsConnected: webSocketService?.stompClient?.connected&#10;        });&#10;&#10;        webSocketService.sendTypingStatus({&#10;            conversationId: conversation.id,&#10;            isTyping&#10;        });&#10;&#10;        console.log('✅ Typing status sent to backend');&#10;    }, [conversation?.id]);&#10;&#10;    // Handle input change&#10;    const handleInputChange = useCallback((e) =&gt; {&#10;        const newValue = e.target.value;&#10;        console.log('handleInputChange: newValue:', JSON.stringify(newValue), 'trim:', newValue.trim(), 'length:', newValue.length);&#10;        setInputValue(newValue);&#10;&#10;        // Send typing indicator based on whether there's text&#10;        const shouldType = newValue.length &gt; 0;&#10;        console.log('shouldType:', shouldType);&#10;        if (shouldType) {&#10;            sendTypingIndicator(true);&#10;        } else {&#10;            sendTypingIndicator(false);&#10;        }&#10;    }, [sendTypingIndicator]);&#10;&#10;    // Send message&#10;    const handleSend = useCallback(async () =&gt; {&#10;        const messageText = inputValue.trim();&#10;        if (!messageText || isSending || !conversation?.id) return;&#10;&#10;        try {&#10;            setIsSending(true);&#10;&#10;            // Send via REST API - backend will save to DB and broadcast via WebSocket&#10;            await ChatService.sendMessage(conversation.id, {&#10;                content: messageText,&#10;                messageType: 'TEXT'&#10;            });&#10;&#10;            setInputValue('');&#10;            sendTypingIndicator(false);&#10;&#10;            // Focus back to input&#10;            setTimeout(() =&gt; inputRef.current?.focus(), 0);&#10;        } catch (error) {&#10;            console.error('Failed to send message:', error);&#10;        } finally {&#10;            setIsSending(false);&#10;        }&#10;    }, [inputValue, isSending, conversation?.id, sendTypingIndicator]);&#10;&#10;    // Handle key press&#10;    const handleKeyPress = useCallback((e) =&gt; {&#10;        if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {&#10;            e.preventDefault();&#10;            handleSend();&#10;        }&#10;    }, [handleSend]);&#10;&#10;    // Linkify text&#10;    const linkify = (text) =&gt; {&#10;        if (!text) return '';&#10;        const urlRegex = /(https?:\/\/[^\s]+)/g;&#10;        return text.replace(urlRegex, (url) =&gt; {&#10;            return `&lt;a href=&quot;${url}&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;message-link&quot;&gt;${url}&lt;/a&gt;`;&#10;        });&#10;    };&#10;&#10;    // Format message time&#10;    const formatTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        const now = new Date();&#10;        const diffInHours = (now - date) / (1000 * 60 * 60);&#10;&#10;        if (diffInHours &lt; 24) {&#10;            return date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });&#10;        } else {&#10;            return date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;        }&#10;    };&#10;&#10;    return (&#10;        &lt;div&#10;            className={`chat-window ${minimized ? 'minimized' : 'open'}`}&#10;            data-conversation-id={conversation?.id}&#10;            data-friend-id={conversation?.id}&#10;        &gt;&#10;            &lt;div className={`chat-window-header ${unreadCount &gt; 0 ? 'unread' : ''}`} onClick={onMinimize}&gt;&#10;                &lt;img&#10;                    src={displayInfo.avatar}&#10;                    alt=&quot;Avatar&quot;&#10;                    className=&quot;chat-window-avatar&quot;&#10;                    onClick={(e) =&gt; {&#10;                        e.stopPropagation();&#10;                        if (!conversation.isGroup) {&#10;                            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                            if (otherUser?.userId) {&#10;                                navigate(`/profile/${otherUser.userId}`);&#10;                            }&#10;                        }&#10;                    }}&#10;                /&gt;&#10;                &lt;div className=&quot;chat-window-info&quot;&gt;&#10;                    &lt;div className=&quot;chat-window-name&quot;&gt;{displayInfo.name}&lt;/div&gt;&#10;                    &lt;div className=&quot;chat-window-status&quot;&gt;{displayInfo.status}&lt;/div&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;chat-window-controls&quot;&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-minimize&quot;&#10;                        title=&quot;Thu nhỏ&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onMinimize();&#10;                        }}&#10;                    &gt;&#10;                        −&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-close&quot;&#10;                        title=&quot;Đóng&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onClose();&#10;                        }}&#10;                    &gt;&#10;                        ×&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div&#10;                className=&quot;chat-window-messages&quot;&#10;                ref={messagesContainerRef}&#10;                onScroll={handleScroll}&#10;            &gt;&#10;                {isLoading &amp;&amp; currentPage === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-loading&quot;&gt;Đang tải tin nhắn...&lt;/div&gt;&#10;                )}&#10;&#10;                {hasMore &amp;&amp; !isLoading &amp;&amp; currentPage &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;load-more-messages&quot;&gt;&#10;                        &lt;button onClick={() =&gt; loadMessages(currentPage + 1)}&gt;&#10;                            Tải thêm tin nhắn&#10;                        &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {messages.map((msg, index) =&gt; {&#10;                    const isSent = msg.senderId === currentUserId;&#10;                    const showAvatar = !isSent &amp;&amp; (index === 0 || messages[index - 1].senderId !== msg.senderId);&#10;&#10;                    return (&#10;                        &lt;div&#10;                            key={msg.id || index}&#10;                            className={`chat-window-message ${isSent ? 'sent' : 'received'}`}&#10;                        &gt;&#10;                            {showAvatar &amp;&amp; !isSent &amp;&amp; (&#10;                                &lt;img&#10;                                    src={msg.senderAvatar || displayInfo.avatar}&#10;                                    alt=&quot;Avatar&quot;&#10;                                    className=&quot;chat-window-message-avatar&quot;&#10;                                /&gt;&#10;                            )}&#10;                            {!showAvatar &amp;&amp; !isSent &amp;&amp; &lt;div className=&quot;chat-window-message-avatar-spacer&quot; /&gt;}&#10;&#10;                            &lt;div className=&quot;chat-window-message-content&quot;&gt;&#10;                                {!isSent &amp;&amp; showAvatar &amp;&amp; (&#10;                                    &lt;div className=&quot;chat-window-message-sender&quot;&gt;{msg.senderName}&lt;/div&gt;&#10;                                )}&#10;                                {msg.isLocation ? (&#10;                                    &lt;div className=&quot;location-message-card&quot;&gt;&#10;                                        &lt;div className=&quot;location-card-image&quot;&gt;&#10;                                            &lt;img src={msg.content.image} alt={msg.content.name} /&gt;&#10;                                            &lt;div className=&quot;location-card-overlay&quot;&gt;&lt;/div&gt;&#10;                                        &lt;/div&gt;&#10;                                        &lt;div className=&quot;location-card-content&quot;&gt;&#10;                                            &lt;div className=&quot;location-card-title&quot;&gt;{msg.content.name}&lt;/div&gt;&#10;                                            &lt;div className=&quot;location-card-description&quot;&gt;{msg.content.description}&lt;/div&gt;&#10;                                            &lt;button&#10;                                                className=&quot;location-card-button&quot;&#10;                                                onClick={() =&gt; window.focusLocation?.(msg.content.coordinates[0], msg.content.coordinates[1], msg.content.name)}&#10;                                            &gt;&#10;                                                ️ Xem trên bản đồ&#10;                                            &lt;/button&gt;&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                ) : (&#10;                                    &lt;div&#10;                                        className=&quot;chat-window-message-text&quot;&#10;                                        dangerouslySetInnerHTML={{ __html: linkify(msg.content) }}&#10;                                    /&gt;&#10;                                )}&#10;                                &lt;div className=&quot;chat-window-message-time&quot;&gt;&#10;                                    {formatTime(msg.timestamp)}&#10;                                    {msg.edited &amp;&amp; &lt;span className=&quot;edited-indicator&quot;&gt; (đã chỉnh sửa)&lt;/span&gt;}&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    );&#10;                })}&#10;&#10;                {typingUsers.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-window-message received typing-indicator-message&quot;&gt;&#10;                        {console.log('rendering typing indicator, typingUsers length:', typingUsers.length, 'users:', typingUsers.map(u =&gt; u.userId))}&#10;                        &lt;img src={typingUsers[0].avatar} alt=&quot;Avatar&quot; className=&quot;chat-window-message-avatar&quot; /&gt;&#10;                        &lt;div className=&quot;typing-indicator&quot;&gt;&#10;                            &lt;div className=&quot;typing-dots&quot;&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div ref={messagesEndRef} /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className=&quot;chat-window-input-container&quot;&gt;&#10;                &lt;input&#10;                    type=&quot;text&quot;&#10;                    placeholder=&quot;Aa&quot;&#10;                    className=&quot;chat-window-input&quot;&#10;                    value={inputValue}&#10;                    onInput={handleInputChange}&#10;                    onKeyPress={handleKeyPress}&#10;                    onFocus={() =&gt; { if (inputValue.length &gt; 0) sendTypingIndicator(true); }}&#10;                    onBlur={() =&gt; sendTypingIndicator(false)}&#10;                    disabled={isSending}&#10;                    ref={inputRef}&#10;                /&gt;&#10;                &lt;button&#10;                    className=&quot;chat-window-send&quot;&#10;                    onClick={handleSend}&#10;                    disabled={!inputValue.trim() || isSending}&#10;                &gt;&#10;                    {isSending ? '...' : '→'}&#10;                &lt;/button&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useRef, useCallback } from 'react';&#13;&#10;import { useNavigate } from 'react-router-dom';&#13;&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#13;&#10;import './ChatWindows.css';&#13;&#10;&#13;&#10;export default function ChatWindow({ conversation, minimized, currentUserId, onClose, onMinimize, onNewMessage, unreadCount = 0, onMarkAsRead }) {&#13;&#10;    const [messages, setMessages] = useState([]);&#13;&#10;    const [inputValue, setInputValue] = useState('');&#13;&#10;    const [isLoading, setIsLoading] = useState(false);&#13;&#10;    const [hasMore, setHasMore] = useState(true);&#13;&#10;    const [currentPage, setCurrentPage] = useState(0);&#13;&#10;    const [typingUsers, setTypingUsers] = useState([]);&#13;&#10;    const [isSending, setIsSending] = useState(false);&#13;&#10;&#13;&#10;    const messagesEndRef = useRef(null);&#13;&#10;    const messagesContainerRef = useRef(null);&#13;&#10;    const lastScrollHeightRef = useRef(0);&#13;&#10;    const isLoadingMoreRef = useRef(false);&#13;&#10;    const inputRef = useRef(null);&#13;&#10;    const navigate = useNavigate();&#13;&#10;&#13;&#10;    // Track if user is currently typing to avoid unnecessary cleanup messages&#13;&#10;    const isTypingRef = useRef(false);&#13;&#10;&#13;&#10;    // Get display info&#13;&#10;    const getDisplayInfo = useCallback(() =&gt; {&#13;&#10;        if (!conversation) return { name: '', avatar: '', status: '' };&#13;&#10;&#13;&#10;        if (conversation.isGroup) {&#13;&#10;            return {&#13;&#10;                name: conversation.groupName || 'Nhóm',&#13;&#10;                avatar: conversation.groupAvatar || '/channels/myprofile.jpg',&#13;&#10;                status: `${conversation.members?.length || 0} thành viên`,&#13;&#10;            };&#13;&#10;        } else {&#13;&#10;            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#13;&#10;            return {&#13;&#10;                name: otherUser?.fullName || 'User',&#13;&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#13;&#10;                status: otherUser?.isOnline ? 'Đang hoạt động' : 'Không hoạt động',&#13;&#10;            };&#13;&#10;        }&#13;&#10;    }, [conversation, currentUserId]);&#13;&#10;&#13;&#10;    const displayInfo = getDisplayInfo();&#13;&#10;&#13;&#10;    // Load initial messages&#13;&#10;    const loadMessages = useCallback(async (page = 0) =&gt; {&#13;&#10;        if (!conversation?.id) return;&#13;&#10;&#13;&#10;        try {&#13;&#10;            setIsLoading(true);&#13;&#10;            const response = await ChatService.getMessages(conversation.id, { page, size: 20 });&#13;&#10;&#13;&#10;            if (page === 0) {&#13;&#10;                const processedMessages = response.content.map(msg =&gt; {&#13;&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#13;&#10;                        try {&#13;&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#13;&#10;                            return {&#13;&#10;                                ...msg,&#13;&#10;                                content: locationData,&#13;&#10;                                isLocation: true&#13;&#10;                            };&#13;&#10;                        } catch (e) {&#13;&#10;                            console.error('Failed to parse location message:', e);&#13;&#10;                            return msg;&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    return msg;&#13;&#10;                }).reverse();&#13;&#10;                setMessages(processedMessages);&#13;&#10;            } else {&#13;&#10;                const processedMessages = response.content.map(msg =&gt; {&#13;&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#13;&#10;                        try {&#13;&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#13;&#10;                            return {&#13;&#10;                                ...msg,&#13;&#10;                                content: locationData,&#13;&#10;                                isLocation: true&#13;&#10;                            };&#13;&#10;                        } catch (e) {&#13;&#10;                            console.error('Failed to parse location message:', e);&#13;&#10;                            return msg;&#13;&#10;                        }&#13;&#10;                    } // ✅ thêm dấu đóng if&#13;&#10;                    return msg;&#13;&#10;                }).reverse();&#13;&#10;&#13;&#10;                setMessages(prev =&gt; [...processedMessages, ...prev]);&#13;&#10;            }&#13;&#10;&#13;&#10;            setHasMore(!response.last);&#13;&#10;            setCurrentPage(page);&#13;&#10;        } catch (error) {&#13;&#10;            console.error('Failed to load messages:', error);&#13;&#10;        } finally {&#13;&#10;            setIsLoading(false);&#13;&#10;            isLoadingMoreRef.current = false;&#13;&#10;        }&#13;&#10;    }, [conversation?.id]);&#13;&#10;&#13;&#10;    // Load more messages on scroll&#13;&#10;    const handleScroll = useCallback(() =&gt; {&#13;&#10;        const container = messagesContainerRef.current;&#13;&#10;        if (!container || isLoadingMoreRef.current || !hasMore) return;&#13;&#10;&#13;&#10;        if (container.scrollTop === 0) {&#13;&#10;            isLoadingMoreRef.current = true;&#13;&#10;            lastScrollHeightRef.current = container.scrollHeight;&#13;&#10;            loadMessages(currentPage + 1);&#13;&#10;        }&#13;&#10;    }, [currentPage, hasMore, loadMessages]);&#13;&#10;&#13;&#10;    // Maintain scroll position after loading more&#13;&#10;    useEffect(() =&gt; {&#13;&#10;        const container = messagesContainerRef.current;&#13;&#10;        if (container &amp;&amp; lastScrollHeightRef.current &gt; 0) {&#13;&#10;            const newScrollHeight = container.scrollHeight;&#13;&#10;            container.scrollTop = newScrollHeight - lastScrollHeightRef.current;&#13;&#10;            lastScrollHeightRef.current = 0;&#13;&#10;        }&#13;&#10;    }, [messages]);&#13;&#10;&#13;&#10;    // Scroll to bottom for new messages&#13;&#10;    const scrollToBottom = useCallback((smooth = false) =&gt; {&#13;&#10;        if (messagesContainerRef.current) {&#13;&#10;            messagesContainerRef.current.scrollTo({&#13;&#10;                top: messagesContainerRef.current.scrollHeight,&#13;&#10;                behavior: smooth ? 'smooth' : 'auto'&#13;&#10;            });&#13;&#10;        }&#13;&#10;    }, []);&#13;&#10;&#13;&#10;    // Load messages on conversation change&#13;&#10;    useEffect(() =&gt; {&#13;&#10;        if (conversation?.id) {&#13;&#10;            setMessages([]);&#13;&#10;            setCurrentPage(0);&#13;&#10;            setHasMore(true);&#13;&#10;            loadMessages(0);&#13;&#10;        }&#13;&#10;    }, [conversation?.id, loadMessages]);&#13;&#10;&#13;&#10;    // Mark as read when conversation opens or unminimizes&#13;&#10;    useEffect(() =&gt; {&#13;&#10;        if (conversation?.id &amp;&amp; !minimized) {&#13;&#10;            ChatService.markAsRead(conversation.id).catch(console.error);&#13;&#10;            if (onMarkAsRead) {&#13;&#10;                onMarkAsRead(conversation.id);&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }, [conversation?.id, minimized, onMarkAsRead]);&#13;&#10;&#13;&#10;    // Subscribe to WebSocket updates&#13;&#10;    useEffect(() =&gt; {&#13;&#10;        if (!conversation?.id) return;&#13;&#10;&#13;&#10;        // Create callbacks with stable references for cleanup&#13;&#10;        const messageCallback = (message) =&gt; {&#13;&#10;            console.log(' ChatWindow received new message:', message);&#13;&#10;            // New message&#13;&#10;            let processedMessage = message;&#13;&#10;&#13;&#10;            // Handle location messages&#13;&#10;            if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#13;&#10;                try {&#13;&#10;                    const locationData = JSON.parse(message.content.substring(9));&#13;&#10;                    processedMessage = {&#13;&#10;                        ...message,&#13;&#10;                        content: locationData,&#13;&#10;                        isLocation: true&#13;&#10;                    };&#13;&#10;                } catch (e) {&#13;&#10;                    console.error('Failed to parse location message:', e);&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            setMessages(prev =&gt; [...prev, processedMessage]);&#13;&#10;            scrollToBottom(true);&#13;&#10;&#13;&#10;            // Notify parent&#13;&#10;            if (onNewMessage) {&#13;&#10;                onNewMessage(processedMessage);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Mark as read if window is open&#13;&#10;            if (!minimized) {&#13;&#10;                webSocketService.sendMarkAsRead({ conversationId: conversation.id });&#13;&#10;            }&#13;&#10;        };&#13;&#10;&#13;&#10;        const typingCallback = (typingDTO) =&gt; {&#13;&#10;            // Typing indicator&#13;&#10;            console.log(' ChatWindow received typing from WebSocket:', typingDTO, 'currentUserId:', currentUserId);&#13;&#10;&#13;&#10;            // Handle both 'typing' and 'isTyping' field names from backend&#13;&#10;            const isTyping = typingDTO.typing ?? typingDTO.isTyping ?? false;&#13;&#10;&#13;&#10;            if (typingDTO.userId !== currentUserId) {&#13;&#10;                if (isTyping) {&#13;&#10;                    // User started typing&#13;&#10;                    const user = conversation.isGroup&#13;&#10;                        ? conversation.members?.find(m =&gt; m.userId === typingDTO.userId)&#13;&#10;                        : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#13;&#10;                    const avatar = user?.avatarUrl || '/channels/myprofile.jpg';&#13;&#10;                    const name = user?.fullName || typingDTO.username || 'User';&#13;&#10;&#13;&#10;                    setTypingUsers(prev =&gt; {&#13;&#10;                        const alreadyTyping = prev.some(u =&gt; u.userId === typingDTO.userId);&#13;&#10;                        if (alreadyTyping) {&#13;&#10;                            console.log(`⏭️ User ${typingDTO.userId} already in typingUsers, skipping`);&#13;&#10;                            return prev;&#13;&#10;                        }&#13;&#10;                        const newUsers = [...prev, { userId: typingDTO.userId, avatar, name }];&#13;&#10;                        console.log(`✍️ Added user ${typingDTO.userId} (${name}) to typingUsers:`, newUsers);&#13;&#10;                        return newUsers;&#13;&#10;                    });&#13;&#10;                } else {&#13;&#10;                    // User stopped typing&#13;&#10;                    setTypingUsers(prev =&gt; {&#13;&#10;                        const newUsers = prev.filter(u =&gt; u.userId !== typingDTO.userId);&#13;&#10;                        console.log(`⏹️ Removed user ${typingDTO.userId} from typingUsers. Before:`, prev.length, 'After:', newUsers.length);&#13;&#10;                        return newUsers;&#13;&#10;                    });&#13;&#10;                }&#13;&#10;&#13;&#10;                // Dispatch event to update SideChat (if needed)&#13;&#10;                console.log(' ChatWindow dispatching typingStatus event');&#13;&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#13;&#10;                    detail: { conversationId: conversation.id, isTyping: isTyping, userId: typingDTO.userId }&#13;&#10;                }));&#13;&#10;            } else {&#13;&#10;                console.log('⏭️ Skipping typing from self (currentUser)');&#13;&#10;            }&#13;&#10;        };&#13;&#10;&#13;&#10;        const updateCallback = (updatedMessage) =&gt; {&#13;&#10;            // Message edited/deleted&#13;&#10;            setMessages(prev =&gt; prev.map(msg =&gt;&#13;&#10;                msg.id === updatedMessage.id ? updatedMessage : msg&#13;&#10;            ));&#13;&#10;        };&#13;&#10;&#13;&#10;        // Subscribe with callback references&#13;&#10;        console.log(' ChatWindow subscribing to conversation:', conversation.id);&#13;&#10;        webSocketService.subscribeToConversation(&#13;&#10;            conversation.id,&#13;&#10;            messageCallback,&#13;&#10;            typingCallback,&#13;&#10;            updateCallback&#13;&#10;        );&#13;&#10;&#13;&#10;        return () =&gt; {&#13;&#10;            // Cleanup: Send typing stopped ONLY if user was typing&#13;&#10;            if (isTypingRef.current) {&#13;&#10;                console.log(' ChatWindow cleanup: user was typing, sending stopped');&#13;&#10;                webSocketService.sendTypingStatus({&#13;&#10;                    conversationId: conversation.id,&#13;&#10;                    isTyping: false&#13;&#10;                });&#13;&#10;                isTypingRef.current = false;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Unsubscribe ONLY ChatWindow's callbacks (not SideChat's!)&#13;&#10;            console.log(' ChatWindow cleanup: unsubscribing callbacks for', conversation.id);&#13;&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}`, messageCallback);&#13;&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/typing`, typingCallback);&#13;&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/update`, updateCallback);&#13;&#10;        };&#13;&#10;    }, [conversation?.id, currentUserId]);&#13;&#10;&#13;&#10;    // Handle page reload/close - cleanup typing indicator&#13;&#10;    useEffect(() =&gt; {&#13;&#10;        if (!conversation?.id) return;&#13;&#10;&#13;&#10;        const handleBeforeUnload = () =&gt; {&#13;&#10;            // Only send if user was actually typing&#13;&#10;            if (isTypingRef.current) {&#13;&#10;                console.log('⚠️ Page unloading, user was typing, sending stopped');&#13;&#10;                if (webSocketService?.stompClient?.connected) {&#13;&#10;                    webSocketService.sendTypingStatus({&#13;&#10;                        conversationId: conversation.id,&#13;&#10;                        isTyping: false&#13;&#10;                    });&#13;&#10;                }&#13;&#10;            }&#13;&#10;        };&#13;&#10;&#13;&#10;        window.addEventListener('beforeunload', handleBeforeUnload);&#13;&#10;&#13;&#10;        return () =&gt; {&#13;&#10;            window.removeEventListener('beforeunload', handleBeforeUnload);&#13;&#10;        };&#13;&#10;    }, [conversation?.id]);&#13;&#10;&#13;&#10;    // Send typing indicator&#13;&#10;    const sendTypingIndicator = useCallback((isTyping) =&gt; {&#13;&#10;        if (!conversation?.id) return;&#13;&#10;&#13;&#10;        // Track typing state&#13;&#10;        isTypingRef.current = isTyping;&#13;&#10;&#13;&#10;        console.log('⌨️ sendTypingIndicator called:', {&#13;&#10;            isTyping,&#13;&#10;            conversationId: conversation.id,&#13;&#10;            wsConnected: webSocketService?.stompClient?.connected&#13;&#10;        });&#13;&#10;&#13;&#10;        webSocketService.sendTypingStatus({&#13;&#10;            conversationId: conversation.id,&#13;&#10;            isTyping&#13;&#10;        });&#13;&#10;&#13;&#10;        console.log('✅ Typing status sent to backend');&#13;&#10;    }, [conversation?.id]);&#13;&#10;&#13;&#10;    // Handle input change&#13;&#10;    const handleInputChange = useCallback((e) =&gt; {&#13;&#10;        const newValue = e.target.value;&#13;&#10;        console.log('handleInputChange: newValue:', JSON.stringify(newValue), 'trim:', newValue.trim(), 'length:', newValue.length);&#13;&#10;        setInputValue(newValue);&#13;&#10;&#13;&#10;        // Send typing indicator based on whether there's text&#13;&#10;        const shouldType = newValue.length &gt; 0;&#13;&#10;        console.log('shouldType:', shouldType);&#13;&#10;        if (shouldType) {&#13;&#10;            sendTypingIndicator(true);&#13;&#10;        } else {&#13;&#10;            sendTypingIndicator(false);&#13;&#10;        }&#13;&#10;    }, [sendTypingIndicator]);&#13;&#10;&#13;&#10;    // Send message&#13;&#10;    const handleSend = useCallback(async () =&gt; {&#13;&#10;        const messageText = inputValue.trim();&#13;&#10;        if (!messageText || isSending || !conversation?.id) return;&#13;&#10;&#13;&#10;        try {&#13;&#10;            setIsSending(true);&#13;&#10;&#13;&#10;            // Send via REST API - backend will save to DB and broadcast via WebSocket&#13;&#10;            await ChatService.sendMessage(conversation.id, {&#13;&#10;                content: messageText,&#13;&#10;                messageType: 'TEXT'&#13;&#10;            });&#13;&#10;&#13;&#10;            setInputValue('');&#13;&#10;            sendTypingIndicator(false);&#13;&#10;&#13;&#10;            // Focus back to input&#13;&#10;            setTimeout(() =&gt; inputRef.current?.focus(), 0);&#13;&#10;        } catch (error) {&#13;&#10;            console.error('Failed to send message:', error);&#13;&#10;        } finally {&#13;&#10;            setIsSending(false);&#13;&#10;        }&#13;&#10;    }, [inputValue, isSending, conversation?.id, sendTypingIndicator]);&#13;&#10;&#13;&#10;    // Handle key press&#13;&#10;    const handleKeyPress = useCallback((e) =&gt; {&#13;&#10;        if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {&#13;&#10;            e.preventDefault();&#13;&#10;            handleSend();&#13;&#10;        }&#13;&#10;    }, [handleSend]);&#13;&#10;&#13;&#10;    // Linkify text&#13;&#10;    const linkify = (text) =&gt; {&#13;&#10;        if (!text) return '';&#13;&#10;        const urlRegex = /(https?:\/\/[^\s]+)/g;&#13;&#10;        return text.replace(urlRegex, (url) =&gt; {&#13;&#10;            return `&lt;a href=&quot;${url}&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;message-link&quot;&gt;${url}&lt;/a&gt;`;&#13;&#10;        });&#13;&#10;    };&#13;&#10;&#13;&#10;    // Format message time (short version)&#10;    const formatTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        const now = new Date();&#10;        const diffInHours = (now - date) / (1000 * 60 * 60);&#10;&#10;        if (diffInHours &lt; 24) {&#10;            return date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });&#10;        } else {&#10;            return date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;        }&#10;    };&#10;&#10;    // Format detailed time for tooltip&#10;    const formatDetailedTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        return date.toLocaleString('vi-VN', {&#10;            weekday: 'long',&#10;            year: 'numeric',&#10;            month: 'long',&#10;            day: 'numeric',&#10;            hour: '2-digit',&#10;            minute: '2-digit'&#10;        });&#10;    };&#10;&#10;    // Check if should show timestamp separator between messages&#10;    const shouldShowTimestamp = (currentMsg, prevMsg) =&gt; {&#10;        if (!prevMsg) return true; // First message&#10;        &#10;        const currentTime = new Date(currentMsg.timestamp);&#10;        const prevTime = new Date(prevMsg.timestamp);&#10;        &#10;        // Show timestamp if messages are more than 5 minutes apart&#10;        const diffInMinutes = (currentTime - prevTime) / (1000 * 60);&#10;        return diffInMinutes &gt; 5;&#10;    };&#13;&#10;&#13;&#10;    return (&#13;&#10;        &lt;div&#13;&#10;            className={`chat-window ${minimized ? 'minimized' : 'open'}`}&#13;&#10;            data-conversation-id={conversation?.id}&#13;&#10;            data-friend-id={conversation?.id}&#13;&#10;        &gt;&#13;&#10;            &lt;div className={`chat-window-header ${unreadCount &gt; 0 ? 'unread' : ''}`} onClick={onMinimize}&gt;&#13;&#10;                &lt;img&#13;&#10;                    src={displayInfo.avatar}&#13;&#10;                    alt=&quot;Avatar&quot;&#13;&#10;                    className=&quot;chat-window-avatar&quot;&#13;&#10;                    onClick={(e) =&gt; {&#13;&#10;                        e.stopPropagation();&#13;&#10;                        if (!conversation.isGroup) {&#13;&#10;                            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#13;&#10;                            if (otherUser?.userId) {&#13;&#10;                                navigate(`/profile/${otherUser.userId}`);&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }}&#13;&#10;                /&gt;&#13;&#10;                &lt;div className=&quot;chat-window-info&quot;&gt;&#13;&#10;                    &lt;div className=&quot;chat-window-name&quot;&gt;{displayInfo.name}&lt;/div&gt;&#13;&#10;                    &lt;div className=&quot;chat-window-status&quot;&gt;{displayInfo.status}&lt;/div&gt;&#13;&#10;                &lt;/div&gt;&#13;&#10;                &lt;div className=&quot;chat-window-controls&quot;&gt;&#13;&#10;                    &lt;button&#13;&#10;                        className=&quot;chat-window-minimize&quot;&#13;&#10;                        title=&quot;Thu nhỏ&quot;&#13;&#10;                        onClick={(e) =&gt; {&#13;&#10;                            e.stopPropagation();&#13;&#10;                            onMinimize();&#13;&#10;                        }}&#13;&#10;                    &gt;&#13;&#10;                        −&#13;&#10;                    &lt;/button&gt;&#13;&#10;                    &lt;button&#13;&#10;                        className=&quot;chat-window-close&quot;&#13;&#10;                        title=&quot;Đóng&quot;&#13;&#10;                        onClick={(e) =&gt; {&#13;&#10;                            e.stopPropagation();&#13;&#10;                            onClose();&#13;&#10;                        }}&#13;&#10;                    &gt;&#13;&#10;                        ×&#13;&#10;                    &lt;/button&gt;&#13;&#10;                &lt;/div&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;&#13;&#10;            &lt;div&#13;&#10;                className=&quot;chat-window-messages&quot;&#13;&#10;                ref={messagesContainerRef}&#13;&#10;                onScroll={handleScroll}&#13;&#10;            &gt;&#13;&#10;                {isLoading &amp;&amp; currentPage === 0 &amp;&amp; (&#13;&#10;                    &lt;div className=&quot;chat-loading&quot;&gt;Đang tải tin nhắn...&lt;/div&gt;&#13;&#10;                )}&#13;&#10;&#13;&#10;                {hasMore &amp;&amp; !isLoading &amp;&amp; currentPage &gt; 0 &amp;&amp; (&#13;&#10;                    &lt;div className=&quot;load-more-messages&quot;&gt;&#13;&#10;                        &lt;button onClick={() =&gt; loadMessages(currentPage + 1)}&gt;&#13;&#10;                            Tải thêm tin nhắn&#13;&#10;                        &lt;/button&gt;&#13;&#10;                    &lt;/div&gt;&#13;&#10;                )}&#13;&#10;&#13;&#10;                {messages.map((msg, index) =&gt; {&#13;&#10;                    const isSent = msg.senderId === currentUserId;&#13;&#10;                    const showAvatar = !isSent &amp;&amp; (index === 0 || messages[index - 1].senderId !== msg.senderId);&#13;&#10;&#13;&#10;                    return (&#13;&#10;                        &lt;div&#13;&#10;                            key={msg.id || index}&#13;&#10;                            className={`chat-window-message ${isSent ? 'sent' : 'received'}`}&#13;&#10;                        &gt;&#13;&#10;                            {showAvatar &amp;&amp; !isSent &amp;&amp; (&#13;&#10;                                &lt;img&#13;&#10;                                    src={msg.senderAvatar || displayInfo.avatar}&#13;&#10;                                    alt=&quot;Avatar&quot;&#13;&#10;                                    className=&quot;chat-window-message-avatar&quot;&#13;&#10;                                /&gt;&#13;&#10;                            )}&#13;&#10;                            {!showAvatar &amp;&amp; !isSent &amp;&amp; &lt;div className=&quot;chat-window-message-avatar-spacer&quot; /&gt;}&#13;&#10;&#13;&#10;                            &lt;div className=&quot;chat-window-message-content&quot;&gt;&#13;&#10;                                {!isSent &amp;&amp; showAvatar &amp;&amp; (&#13;&#10;                                    &lt;div className=&quot;chat-window-message-sender&quot;&gt;{msg.senderName}&lt;/div&gt;&#13;&#10;                                )}&#13;&#10;                                {msg.isLocation ? (&#13;&#10;                                    &lt;div className=&quot;location-message-card&quot;&gt;&#13;&#10;                                        &lt;div className=&quot;location-card-image&quot;&gt;&#13;&#10;                                            &lt;img src={msg.content.image} alt={msg.content.name} /&gt;&#13;&#10;                                            &lt;div className=&quot;location-card-overlay&quot;&gt;&lt;/div&gt;&#13;&#10;                                        &lt;/div&gt;&#13;&#10;                                        &lt;div className=&quot;location-card-content&quot;&gt;&#13;&#10;                                            &lt;div className=&quot;location-card-title&quot;&gt;{msg.content.name}&lt;/div&gt;&#13;&#10;                                            &lt;div className=&quot;location-card-description&quot;&gt;{msg.content.description}&lt;/div&gt;&#13;&#10;                                            &lt;button&#13;&#10;                                                className=&quot;location-card-button&quot;&#13;&#10;                                                onClick={() =&gt; window.focusLocation?.(msg.content.coordinates[0], msg.content.coordinates[1], msg.content.name)}&#13;&#10;                                            &gt;&#13;&#10;                                                ️ Xem trên bản đồ&#13;&#10;                                            &lt;/button&gt;&#13;&#10;                                        &lt;/div&gt;&#13;&#10;                                    &lt;/div&gt;&#13;&#10;                                ) : (&#13;&#10;                                    &lt;div&#13;&#10;                                        className=&quot;chat-window-message-text&quot;&#13;&#10;                                        dangerouslySetInnerHTML={{ __html: linkify(msg.content) }}&#13;&#10;                                    /&gt;&#13;&#10;                                )}&#13;&#10;                                &lt;div className=&quot;chat-window-message-time&quot;&gt;&#13;&#10;                                    {formatTime(msg.timestamp)}&#13;&#10;                                    {msg.edited &amp;&amp; &lt;span className=&quot;edited-indicator&quot;&gt; (đã chỉnh sửa)&lt;/span&gt;}&#13;&#10;                                &lt;/div&gt;&#13;&#10;                            &lt;/div&gt;&#13;&#10;                        &lt;/div&gt;&#13;&#10;                    );&#13;&#10;                })}&#13;&#10;&#13;&#10;                {typingUsers.length &gt; 0 &amp;&amp; (&#13;&#10;                    &lt;div className=&quot;chat-window-message received typing-indicator-message&quot;&gt;&#13;&#10;                        {console.log('rendering typing indicator, typingUsers length:', typingUsers.length, 'users:', typingUsers.map(u =&gt; u.userId))}&#13;&#10;                        &lt;img src={typingUsers[0].avatar} alt=&quot;Avatar&quot; className=&quot;chat-window-message-avatar&quot; /&gt;&#13;&#10;                        &lt;div className=&quot;typing-indicator&quot;&gt;&#13;&#10;                            &lt;div className=&quot;typing-dots&quot;&gt;&#13;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#13;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#13;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#13;&#10;                            &lt;/div&gt;&#13;&#10;                        &lt;/div&gt;&#13;&#10;                    &lt;/div&gt;&#13;&#10;                )}&#13;&#10;&#13;&#10;                &lt;div ref={messagesEndRef} /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;&#13;&#10;            &lt;div className=&quot;chat-window-input-container&quot;&gt;&#13;&#10;                &lt;input&#13;&#10;                    type=&quot;text&quot;&#13;&#10;                    placeholder=&quot;Aa&quot;&#13;&#10;                    className=&quot;chat-window-input&quot;&#13;&#10;                    value={inputValue}&#13;&#10;                    onInput={handleInputChange}&#13;&#10;                    onKeyPress={handleKeyPress}&#13;&#10;                    onFocus={() =&gt; { if (inputValue.length &gt; 0) sendTypingIndicator(true); }}&#13;&#10;                    onBlur={() =&gt; sendTypingIndicator(false)}&#13;&#10;                    disabled={isSending}&#13;&#10;                    ref={inputRef}&#13;&#10;                /&gt;&#13;&#10;                &lt;button&#13;&#10;                    className=&quot;chat-window-send&quot;&#13;&#10;                    onClick={handleSend}&#13;&#10;                    disabled={!inputValue.trim() || isSending}&#13;&#10;                &gt;&#13;&#10;                    {isSending ? '...' : '→'}&#13;&#10;                &lt;/button&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;    );&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>