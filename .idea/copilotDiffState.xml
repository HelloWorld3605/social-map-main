<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CHAT_DEBUG_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CHAT_DEBUG_GUIDE.md" />
              <option name="updatedContent" value="# Chat Debug Guide - Last Message Real-time Fix&#10;&#10;## Cách test fix&#10;&#10;### 1. Mở Browser Console&#10;Mở DevTools (F12) → Console tab để xem logs&#10;&#10;### 2. Load website&#10;Quan sát các logs sau:&#10;```&#10;✅ WebSocket connected&#10;✅ Current user ID from JWT: [userId]&#10;✅ Subscribed to /user/queue/unread&#10;✅ Subscribed to /user/queue/conversation-update&#10;```&#10;&#10;### 3. Sau khi load conversations&#10;Sẽ thấy logs subscribe cho mỗi conversation:&#10;```&#10;✅ Subscribed to /topic/conversation/[convId]&#10;✅ Subscribed to /topic/conversation/[convId]/typing&#10;```&#10;&#10;### 4. Khi có message mới (KHÔNG mở ChatWindow)&#10;Sẽ thấy:&#10;```&#10;SideChat received new message for conv [convId] : {message object}&#10;```&#10;&#10;→ **Last message trong SideChat phải update ngay lập tức**&#10;&#10;### 5. Khi mở ChatWindow&#10;Sẽ thấy:&#10;```&#10;⚡ Added callback to existing subscription: /topic/conversation/[convId]&#10;⚡ Added callback to existing subscription: /topic/conversation/[convId]/typing&#10;```&#10;&#10;→ **Có nghĩa là ChatWindow đang share subscription với SideChat**&#10;&#10;### 6. Khi có message mới (ĐÃ mở ChatWindow)&#10;Sẽ thấy 2 logs (do 2 callbacks):&#10;```&#10;SideChat received new message for conv [convId] : {message object}&#10;ChatWindow received new message : {message object}&#10;```&#10;&#10;→ **Cả SideChat và ChatWindow đều nhận message và update UI**&#10;&#10;## Các trường hợp test&#10;&#10;### Test Case 1: Load website lần đầu&#10;**Steps:**&#10;1. Clear cache &amp; reload&#10;2. Login&#10;3. Vào trang có chat&#10;&#10;**Expected:**&#10;- Last message của tất cả conversations hiển thị đúng (từ backend)&#10;- WebSocket connect thành công&#10;- Subscribe vào tất cả conversations&#10;&#10;### Test Case 2: Nhận message mới khi KHÔNG mở ChatWindow&#10;**Steps:**&#10;1. Đăng nhập 2 tài khoản khác nhau (2 browser/incognito)&#10;2. User A: Không mở ChatWindow nào&#10;3. User B: Gửi message cho User A&#10;&#10;**Expected:**&#10;- User A thấy last message update ngay lập tức trong SideChat&#10;- Unread count tăng lên&#10;- Console log: &quot;SideChat received new message for conv...&quot;&#10;&#10;### Test Case 3: Nhận message khi ĐÃ mở ChatWindow&#10;**Steps:**&#10;1. User A: Mở ChatWindow với User B&#10;2. User B: Gửi message&#10;&#10;**Expected:**&#10;- Message hiển thị trong ChatWindow của User A&#10;- Last message trong SideChat cũng update&#10;- Console log cả 2: SideChat và ChatWindow received message&#10;&#10;### Test Case 4: Location message&#10;**Steps:**&#10;1. User B gửi location message&#10;2. User A không mở ChatWindow&#10;&#10;**Expected:**&#10;- Last message hiển thị &quot;Vị trí&quot; (không phải raw JSON)&#10;- Console log: lastMessageContent = &quot;Vị trí&quot;&#10;&#10;### Test Case 5: Multiple conversations&#10;**Steps:**&#10;1. User A có nhiều conversations&#10;2. Các User khác nhau gửi message cho User A&#10;&#10;**Expected:**&#10;- Tất cả last messages đều update đúng&#10;- Không bị override lẫn nhau&#10;- Mỗi conversation có riêng callbacks&#10;&#10;### Test Case 6: Open/Close ChatWindow nhiều lần&#10;**Steps:**&#10;1. Mở ChatWindow&#10;2. Đóng ChatWindow&#10;3. Mở lại&#10;4. Nhận message&#10;&#10;**Expected:**&#10;- Không bị duplicate subscription&#10;- Message vẫn nhận đúng&#10;- Console log: &quot;Added callback to existing subscription&quot; (lần mở thứ 2 trở đi)&#10;&#10;## Troubleshooting&#10;&#10;### Vấn đề: Last message không update&#10;**Check:**&#10;1. WebSocket có connected không? → Check console log &quot;✅ WebSocket connected&quot;&#10;2. Có subscribe vào conversation không? → Check &quot;✅ Subscribed to /topic/conversation/[id]&quot;&#10;3. Message có được gửi qua WebSocket không? → Check backend logs&#10;4. Callback có được gọi không? → Check &quot;SideChat received new message&quot;&#10;&#10;**Solutions:**&#10;- Nếu không connect: Check authToken trong localStorage&#10;- Nếu không subscribe: Check conversations.length &gt; 0&#10;- Nếu callback không được gọi: Check backend có broadcast đúng topic không&#10;&#10;### Vấn đề: ChatWindow không nhận message&#10;**Check:**&#10;1. Console log có &quot;Added callback to existing subscription&quot; không?&#10;2. Có 2 logs khi nhận message không? (SideChat + ChatWindow)&#10;&#10;**Solutions:**&#10;- Clear refs và reload: `subscribedConversationsRef.current.clear()`&#10;- Check cleanup trong useEffect có chạy đúng không&#10;&#10;### Vấn đề: Memory leak / Multiple subscriptions&#10;**Check:**&#10;1. Số lượng subscriptions: `webSocketService.subscriptions.size`&#10;2. Số lượng callbacks: `webSocketService.callbacks.get('/topic/conversation/[id]').size`&#10;&#10;**Solutions:**&#10;- Đảm bảo cleanup chạy khi unmount&#10;- Check unsubscribe có truyền đúng callback reference không&#10;&#10;## Backend Requirements&#10;&#10;Backend cần broadcast message lên các topics sau:&#10;&#10;### 1. New message&#10;```&#10;Topic: /topic/conversation/{conversationId}&#10;Payload: {&#10;  id: string,&#10;  conversationId: string,&#10;  senderId: string,&#10;  senderName: string,&#10;  content: string,  // hoặc &quot;LOCATION:{...}&quot; cho location&#10;  timestamp: ISO date string,&#10;  messageType: &quot;TEXT&quot; | &quot;IMAGE&quot; | &quot;LOCATION&quot;&#10;}&#10;```&#10;&#10;### 2. Unread count&#10;```&#10;Topic: /user/queue/unread&#10;Payload: {&#10;  conversationId: string,&#10;  count: number&#10;}&#10;```&#10;&#10;### 3. Conversation update (optional - fallback)&#10;```&#10;Topic: /user/queue/conversation-update&#10;Payload: {&#10;  conversationId: string,&#10;  lastMessageContent: string,&#10;  lastMessageSenderId: string,&#10;  lastMessageAt: ISO date string,&#10;  unreadCount: number&#10;}&#10;```&#10;&#10;## Console Commands for Debugging&#10;&#10;```javascript&#10;// Check WebSocket connection&#10;webSocketService.stompClient?.connected&#10;&#10;// Check current subscriptions&#10;webSocketService.subscriptions&#10;&#10;// Check callbacks for a conversation&#10;webSocketService.callbacks.get('/topic/conversation/CONV_ID')&#10;&#10;// Check all subscribed conversations in SideChat&#10;// (Paste this in console when on the page)&#10;window.sideChatSubscriptions = subscribedConversationsRef.current&#10;&#10;// Manually trigger a test message (in console)&#10;// webSocketService.sendChatMessage({&#10;//   conversationId: 'CONV_ID',&#10;//   content: 'Test message',&#10;//   messageType: 'TEXT'&#10;// })&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CHAT_FIX_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CHAT_FIX_SUMMARY.md" />
              <option name="updatedContent" value="# Chat Last Message Fix Summary&#10;&#10;## Vấn đề&#10;- Last message trong SideChat không hiển thị đúng và real-time khi user không mở ChatWindow&#10;- Chỉ khi mở ChatWindow và nhắn tin thì last message mới cập nhật&#10;&#10;## Nguyên nhân&#10;1. **SideChat không subscribe vào message stream của tất cả conversations**&#10;   - Trước đây chỉ subscribe vào typing status&#10;   - Không nhận được message mới qua WebSocket&#10;&#10;2. **WebSocketService không hỗ trợ multiple callbacks**&#10;   - Khi cả SideChat và ChatWindow cùng subscribe vào 1 topic&#10;   - Callback thứ 2 ghi đè callback thứ 1&#10;   - Dẫn đến chỉ component subscribe sau nhận được message&#10;&#10;## Giải pháp đã implement&#10;&#10;### 1. Refactor WebSocketService để hỗ trợ multiple callbacks&#10;**File: `src/services/ChatService.js`**&#10;- Thêm `callbacks` Map để lưu tất cả callbacks cho mỗi destination&#10;- Khi subscribe: thêm callback vào Set, chỉ subscribe STOMP 1 lần&#10;- Khi có message: gọi TẤT CẢ callbacks đã register&#10;- Khi unsubscribe: remove callback cụ thể, chỉ unsubscribe STOMP khi không còn callback nào&#10;&#10;```javascript&#10;class WebSocketChatService {&#10;    constructor() {&#10;        this.stompClient = null;&#10;        this.subscriptions = new Map(); // Map&lt;destination, subscription&gt;&#10;        this.callbacks = new Map(); // Map&lt;destination, Set&lt;callback&gt;&gt;&#10;        this.currentUserId = null;&#10;    }&#10;&#10;    subscribe(destination, callback) {&#10;        // Add callback to callbacks set&#10;        if (!this.callbacks.has(destination)) {&#10;            this.callbacks.set(destination, new Set());&#10;        }&#10;        this.callbacks.get(destination).add(callback);&#10;&#10;        // Only subscribe to STOMP if not already subscribed&#10;        if (!this.subscriptions.has(destination)) {&#10;            const sub = this.stompClient.subscribe(destination, msg =&gt; {&#10;                const data = JSON.parse(msg.body);&#10;                // Call all registered callbacks for this destination&#10;                const callbacks = this.callbacks.get(destination);&#10;                if (callbacks) {&#10;                    callbacks.forEach(cb =&gt; cb(data));&#10;                }&#10;            });&#10;            this.subscriptions.set(destination, sub);&#10;        }&#10;    }&#10;&#10;    unsubscribe(destination, callback) {&#10;        // If callback provided, remove only that callback&#10;        if (callback &amp;&amp; this.callbacks.has(destination)) {&#10;            this.callbacks.get(destination).delete(callback);&#10;            &#10;            // If no more callbacks, unsubscribe from STOMP&#10;            if (this.callbacks.get(destination).size === 0) {&#10;                this.callbacks.delete(destination);&#10;                const sub = this.subscriptions.get(destination);&#10;                sub?.unsubscribe();&#10;                this.subscriptions.delete(destination);&#10;            }&#10;        } else {&#10;            // Remove all callbacks and unsubscribe&#10;            this.callbacks.delete(destination);&#10;            const sub = this.subscriptions.get(destination);&#10;            sub?.unsubscribe();&#10;            this.subscriptions.delete(destination);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### 2. Update SideChat để subscribe vào messages&#10;**File: `src/components/Chat/SideChat.jsx`**&#10;&#10;**Thay đổi chính:**&#10;- Subscribe vào message stream cho TẤT CẢ conversations&#10;- Khi nhận message mới → cập nhật last message ngay lập tức&#10;- Track subscribed conversations để tránh duplicate&#10;- Lưu callback references để cleanup đúng cách&#10;&#10;```javascript&#10;// Subscribe to all conversations for both messages and typing&#10;useEffect(() =&gt; {&#10;    if (!isConnected || conversations.length === 0) return;&#10;&#10;    conversations.forEach(conv =&gt; {&#10;        // Skip if already subscribed&#10;        if (subscribedConversationsRef.current.has(conv.id)) {&#10;            return;&#10;        }&#10;&#10;        // Create message callback&#10;        const messageCallback = (message) =&gt; {&#10;            console.log('SideChat received new message for conv', conv.id, ':', message);&#10;            &#10;            // Process location messages&#10;            let lastMessageContent = message.content;&#10;            if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                lastMessageContent = 'Vị trí';&#10;            } else if (message.isLocation) {&#10;                lastMessageContent = 'Vị trí';&#10;            }&#10;&#10;            // Update conversation's last message&#10;            setConversations(prev =&gt; prev.map(c =&gt; {&#10;                if (c.id === conv.id) {&#10;                    return {&#10;                        ...c,&#10;                        lastMessageContent: lastMessageContent,&#10;                        lastMessageSenderId: message.senderId,&#10;                        lastMessageAt: message.timestamp || new Date().toISOString(),&#10;                    };&#10;                }&#10;                return c;&#10;            }));&#10;        };&#10;&#10;        // Create typing callback&#10;        const typingCallback = (typingDTO) =&gt; {&#10;            window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                detail: { conversationId: conv.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;            }));&#10;        };&#10;&#10;        // Save callbacks for cleanup&#10;        messageCallbacksRef.current.set(conv.id, messageCallback);&#10;        typingCallbacksRef.current.set(conv.id, typingCallback);&#10;&#10;        // Subscribe to messages AND typing for this conversation&#10;        webSocketService.subscribeToConversation(&#10;            conv.id,&#10;            messageCallback,&#10;            typingCallback,&#10;            null&#10;        );&#10;        &#10;        // Mark as subscribed&#10;        subscribedConversationsRef.current.add(conv.id);&#10;    });&#10;&#10;    // Cleanup&#10;    return () =&gt; {&#10;        conversations.forEach(conv =&gt; {&#10;            if (subscribedConversationsRef.current.has(conv.id)) {&#10;                const messageCallback = messageCallbacksRef.current.get(conv.id);&#10;                const typingCallback = typingCallbacksRef.current.get(conv.id);&#10;                &#10;                webSocketService.unsubscribe(`/topic/conversation/${conv.id}`, messageCallback);&#10;                webSocketService.unsubscribe(`/topic/conversation/${conv.id}/typing`, typingCallback);&#10;                &#10;                subscribedConversationsRef.current.delete(conv.id);&#10;                messageCallbacksRef.current.delete(conv.id);&#10;                typingCallbacksRef.current.delete(conv.id);&#10;            }&#10;        });&#10;    };&#10;}, [conversations, isConnected]);&#10;```&#10;&#10;### 3. Thêm method sendMarkAsRead&#10;**File: `src/services/ChatService.js`**&#10;&#10;```javascript&#10;sendMarkAsRead({ conversationId }) {&#10;    if (!this.stompClient?.connected) {&#10;        console.error('STOMP client not connected, cannot send mark as read');&#10;        return;&#10;    }&#10;    try {&#10;        this.stompClient.publish({&#10;            destination: '/app/markAsRead',&#10;            body: JSON.stringify({&#10;                conversationId&#10;            })&#10;        });&#10;        console.log('Mark as read sent for conversation:', conversationId);&#10;    } catch (error) {&#10;        console.error('Failed to send mark as read:', error);&#10;    }&#10;}&#10;```&#10;&#10;## Cách hoạt động mới&#10;&#10;### Khi load website lần đầu:&#10;1. **SideChat connect WebSocket** → load conversations&#10;2. **Subscribe vào ALL conversations** (messages + typing)&#10;3. **Mỗi khi có message mới** → callback được gọi → update last message&#10;&#10;### Khi mở ChatWindow:&#10;1. **ChatWindow cũng subscribe** vào conversation&#10;2. **WebSocketService cho phép multiple callbacks** &#10;3. Cả SideChat và ChatWindow **đều nhận message**&#10;4. SideChat → update last message&#10;5. ChatWindow → hiển thị message trong chat&#10;&#10;### Flow hoàn chỉnh:&#10;```&#10;User A gửi message&#10;    ↓&#10;Backend broadcast → /topic/conversation/{id}&#10;    ↓&#10;WebSocketService nhận message&#10;    ↓&#10;Gọi TẤT CẢ callbacks đã register:&#10;    - SideChat callback → update last message&#10;    - ChatWindow callback (nếu mở) → hiển thị message&#10;```&#10;&#10;## Test checklist&#10;- [ ] Load website → last message hiển thị đúng từ backend&#10;- [ ] Không mở ChatWindow → nhận message mới → last message update real-time&#10;- [ ] Mở ChatWindow → nhận message → cả ChatWindow và SideChat đều update&#10;- [ ] Location message hiển thị &quot;Vị trí&quot; trong last message&#10;- [ ] Typing indicator hoạt động đúng&#10;- [ ] Unread count update đúng&#10;&#10;## Notes&#10;- SideChat giờ subscribe vào messages nhưng KHÔNG tăng unread count (backend handle qua `/user/queue/unread`)&#10;- ChatWindow vẫn hoạt động bình thường với multiple callbacks&#10;- Memory leak đã được xử lý với proper cleanup trong useEffect&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/IMPLEMENTATION_COMPLETE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/IMPLEMENTATION_COMPLETE.md" />
              <option name="updatedContent" value="# ✅ COMPLETED: Fix Last Message Real-time Display in SideChat&#10;&#10;##  Vấn đề đã giải quyết&#10;&#10;**Trước khi fix:**&#10;- ❌ Last message trong SideChat KHÔNG hiển thị real-time khi user không mở ChatWindow&#10;- ❌ Chỉ khi mở ChatWindow và nhắn tin thì last message mới cập nhật&#10;- ❌ WebSocket chỉ subscribe cho ChatWindow đang mở, không subscribe cho tất cả conversations&#10;&#10;**Sau khi fix:**&#10;- ✅ Last message trong SideChat hiển thị real-time cho TẤT CẢ conversations&#10;- ✅ Không cần mở ChatWindow, last message vẫn update ngay lập tức&#10;- ✅ Cả SideChat và ChatWindow đều nhận message đồng thời (multiple callbacks)&#10;- ✅ Location messages hiển thị &quot;Vị trí&quot; thay vì raw JSON&#10;&#10;##  Files đã sửa&#10;&#10;### 1. `src/services/ChatService.js`&#10;**Thay đổi chính:**&#10;- Thêm `callbacks` Map để hỗ trợ multiple callbacks cho cùng destination&#10;- Refactor `subscribe()` method để cho phép nhiều component subscribe cùng topic&#10;- Refactor `unsubscribe()` method để cleanup đúng cách&#10;- Thêm method `sendMarkAsRead()` để ChatWindow có thể đánh dấu đã đọc qua WebSocket&#10;&#10;**Code changes:**&#10;```javascript&#10;class WebSocketChatService {&#10;    constructor() {&#10;        this.stompClient = null;&#10;        this.subscriptions = new Map(); // Map&lt;destination, subscription&gt;&#10;        this.callbacks = new Map(); // Map&lt;destination, Set&lt;callback&gt;&gt; ← MỚI&#10;        this.currentUserId = null;&#10;    }&#10;&#10;    subscribe(destination, callback) {&#10;        // Add callback to callbacks set&#10;        if (!this.callbacks.has(destination)) {&#10;            this.callbacks.set(destination, new Set());&#10;        }&#10;        this.callbacks.get(destination).add(callback);&#10;&#10;        // Only subscribe to STOMP if not already subscribed&#10;        if (!this.subscriptions.has(destination)) {&#10;            const sub = this.stompClient.subscribe(destination, msg =&gt; {&#10;                const data = JSON.parse(msg.body);&#10;                // Call all registered callbacks for this destination ← QUAN TRỌNG&#10;                const callbacks = this.callbacks.get(destination);&#10;                if (callbacks) {&#10;                    callbacks.forEach(cb =&gt; cb(data));&#10;                }&#10;            });&#10;            this.subscriptions.set(destination, sub);&#10;        }&#10;    }&#10;&#10;    unsubscribe(destination, callback) {&#10;        // Remove specific callback, only unsubscribe STOMP when no callbacks left&#10;        if (callback &amp;&amp; this.callbacks.has(destination)) {&#10;            this.callbacks.get(destination).delete(callback);&#10;            &#10;            if (this.callbacks.get(destination).size === 0) {&#10;                this.callbacks.delete(destination);&#10;                const sub = this.subscriptions.get(destination);&#10;                sub?.unsubscribe();&#10;                this.subscriptions.delete(destination);&#10;            }&#10;        }&#10;    }&#10;&#10;    sendMarkAsRead({ conversationId }) { // ← MỚI&#10;        if (!this.stompClient?.connected) return;&#10;        this.stompClient.publish({&#10;            destination: '/app/markAsRead',&#10;            body: JSON.stringify({ conversationId })&#10;        });&#10;    }&#10;}&#10;```&#10;&#10;### 2. `src/components/Chat/SideChat.jsx`&#10;**Thay đổi chính:**&#10;- Subscribe vào message stream cho TẤT CẢ conversations (không chỉ typing)&#10;- Update last message ngay lập tức khi nhận message qua WebSocket&#10;- Track callbacks để cleanup đúng cách&#10;- Handle location messages để hiển thị &quot;Vị trí&quot;&#10;&#10;**Code changes:**&#10;```javascript&#10;// Thêm refs để track subscriptions và callbacks&#10;const subscribedConversationsRef = useRef(new Set());&#10;const messageCallbacksRef = useRef(new Map());&#10;const typingCallbacksRef = useRef(new Map());&#10;&#10;// Subscribe to all conversations for both messages and typing&#10;useEffect(() =&gt; {&#10;    if (!isConnected || conversations.length === 0) return;&#10;&#10;    conversations.forEach(conv =&gt; {&#10;        // Skip if already subscribed&#10;        if (subscribedConversationsRef.current.has(conv.id)) return;&#10;&#10;        // Message callback - UPDATE LAST MESSAGE&#10;        const messageCallback = (message) =&gt; {&#10;            console.log('SideChat received new message for conv', conv.id, ':', message);&#10;            &#10;            // Process location messages&#10;            let lastMessageContent = message.content;&#10;            if (message.content?.startsWith('LOCATION:') || message.isLocation) {&#10;                lastMessageContent = 'Vị trí';&#10;            }&#10;&#10;            // Update conversation's last message ← QUAN TRỌNG&#10;            setConversations(prev =&gt; prev.map(c =&gt; {&#10;                if (c.id === conv.id) {&#10;                    return {&#10;                        ...c,&#10;                        lastMessageContent: lastMessageContent,&#10;                        lastMessageSenderId: message.senderId,&#10;                        lastMessageAt: message.timestamp || new Date().toISOString(),&#10;                    };&#10;                }&#10;                return c;&#10;            }));&#10;        };&#10;&#10;        // Typing callback&#10;        const typingCallback = (typingDTO) =&gt; {&#10;            window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                detail: { &#10;                    conversationId: conv.id, &#10;                    isTyping: typingDTO.typing, &#10;                    userId: typingDTO.userId &#10;                }&#10;            }));&#10;        };&#10;&#10;        // Save callbacks for cleanup&#10;        messageCallbacksRef.current.set(conv.id, messageCallback);&#10;        typingCallbacksRef.current.set(conv.id, typingCallback);&#10;&#10;        // Subscribe ← QUAN TRỌNG&#10;        webSocketService.subscribeToConversation(&#10;            conv.id,&#10;            messageCallback,  // ← Subscribe vào messages&#10;            typingCallback,&#10;            null&#10;        );&#10;        &#10;        subscribedConversationsRef.current.add(conv.id);&#10;    });&#10;&#10;    // Cleanup&#10;    return () =&gt; {&#10;        conversations.forEach(conv =&gt; {&#10;            if (subscribedConversationsRef.current.has(conv.id)) {&#10;                const messageCallback = messageCallbacksRef.current.get(conv.id);&#10;                const typingCallback = typingCallbacksRef.current.get(conv.id);&#10;                &#10;                webSocketService.unsubscribe(`/topic/conversation/${conv.id}`, messageCallback);&#10;                webSocketService.unsubscribe(`/topic/conversation/${conv.id}/typing`, typingCallback);&#10;                &#10;                subscribedConversationsRef.current.delete(conv.id);&#10;                messageCallbacksRef.current.delete(conv.id);&#10;                typingCallbacksRef.current.delete(conv.id);&#10;            }&#10;        });&#10;    };&#10;}, [conversations, isConnected]);&#10;```&#10;&#10;##  Flow hoạt động&#10;&#10;### Khi load website:&#10;```&#10;1. User login → WebSocket connect&#10;2. Load conversations từ backend → setState conversations&#10;3. useEffect trigger → Subscribe vào TẤT CẢ conversations&#10;4. Mỗi conversation có 2 subscriptions:&#10;   - /topic/conversation/{id} → message callback&#10;   - /topic/conversation/{id}/typing → typing callback&#10;```&#10;&#10;### Khi nhận message mới (KHÔNG mở ChatWindow):&#10;```&#10;1. User B gửi message&#10;2. Backend broadcast → /topic/conversation/{convId}&#10;3. WebSocket nhận message&#10;4. Gọi TẤT CẢ callbacks đã register:&#10;   - SideChat callback → Update last message ✅&#10;5. UI update ngay lập tức trong SideChat&#10;```&#10;&#10;### Khi nhận message mới (ĐÃ mở ChatWindow):&#10;```&#10;1. User B gửi message&#10;2. Backend broadcast → /topic/conversation/{convId}&#10;3. WebSocket nhận message&#10;4. Gọi TẤT CẢ callbacks (2 callbacks):&#10;   - SideChat callback → Update last message ✅&#10;   - ChatWindow callback → Hiển thị message trong chat ✅&#10;5. Cả 2 UIs đều update đồng thời&#10;```&#10;&#10;## ✨ Tính năng mới&#10;&#10;### Multiple Callbacks Support&#10;- Nhiều components có thể subscribe cùng 1 WebSocket topic&#10;- Mỗi component có callback riêng&#10;- Tất cả callbacks đều được gọi khi có message mới&#10;- Cleanup tự động khi component unmount&#10;&#10;### Smart Subscription Management&#10;- Chỉ subscribe STOMP 1 lần cho mỗi topic&#10;- Thêm callbacks vào Set mà không tạo duplicate subscription&#10;- Chỉ unsubscribe STOMP khi không còn callback nào&#10;- Tránh memory leak và duplicate subscriptions&#10;&#10;### Location Message Handling&#10;- Detect location message: `content.startsWith('LOCATION:')` hoặc `isLocation: true`&#10;- Hiển thị &quot;Vị trí&quot; thay vì raw JSON trong last message&#10;- Consistent display trong cả SideChat và ChatWindow&#10;&#10;##  Cách test&#10;&#10;### Test 1: Load website lần đầu&#10;```&#10;1. Clear cache &amp; reload&#10;2. Login&#10;3. Check console: &quot;✅ Subscribed to /topic/conversation/...&quot; cho mỗi conversation&#10;4. Last message của tất cả conversations hiển thị đúng&#10;```&#10;&#10;### Test 2: Nhận message khi KHÔNG mở ChatWindow&#10;```&#10;1. Đăng nhập 2 tài khoản (2 browsers)&#10;2. User A: KHÔNG mở ChatWindow nào&#10;3. User B: Gửi message cho User A&#10;4. User A: Check last message update real-time ✅&#10;5. Console log: &quot;SideChat received new message for conv...&quot;&#10;```&#10;&#10;### Test 3: Nhận message khi ĐÃ mở ChatWindow&#10;```&#10;1. User A: Mở ChatWindow với User B&#10;2. User B: Gửi message&#10;3. User A: &#10;   - Message hiển thị trong ChatWindow ✅&#10;   - Last message trong SideChat cũng update ✅&#10;4. Console log 2 dòng:&#10;   - &quot;SideChat received new message...&quot;&#10;   - &quot;ChatWindow received new message...&quot;&#10;```&#10;&#10;### Test 4: Location message&#10;```&#10;1. User B: Gửi location message&#10;2. User A: Last message hiển thị &quot;Vị trí&quot; ✅&#10;3. Không phải raw JSON&#10;```&#10;&#10;##  So sánh trước/sau&#10;&#10;| Tính năng | Trước | Sau |&#10;|-----------|-------|-----|&#10;| Last message real-time (không mở chat) | ❌ | ✅ |&#10;| Last message real-time (đã mở chat) | ✅ | ✅ |&#10;| Multiple callbacks support | ❌ | ✅ |&#10;| Location message display | Raw JSON | &quot;Vị trí&quot; |&#10;| Memory leak prevention | ⚠️ | ✅ |&#10;| Console debugging | Limited | Full logs |&#10;&#10;##  Known Issues &amp; Solutions&#10;&#10;### Issue: Last message vẫn không update&#10;**Giải pháp:**&#10;1. Check WebSocket connection: `webSocketService.stompClient?.connected`&#10;2. Check subscriptions: `webSocketService.subscriptions.size`&#10;3. Check backend có broadcast đúng topic không&#10;&#10;### Issue: Duplicate messages&#10;**Giải pháp:**&#10;- Đã handle bằng `subscribedConversationsRef` để tránh subscribe duplicate&#10;- Cleanup đúng cách trong useEffect return function&#10;&#10;### Issue: Memory leak&#10;**Giải pháp:**&#10;- Cleanup callbacks khi component unmount&#10;- Unsubscribe với đúng callback reference&#10;- Clear tất cả refs khi disconnect&#10;&#10;##  Documentation created&#10;1. `CHAT_FIX_SUMMARY.md` - Tổng quan về fix&#10;2. `CHAT_DEBUG_GUIDE.md` - Hướng dẫn debug và test chi tiết&#10;3. `IMPLEMENTATION_COMPLETE.md` - File này (tổng kết)&#10;&#10;## ✅ Checklist hoàn thành&#10;- [x] Refactor WebSocketService để hỗ trợ multiple callbacks&#10;- [x] Update SideChat để subscribe vào messages&#10;- [x] Thêm tracking refs để quản lý subscriptions&#10;- [x] Handle location messages&#10;- [x] Add proper cleanup&#10;- [x] Add sendMarkAsRead method&#10;- [x] Test và verify không có compile errors&#10;- [x] Tạo documentation&#10;&#10;##  Next Steps&#10;1. Test trên môi trường thực&#10;2. Monitor console logs để verify&#10;3. Fix backend nếu cần (broadcast topics)&#10;4. Performance optimization nếu có nhiều conversations (lazy subscribe)&#10;&#10;---&#10;**Status:** ✅ COMPLETED AND READY FOR TESTING&#10;**Date:** November 1, 2025&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map-fe/src/components/Chat/SideChat.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/components/Chat/SideChat.jsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useCallback, useRef } from 'react';&#10;import './Chat.css';&#10;import './ChatWindows.css';&#10;import './LocationMessage.css';&#10;import ChatWindow from './ChatWindow';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;&#10;export default function SideChat() {&#10;    const [isChatOpen, setIsChatOpen] = useState(false);&#10;    const [activeFriend, setActiveFriend] = useState(null);&#10;    const [openChatWindows, setOpenChatWindows] = useState(new Map());&#10;    const [conversations, setConversations] = useState([]);&#10;    const [searchQuery, setSearchQuery] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isConnected, setIsConnected] = useState(false);&#10;    const [currentUserId, setCurrentUserId] = useState(null);&#10;    const wsConnectedRef = useRef(false);&#10;&#10;    // Load conversations from backend&#10;    const loadConversations = useCallback(async () =&gt; {&#10;        try {&#10;            setIsLoading(true);&#10;            const data = await ChatService.getUserConversations();&#10;            // Parse location messages in lastMessage&#10;            const processedData = data.map(conv =&gt; {&#10;                if (conv.lastMessageContent?.startsWith('LOCATION:')) {&#10;                    return {&#10;                        ...conv,&#10;                        lastMessageContent: 'Vị trí'&#10;                    };&#10;                }&#10;                return conv;&#10;            }).map(conv =&gt; ({ ...conv, typingUsers: [] })); // Add typingUsers array&#10;            setConversations(processedData);&#10;        } catch (error) {&#10;            console.error('Failed to load conversations:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, []);&#10;&#10;    // Connect to WebSocket&#10;    useEffect(() =&gt; {&#10;        if (!wsConnectedRef.current) {&#10;            webSocketService.connect(&#10;                () =&gt; {&#10;                    console.log('✅ WebSocket connected');&#10;                    setIsConnected(true);&#10;                    wsConnectedRef.current = true;&#10;&#10;                    // Lấy userId từ WebSocket service (đã được fetch từ backend)&#10;                    const userId = webSocketService.getCurrentUserId();&#10;                    setCurrentUserId(userId);&#10;&#10;                    // Subscribe to user queue for unread counts&#10;                    webSocketService.subscribeToUserQueue(&#10;                        (unreadDTO) =&gt; {&#10;                            // Update unread count for conversation&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === unreadDTO.conversationId&#10;                                    ? { ...conv, unreadCount: unreadDTO.count }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('WebSocket error:', error);&#10;                        }&#10;                    );&#10;&#10;                    // Subscribe to conversation updates&#10;                    webSocketService.subscribeToConversationUpdates(&#10;                        (updateDTO) =&gt; {&#10;                            // Update conversation with new last message and unread count&#10;                            let lastMessageContent = updateDTO.lastMessageContent;&#10;                            if (updateDTO.lastMessageContent?.startsWith('LOCATION:')) {&#10;                                lastMessageContent = 'Vị trí';&#10;                            }&#10;&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === updateDTO.conversationId&#10;                                    ? {&#10;                                        ...conv,&#10;                                        lastMessageContent: lastMessageContent,&#10;                                        lastMessageSenderId: updateDTO.lastMessageSenderId,&#10;                                        lastMessageAt: updateDTO.lastMessageAt,&#10;                                        unreadCount: updateDTO.unreadCount&#10;                                    }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('Conversation update error:', error);&#10;                        }&#10;                    );&#10;                },&#10;                (error) =&gt; {&#10;                    console.error('WebSocket connection failed:', error);&#10;                    setIsConnected(false);&#10;                    wsConnectedRef.current = false;&#10;                }&#10;            );&#10;        }&#10;&#10;        return () =&gt; {&#10;            if (wsConnectedRef.current) {&#10;                webSocketService.disconnect();&#10;                wsConnectedRef.current = false;&#10;            }&#10;        };&#10;    }, []);&#10;&#10;    // Load conversations on mount&#10;    useEffect(() =&gt; {&#10;        loadConversations();&#10;    }, [loadConversations]);&#10;&#10;    // Subscribe to typing for all conversations&#10;    useEffect(() =&gt; {&#10;        if (!isConnected || conversations.length === 0) return;&#10;&#10;        const unsubscribeFunctions = [];&#10;&#10;        conversations.forEach(conv =&gt; {&#10;            // Subscribe only to typing, not messages&#10;            const unsubscribe = webSocketService.subscribeToConversation(&#10;                conv.id,&#10;                null, // no message callback&#10;                (typingDTO) =&gt; {&#10;                    // Dispatch event to update SideChat&#10;                    console.log('SideChat received typing:', typingDTO);&#10;                    window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                        detail: { conversationId: conv.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;                    }));&#10;                },&#10;                null // no update callback&#10;            );&#10;            // Assuming subscribeToConversation returns an unsubscribe function or we can use the pattern&#10;            // For now, we'll collect the conversation ids to unsubscribe later&#10;            unsubscribeFunctions.push(() =&gt; {&#10;                webSocketService.unsubscribe(`/topic/conversation/${conv.id}/typing`);&#10;            });&#10;        });&#10;&#10;        return () =&gt; {&#10;            unsubscribeFunctions.forEach(unsub =&gt; unsub());&#10;        };&#10;    }, [conversations, isConnected]);&#10;&#10;    // Listen for openChatWindow event from Profile Page&#10;    useEffect(() =&gt; {&#10;        const handleOpenChatWindow = (event) =&gt; {&#10;            const { conversation, minimized } = event.detail;&#10;&#10;            if (!conversation) return;&#10;&#10;            // Add to conversations list if not exists&#10;            setConversations(prev =&gt; {&#10;                const exists = prev.find(c =&gt; c.id === conversation.id);&#10;                if (!exists) {&#10;                    return [conversation, ...prev];&#10;                }&#10;                return prev;&#10;            });&#10;&#10;            // Open chat window&#10;            setOpenChatWindows(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                newMap.set(conversation.id, { ...conversation, minimized: minimized || false });&#10;                return newMap;&#10;            });&#10;&#10;            setActiveFriend(conversation.id);&#10;        };&#10;&#10;        window.addEventListener('openChatWindow', handleOpenChatWindow);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('openChatWindow', handleOpenChatWindow);&#10;        };&#10;    }, []);&#10;&#10;    // Listen for typing status updates from ChatWindow&#10;    useEffect(() =&gt; {&#10;        const handleTypingStatus = (event) =&gt; {&#10;            const { conversationId, isTyping, userId } = event.detail;&#10;            console.log('SideChat handling typingStatus:', { conversationId, isTyping, userId });&#10;            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                if (conv.id === conversationId) {&#10;                    let newTypingUsers = [...conv.typingUsers];&#10;                    if (isTyping) {&#10;                        if (!newTypingUsers.includes(userId)) {&#10;                            newTypingUsers.push(userId);&#10;                        }&#10;                    } else {&#10;                        newTypingUsers = newTypingUsers.filter(id =&gt; id !== userId);&#10;                    }&#10;                    console.log('Updated typingUsers for conv', conv.id, ':', newTypingUsers);&#10;                    return { ...conv, typingUsers: newTypingUsers };&#10;                }&#10;                return conv;&#10;            }));&#10;        };&#10;&#10;        window.addEventListener('typingStatus', handleTypingStatus);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('typingStatus', handleTypingStatus);&#10;        };&#10;    }, []);&#10;&#10;    const handleChatToggle = useCallback(() =&gt; {&#10;        setIsChatOpen(prev =&gt; !prev);&#10;    }, []);&#10;&#10;    const handleCloseChatPopup = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleOverlayClick = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleFriendClick = useCallback(async (conversation) =&gt; {&#10;        setActiveFriend(conversation.id);&#10;        setIsChatOpen(false);&#10;&#10;        // Mark as read&#10;        try {&#10;            await ChatService.markAsRead(conversation.id);&#10;            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                conv.id === conversation.id ? { ...conv, unreadCount: 0 } : conv&#10;            ));&#10;        } catch (error) {&#10;            console.error('Failed to mark as read:', error);&#10;        }&#10;&#10;        // Open chat window&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            if (!newMap.has(conversation.id)) {&#10;                newMap.set(conversation.id, { ...conversation, minimized: false });&#10;            } else {&#10;                const existing = newMap.get(conversation.id);&#10;                newMap.set(conversation.id, { ...existing, minimized: false });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleCloseChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            newMap.delete(conversationId);&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleMinimizeChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            const chatWindow = newMap.get(conversationId);&#10;            if (chatWindow) {&#10;                newMap.set(conversationId, { ...chatWindow, minimized: !chatWindow.minimized });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    // Handle new messages from WebSocket&#10;    const handleNewMessage = useCallback((conversationId, message) =&gt; {&#10;        let lastMessageContent = message.content;&#10;        if (message.content?.startsWith('LOCATION:')) {&#10;            lastMessageContent = 'Vị trí';&#10;        }&#10;&#10;        setConversations(prev =&gt; prev.map(conv =&gt; {&#10;            if (conv.id === conversationId) {&#10;                return {&#10;                    ...conv,&#10;                    lastMessageContent: lastMessageContent,&#10;                    lastMessageTime: message.timestamp,&#10;                    lastMessageSender: message.senderName,&#10;                };&#10;            }&#10;            return conv;&#10;        }));&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        const chatToggle = document.getElementById('chatToggle');&#10;        if (chatToggle) {&#10;            chatToggle.addEventListener('click', handleChatToggle);&#10;            return () =&gt; chatToggle.removeEventListener('click', handleChatToggle);&#10;        }&#10;    }, [handleChatToggle]);&#10;&#10;    useEffect(() =&gt; {&#10;        const handleEscape = (e) =&gt; {&#10;            if (e.key === 'Escape' &amp;&amp; isChatOpen) {&#10;                setIsChatOpen(false);&#10;            }&#10;        };&#10;&#10;        document.addEventListener('keydown', handleEscape);&#10;        return () =&gt; document.removeEventListener('keydown', handleEscape);&#10;    }, [isChatOpen]);&#10;&#10;    // Filter conversations based on search query&#10;    const filteredConversations = conversations.filter(conv =&gt; {&#10;        const displayName = conv.isGroup ? conv.groupName : conv.otherUser?.displayName || '';&#10;        return displayName.toLowerCase().includes(searchQuery.toLowerCase());&#10;    });&#10;&#10;    // Get display info for conversation&#10;    const getConversationDisplay = (conv) =&gt; {&#10;        if (conv.isGroup) {&#10;            return {&#10;                name: conv.groupName || 'Nhóm',&#10;                avatar: conv.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conv.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conv.otherUser || conv.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.online ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    };&#10;&#10;    // Format last message display&#10;    const getLastMessageDisplay = (conv) =&gt; {&#10;        if (conv.typingUsers &amp;&amp; conv.typingUsers.length &gt; 0) {&#10;            return (&#10;                &lt;span className=&quot;typing-indicator-text&quot;&gt;&#10;                    &lt;span className=&quot;typing-dots-inline&quot;&gt;&#10;                        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&#10;                    &lt;/span&gt;&#10;                    {' '}đang nhập&#10;                &lt;/span&gt;&#10;            );&#10;        }&#10;&#10;        if (conv.lastMessageContent) {&#10;            const prefix = conv.lastMessageSenderId === currentUserId ? 'Bạn: ' : '';&#10;            return `${prefix}${conv.lastMessageContent}`;&#10;        }&#10;&#10;        return 'Bắt đầu trò chuyện';&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            {/* Chat Popup Overlay */}&#10;            &lt;div&#10;                className={`chat-popup-overlay ${isChatOpen ? 'is-active' : ''}`}&#10;                id=&quot;chatPopupOverlay&quot;&#10;                onClick={handleOverlayClick}&#10;                role=&quot;button&quot;&#10;                tabIndex={0}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleOverlayClick()}&#10;                aria-label=&quot;Close chat&quot;&#10;            /&gt;&#10;&#10;            {/* Side Chat */}&#10;            &lt;div className={`side-chat ${isChatOpen ? 'is-active' : ''}`} id=&quot;sideChat&quot;&gt;&#10;                &lt;div className=&quot;chat-header&quot;&gt;&#10;                    &lt;h3&gt;Đoạn chat&lt;/h3&gt;&#10;                    &lt;button className=&quot;chat-close-btn&quot; id=&quot;chatCloseBtn&quot; onClick={handleCloseChatPopup}&gt;×&lt;/button&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Search Box */}&#10;                &lt;div className=&quot;chat-search-box&quot;&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        placeholder=&quot;Tìm kiếm đoạn chat...&quot;&#10;                        value={searchQuery}&#10;                        onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;                        className=&quot;chat-search-input&quot;&#10;                    /&gt;&#10;                    {searchQuery &amp;&amp; (&#10;                        &lt;button&#10;                            className=&quot;chat-search-clear&quot;&#10;                            onClick={() =&gt; setSearchQuery('')}&#10;                        &gt;&#10;                            ×&#10;                        &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;chat-friends-list&quot;&gt;&#10;                    {isLoading ? (&#10;                        &lt;div className=&quot;chat-loading&quot;&gt;Đang tải...&lt;/div&gt;&#10;                    ) : filteredConversations.length === 0 ? (&#10;                        &lt;div className=&quot;chat-empty&quot;&gt;Không có đoạn chat nào&lt;/div&gt;&#10;                    ) : (&#10;                        filteredConversations.map((conv) =&gt; {&#10;                            const display = getConversationDisplay(conv);&#10;                            return (&#10;                                &lt;div&#10;                                    key={conv.id}&#10;                                    className={`friend-item ${activeFriend === conv.id ? 'active' : ''}`}&#10;                                    onClick={() =&gt; handleFriendClick(conv)}&#10;                                    role=&quot;button&quot;&#10;                                    tabIndex={0}&#10;                                    onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleFriendClick(conv)}&#10;                                    data-friend={conv.id}&#10;                                &gt;&#10;                                    &lt;img src={display.avatar} alt=&quot;Avatar&quot; className=&quot;friend-avatar&quot; /&gt;&#10;                                    &lt;div className=&quot;friend-info&quot;&gt;&#10;                                        &lt;div className=&quot;friend-name&quot;&gt;{display.name}&lt;/div&gt;&#10;                                        &lt;div className=&quot;friend-status&quot;&gt;&#10;                                            {getLastMessageDisplay(conv)}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                    {conv.unreadCount &gt; 0 &amp;&amp; (&#10;                                        &lt;div className=&quot;unread-count&quot;&gt;{conv.unreadCount}&lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            );&#10;                        })&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {!isConnected &amp;&amp; (&#10;                    &lt;div className=&quot;chat-connection-status&quot;&gt;&#10;                        &lt;span className=&quot;connection-indicator offline&quot;&gt;●&lt;/span&gt;&#10;                        {' '}Đang kết nối lại...&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Chat Windows Container */}&#10;            &lt;div className=&quot;chat-windows-container&quot; id=&quot;chatWindowsContainer&quot;&gt;&#10;                {Array.from(openChatWindows.entries()).map(([conversationId, chatData]) =&gt; {&#10;                    const conversation = conversations.find(c =&gt; c.id === conversationId) || chatData;&#10;                    return (&#10;                        &lt;ChatWindow&#10;                            key={conversationId}&#10;                            conversation={conversation}&#10;                            minimized={chatData.minimized}&#10;                            currentUserId={currentUserId}&#10;                            unreadCount={conversation.unreadCount || 0}&#10;                            onClose={() =&gt; handleCloseChatWindow(conversationId)}&#10;                            onMinimize={() =&gt; handleMinimizeChatWindow(conversationId)}&#10;                            onNewMessage={(message) =&gt; handleNewMessage(conversationId, message)}&#10;                        /&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useCallback, useRef } from 'react';&#10;import './Chat.css';&#10;import './ChatWindows.css';&#10;import './LocationMessage.css';&#10;import ChatWindow from './ChatWindow';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;&#10;export default function SideChat() {&#10;    const [isChatOpen, setIsChatOpen] = useState(false);&#10;    const [activeFriend, setActiveFriend] = useState(null);&#10;    const [openChatWindows, setOpenChatWindows] = useState(new Map());&#10;    const [conversations, setConversations] = useState([]);&#10;    const [searchQuery, setSearchQuery] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isConnected, setIsConnected] = useState(false);&#10;    const [currentUserId, setCurrentUserId] = useState(null);&#10;    const wsConnectedRef = useRef(false);&#10;    const subscribedConversationsRef = useRef(new Set()); // Track subscribed conversations&#10;    const messageCallbacksRef = useRef(new Map()); // Track message callbacks for cleanup&#10;    const typingCallbacksRef = useRef(new Map()); // Track typing callbacks for cleanup&#10;&#10;    // Load conversations from backend&#10;    const loadConversations = useCallback(async () =&gt; {&#10;        try {&#10;            setIsLoading(true);&#10;            const data = await ChatService.getUserConversations();&#10;            // Parse location messages in lastMessage&#10;            const processedData = data.map(conv =&gt; {&#10;                if (conv.lastMessageContent?.startsWith('LOCATION:')) {&#10;                    return {&#10;                        ...conv,&#10;                        lastMessageContent: 'Vị trí'&#10;                    };&#10;                }&#10;                return conv;&#10;            }).map(conv =&gt; ({ ...conv, typingUsers: [] })); // Add typingUsers array&#10;            setConversations(processedData);&#10;        } catch (error) {&#10;            console.error('Failed to load conversations:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, []);&#10;&#10;    // Connect to WebSocket&#10;    useEffect(() =&gt; {&#10;        if (!wsConnectedRef.current) {&#10;            webSocketService.connect(&#10;                () =&gt; {&#10;                    console.log('✅ WebSocket connected');&#10;                    setIsConnected(true);&#10;                    wsConnectedRef.current = true;&#10;&#10;                    // Lấy userId từ WebSocket service (đã được fetch từ backend)&#10;                    const userId = webSocketService.getCurrentUserId();&#10;                    setCurrentUserId(userId);&#10;&#10;                    // Subscribe to user queue for unread counts&#10;                    webSocketService.subscribeToUserQueue(&#10;                        (unreadDTO) =&gt; {&#10;                            // Update unread count for conversation&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === unreadDTO.conversationId&#10;                                    ? { ...conv, unreadCount: unreadDTO.count }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('WebSocket error:', error);&#10;                        }&#10;                    );&#10;&#10;                    // Subscribe to conversation updates&#10;                    webSocketService.subscribeToConversationUpdates(&#10;                        (updateDTO) =&gt; {&#10;                            // Update conversation with new last message and unread count&#10;                            let lastMessageContent = updateDTO.lastMessageContent;&#10;                            if (updateDTO.lastMessageContent?.startsWith('LOCATION:')) {&#10;                                lastMessageContent = 'Vị trí';&#10;                            }&#10;&#10;                            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                                conv.id === updateDTO.conversationId&#10;                                    ? {&#10;                                        ...conv,&#10;                                        lastMessageContent: lastMessageContent,&#10;                                        lastMessageSenderId: updateDTO.lastMessageSenderId,&#10;                                        lastMessageAt: updateDTO.lastMessageAt,&#10;                                        unreadCount: updateDTO.unreadCount&#10;                                    }&#10;                                    : conv&#10;                            ));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('Conversation update error:', error);&#10;                        }&#10;                    );&#10;                },&#10;                (error) =&gt; {&#10;                    console.error('WebSocket connection failed:', error);&#10;                    setIsConnected(false);&#10;                    wsConnectedRef.current = false;&#10;                }&#10;            );&#10;        }&#10;&#10;        return () =&gt; {&#10;            if (wsConnectedRef.current) {&#10;                webSocketService.disconnect();&#10;                wsConnectedRef.current = false;&#10;            }&#10;        };&#10;    }, []);&#10;&#10;    // Load conversations on mount&#10;    useEffect(() =&gt; {&#10;        loadConversations();&#10;    }, [loadConversations]);&#10;&#10;    // Subscribe to all conversations for both messages and typing&#10;    useEffect(() =&gt; {&#10;        if (!isConnected || conversations.length === 0) return;&#10;&#10;        conversations.forEach(conv =&gt; {&#10;            // Skip if already subscribed&#10;            if (subscribedConversationsRef.current.has(conv.id)) {&#10;                return;&#10;            }&#10;&#10;            // Create message callback&#10;            const messageCallback = (message) =&gt; {&#10;                console.log('SideChat received new message for conv', conv.id, ':', message);&#10;                &#10;                // Process location messages&#10;                let lastMessageContent = message.content;&#10;                if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                    lastMessageContent = 'Vị trí';&#10;                } else if (message.isLocation) {&#10;                    lastMessageContent = 'Vị trí';&#10;                }&#10;&#10;                // Update conversation's last message&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        return {&#10;                            ...c,&#10;                            lastMessageContent: lastMessageContent,&#10;                            lastMessageSenderId: message.senderId,&#10;                            lastMessageAt: message.timestamp || new Date().toISOString(),&#10;                            // Don't update unreadCount here - backend will send via /user/queue/unread&#10;                        };&#10;                    }&#10;                    return c;&#10;                }));&#10;            };&#10;&#10;            // Create typing callback&#10;            const typingCallback = (typingDTO) =&gt; {&#10;                // Dispatch event to update SideChat&#10;                console.log('SideChat received typing:', typingDTO);&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conv.id, isTyping: typingDTO.typing, userId: typingDTO.userId }&#10;                }));&#10;            };&#10;&#10;            // Save callbacks for cleanup&#10;            messageCallbacksRef.current.set(conv.id, messageCallback);&#10;            typingCallbacksRef.current.set(conv.id, typingCallback);&#10;&#10;            // Subscribe to messages AND typing for this conversation&#10;            webSocketService.subscribeToConversation(&#10;                conv.id,&#10;                messageCallback,&#10;                typingCallback,&#10;                null // no update callback&#10;            );&#10;            &#10;            // Mark as subscribed&#10;            subscribedConversationsRef.current.add(conv.id);&#10;        });&#10;&#10;        // Cleanup function - only unsubscribe when component unmounts&#10;        return () =&gt; {&#10;            conversations.forEach(conv =&gt; {&#10;                if (subscribedConversationsRef.current.has(conv.id)) {&#10;                    const messageCallback = messageCallbacksRef.current.get(conv.id);&#10;                    const typingCallback = typingCallbacksRef.current.get(conv.id);&#10;                    &#10;                    webSocketService.unsubscribe(`/topic/conversation/${conv.id}`, messageCallback);&#10;                    webSocketService.unsubscribe(`/topic/conversation/${conv.id}/typing`, typingCallback);&#10;                    &#10;                    subscribedConversationsRef.current.delete(conv.id);&#10;                    messageCallbacksRef.current.delete(conv.id);&#10;                    typingCallbacksRef.current.delete(conv.id);&#10;                }&#10;            });&#10;        };&#10;    }, [conversations, isConnected]);&#10;&#10;    // Listen for openChatWindow event from Profile Page&#10;    useEffect(() =&gt; {&#10;        const handleOpenChatWindow = (event) =&gt; {&#10;            const { conversation, minimized } = event.detail;&#10;&#10;            if (!conversation) return;&#10;&#10;            // Add to conversations list if not exists&#10;            setConversations(prev =&gt; {&#10;                const exists = prev.find(c =&gt; c.id === conversation.id);&#10;                if (!exists) {&#10;                    return [conversation, ...prev];&#10;                }&#10;                return prev;&#10;            });&#10;&#10;            // Open chat window&#10;            setOpenChatWindows(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                newMap.set(conversation.id, { ...conversation, minimized: minimized || false });&#10;                return newMap;&#10;            });&#10;&#10;            setActiveFriend(conversation.id);&#10;        };&#10;&#10;        window.addEventListener('openChatWindow', handleOpenChatWindow);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('openChatWindow', handleOpenChatWindow);&#10;        };&#10;    }, []);&#10;&#10;    // Listen for typing status updates from ChatWindow&#10;    useEffect(() =&gt; {&#10;        const handleTypingStatus = (event) =&gt; {&#10;            const { conversationId, isTyping, userId } = event.detail;&#10;            console.log('SideChat handling typingStatus:', { conversationId, isTyping, userId });&#10;            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                if (conv.id === conversationId) {&#10;                    let newTypingUsers = [...conv.typingUsers];&#10;                    if (isTyping) {&#10;                        if (!newTypingUsers.includes(userId)) {&#10;                            newTypingUsers.push(userId);&#10;                        }&#10;                    } else {&#10;                        newTypingUsers = newTypingUsers.filter(id =&gt; id !== userId);&#10;                    }&#10;                    console.log('Updated typingUsers for conv', conv.id, ':', newTypingUsers);&#10;                    return { ...conv, typingUsers: newTypingUsers };&#10;                }&#10;                return conv;&#10;            }));&#10;        };&#10;&#10;        window.addEventListener('typingStatus', handleTypingStatus);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('typingStatus', handleTypingStatus);&#10;        };&#10;    }, []);&#10;&#10;    const handleChatToggle = useCallback(() =&gt; {&#10;        setIsChatOpen(prev =&gt; !prev);&#10;    }, []);&#10;&#10;    const handleCloseChatPopup = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleOverlayClick = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleFriendClick = useCallback(async (conversation) =&gt; {&#10;        setActiveFriend(conversation.id);&#10;        setIsChatOpen(false);&#10;&#10;        // Mark as read&#10;        try {&#10;            await ChatService.markAsRead(conversation.id);&#10;            setConversations(prev =&gt; prev.map(conv =&gt;&#10;                conv.id === conversation.id ? { ...conv, unreadCount: 0 } : conv&#10;            ));&#10;        } catch (error) {&#10;            console.error('Failed to mark as read:', error);&#10;        }&#10;&#10;        // Open chat window&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            if (!newMap.has(conversation.id)) {&#10;                newMap.set(conversation.id, { ...conversation, minimized: false });&#10;            } else {&#10;                const existing = newMap.get(conversation.id);&#10;                newMap.set(conversation.id, { ...existing, minimized: false });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleCloseChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            newMap.delete(conversationId);&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleMinimizeChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            const chatWindow = newMap.get(conversationId);&#10;            if (chatWindow) {&#10;                newMap.set(conversationId, { ...chatWindow, minimized: !chatWindow.minimized });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    // Handle new messages from WebSocket&#10;    const handleNewMessage = useCallback((conversationId, message) =&gt; {&#10;        let lastMessageContent = message.content;&#10;        if (message.content?.startsWith('LOCATION:')) {&#10;            lastMessageContent = 'Vị trí';&#10;        }&#10;&#10;        setConversations(prev =&gt; prev.map(conv =&gt; {&#10;            if (conv.id === conversationId) {&#10;                return {&#10;                    ...conv,&#10;                    lastMessageContent: lastMessageContent,&#10;                    lastMessageTime: message.timestamp,&#10;                    lastMessageSender: message.senderName,&#10;                };&#10;            }&#10;            return conv;&#10;        }));&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        const chatToggle = document.getElementById('chatToggle');&#10;        if (chatToggle) {&#10;            chatToggle.addEventListener('click', handleChatToggle);&#10;            return () =&gt; chatToggle.removeEventListener('click', handleChatToggle);&#10;        }&#10;    }, [handleChatToggle]);&#10;&#10;    useEffect(() =&gt; {&#10;        const handleEscape = (e) =&gt; {&#10;            if (e.key === 'Escape' &amp;&amp; isChatOpen) {&#10;                setIsChatOpen(false);&#10;            }&#10;        };&#10;&#10;        document.addEventListener('keydown', handleEscape);&#10;        return () =&gt; document.removeEventListener('keydown', handleEscape);&#10;    }, [isChatOpen]);&#10;&#10;    // Filter conversations based on search query&#10;    const filteredConversations = conversations.filter(conv =&gt; {&#10;        const displayName = conv.isGroup ? conv.groupName : conv.otherUser?.displayName || '';&#10;        return displayName.toLowerCase().includes(searchQuery.toLowerCase());&#10;    });&#10;&#10;    // Get display info for conversation&#10;    const getConversationDisplay = (conv) =&gt; {&#10;        if (conv.isGroup) {&#10;            return {&#10;                name: conv.groupName || 'Nhóm',&#10;                avatar: conv.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conv.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conv.otherUser || conv.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.online ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    };&#10;&#10;    // Format last message display&#10;    const getLastMessageDisplay = (conv) =&gt; {&#10;        if (conv.typingUsers &amp;&amp; conv.typingUsers.length &gt; 0) {&#10;            return (&#10;                &lt;span className=&quot;typing-indicator-text&quot;&gt;&#10;                    &lt;span className=&quot;typing-dots-inline&quot;&gt;&#10;                        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&#10;                    &lt;/span&gt;&#10;                    {' '}đang nhập&#10;                &lt;/span&gt;&#10;            );&#10;        }&#10;&#10;        if (conv.lastMessageContent) {&#10;            const prefix = conv.lastMessageSenderId === currentUserId ? 'Bạn: ' : '';&#10;            return `${prefix}${conv.lastMessageContent}`;&#10;        }&#10;&#10;        return 'Bắt đầu trò chuyện';&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            {/* Chat Popup Overlay */}&#10;            &lt;div&#10;                className={`chat-popup-overlay ${isChatOpen ? 'is-active' : ''}`}&#10;                id=&quot;chatPopupOverlay&quot;&#10;                onClick={handleOverlayClick}&#10;                role=&quot;button&quot;&#10;                tabIndex={0}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleOverlayClick()}&#10;                aria-label=&quot;Close chat&quot;&#10;            /&gt;&#10;&#10;            {/* Side Chat */}&#10;            &lt;div className={`side-chat ${isChatOpen ? 'is-active' : ''}`} id=&quot;sideChat&quot;&gt;&#10;                &lt;div className=&quot;chat-header&quot;&gt;&#10;                    &lt;h3&gt;Đoạn chat&lt;/h3&gt;&#10;                    &lt;button className=&quot;chat-close-btn&quot; id=&quot;chatCloseBtn&quot; onClick={handleCloseChatPopup}&gt;×&lt;/button&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Search Box */}&#10;                &lt;div className=&quot;chat-search-box&quot;&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        placeholder=&quot;Tìm kiếm đoạn chat...&quot;&#10;                        value={searchQuery}&#10;                        onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;                        className=&quot;chat-search-input&quot;&#10;                    /&gt;&#10;                    {searchQuery &amp;&amp; (&#10;                        &lt;button&#10;                            className=&quot;chat-search-clear&quot;&#10;                            onClick={() =&gt; setSearchQuery('')}&#10;                        &gt;&#10;                            ×&#10;                        &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;chat-friends-list&quot;&gt;&#10;                    {isLoading ? (&#10;                        &lt;div className=&quot;chat-loading&quot;&gt;Đang tải...&lt;/div&gt;&#10;                    ) : filteredConversations.length === 0 ? (&#10;                        &lt;div className=&quot;chat-empty&quot;&gt;Không có đoạn chat nào&lt;/div&gt;&#10;                    ) : (&#10;                        filteredConversations.map((conv) =&gt; {&#10;                            const display = getConversationDisplay(conv);&#10;                            return (&#10;                                &lt;div&#10;                                    key={conv.id}&#10;                                    className={`friend-item ${activeFriend === conv.id ? 'active' : ''}`}&#10;                                    onClick={() =&gt; handleFriendClick(conv)}&#10;                                    role=&quot;button&quot;&#10;                                    tabIndex={0}&#10;                                    onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleFriendClick(conv)}&#10;                                    data-friend={conv.id}&#10;                                &gt;&#10;                                    &lt;img src={display.avatar} alt=&quot;Avatar&quot; className=&quot;friend-avatar&quot; /&gt;&#10;                                    &lt;div className=&quot;friend-info&quot;&gt;&#10;                                        &lt;div className=&quot;friend-name&quot;&gt;{display.name}&lt;/div&gt;&#10;                                        &lt;div className=&quot;friend-status&quot;&gt;&#10;                                            {getLastMessageDisplay(conv)}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                    {conv.unreadCount &gt; 0 &amp;&amp; (&#10;                                        &lt;div className=&quot;unread-count&quot;&gt;{conv.unreadCount}&lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            );&#10;                        })&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {!isConnected &amp;&amp; (&#10;                    &lt;div className=&quot;chat-connection-status&quot;&gt;&#10;                        &lt;span className=&quot;connection-indicator offline&quot;&gt;●&lt;/span&gt;&#10;                        {' '}Đang kết nối lại...&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Chat Windows Container */}&#10;            &lt;div className=&quot;chat-windows-container&quot; id=&quot;chatWindowsContainer&quot;&gt;&#10;                {Array.from(openChatWindows.entries()).map(([conversationId, chatData]) =&gt; {&#10;                    const conversation = conversations.find(c =&gt; c.id === conversationId) || chatData;&#10;                    return (&#10;                        &lt;ChatWindow&#10;                            key={conversationId}&#10;                            conversation={conversation}&#10;                            minimized={chatData.minimized}&#10;                            currentUserId={currentUserId}&#10;                            unreadCount={conversation.unreadCount || 0}&#10;                            onClose={() =&gt; handleCloseChatWindow(conversationId)}&#10;                            onMinimize={() =&gt; handleMinimizeChatWindow(conversationId)}&#10;                            onNewMessage={(message) =&gt; handleNewMessage(conversationId, message)}&#10;                        /&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map-fe/src/services/ChatService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/services/ChatService.js" />
              <option name="originalContent" value="import { api } from './apiClient';&#10;import SockJS from 'sockjs-client';&#10;import { Stomp } from '@stomp/stompjs';&#10;&#10;const BASE_URL = &quot;http://localhost:8080&quot;;&#10;&#10;// =================================================================&#10;// PART 1: REST API SERVICE&#10;// =================================================================&#10;// Backend sẽ tự động lấy userId từ JWT token qua @AuthenticationPrincipal&#10;// Không cần truyền userId từ frontend&#10;// =================================================================&#10;&#10;export const ChatService = {&#10;&#10;    /**&#10;     * Lấy danh sách conversations của user hiện tại&#10;     * GET /api/conversations&#10;     * Backend tự động lấy userId từ JWT&#10;     */&#10;    getUserConversations: () =&gt;&#10;        api.get('/conversations'),&#10;&#10;    /**&#10;     * Lấy conversation cụ thể&#10;     * GET /api/conversations/{conversationId}&#10;     */&#10;    getConversation: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}`),&#10;&#10;    /**&#10;     * Lấy hoặc tạo conversation private với user khác&#10;     * GET /api/conversations/private/{otherUserId}&#10;     */&#10;    getOrCreatePrivateConversation: (otherUserId) =&gt;&#10;        api.get(`/conversations/private/${otherUserId}`),&#10;&#10;    /**&#10;     * Tạo conversation mới (nhóm hoặc private)&#10;     * POST /api/conversations&#10;     * @param {object} data - { memberIds: string[], isGroup: boolean, groupName?: string, groupAvatar?: string }&#10;     */&#10;    createConversation: (data) =&gt;&#10;        api.post('/conversations', data),&#10;&#10;    /**&#10;     * Cập nhật thông tin group chat&#10;     * PUT /api/conversations/{conversationId}/group-info&#10;     */&#10;    updateGroupInfo: (conversationId, { groupName, groupAvatar }) =&gt;&#10;        api.put(`/conversations/${conversationId}/group-info`, null, {&#10;            params: { groupName, groupAvatar }&#10;        }),&#10;&#10;    /**&#10;     * Lấy lịch sử tin nhắn của conversation (phân trang)&#10;     * GET /api/conversations/{conversationId}/messages&#10;     */&#10;    getMessages: (conversationId, { page = 0, size = 50 } = {}) =&gt;&#10;        api.get(`/conversations/${conversationId}/messages`, {&#10;            params: { page, size }&#10;        }),&#10;&#10;    /**&#10;     * Lấy tin nhắn mới (chưa đọc)&#10;     * GET /api/conversations/{conversationId}/messages/new&#10;     */&#10;    getNewMessages: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}/messages/new`),&#10;&#10;    /**&#10;     * Gửi tin nhắn qua REST API&#10;     * POST /api/conversations/{conversationId}/messages&#10;     */&#10;    sendMessage: (conversationId, messageData) =&gt;&#10;        api.post(`/conversations/${conversationId}/messages`, messageData),&#10;&#10;    /**&#10;     * Sửa tin nhắn&#10;     * PUT /api/messages/{messageId}&#10;     */&#10;    editMessage: (messageId, content) =&gt;&#10;        api.put(`/messages/${messageId}`, null, {&#10;            params: { content }&#10;        }),&#10;&#10;    /**&#10;     * Xóa tin nhắn&#10;     * DELETE /api/messages/{messageId}&#10;     */&#10;    deleteMessage: (messageId) =&gt;&#10;        api.delete(`/messages/${messageId}`),&#10;&#10;    /**&#10;     * Search tin nhắn trong conversation&#10;     * GET /api/conversations/{conversationId}/messages/search&#10;     */&#10;    searchMessages: (conversationId, query) =&gt;&#10;        api.get(`/conversations/${conversationId}/messages/search`, {&#10;            params: { query }&#10;        }),&#10;&#10;    /**&#10;     * Đánh dấu tin nhắn đã đọc&#10;     * POST /api/conversations/{conversationId}/read&#10;     */&#10;    markAsRead: (conversationId) =&gt;&#10;        api.post(`/conversations/${conversationId}/read`),&#10;&#10;    /**&#10;     * Lấy số tin nhắn chưa đọc&#10;     * GET /api/conversations/{conversationId}/unread-count&#10;     */&#10;    getUnreadCount: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}/unread-count`),&#10;&#10;    /**&#10;     * Lấy danh sách users đang typing&#10;     * GET /api/conversations/{conversationId}/typing&#10;     */&#10;    getTypingUsers: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}/typing`),&#10;&#10;    /**&#10;     * Search users/friends để chat&#10;     * GET /api/chat/search-users&#10;     */&#10;    searchFriendsToChat: (query) =&gt;&#10;        api.get('/chat/search-users', { params: { query } }),&#10;&#10;    /**&#10;     * Search users (general)&#10;     * GET /api/users/search&#10;     */&#10;    searchAllUsers: (query, limit = 20) =&gt;&#10;        api.get('/users/search', { params: { query, limit } }),&#10;&#10;    /**&#10;     * Thêm member vào group chat&#10;     * POST /api/conversations/{conversationId}/members/{memberId}&#10;     */&#10;    addMember: (conversationId, memberId) =&gt;&#10;        api.post(`/conversations/${conversationId}/members/${memberId}`),&#10;&#10;    /**&#10;     * Xóa member khỏi group chat&#10;     * DELETE /api/conversations/{conversationId}/members/{memberId}&#10;     */&#10;    removeMember: (conversationId, memberId) =&gt;&#10;        api.delete(`/conversations/${conversationId}/members/${memberId}`),&#10;&#10;    /**&#10;     * Rời khỏi group chat&#10;     * POST /api/conversations/{conversationId}/leave&#10;     */&#10;    leaveConversation: (conversationId) =&gt;&#10;        api.post(`/conversations/${conversationId}/leave`),&#10;};&#10;&#10;// =================================================================&#10;// PART 2: WEBSOCKET SERVICE&#10;// =================================================================&#10;&#10;class WebSocketChatService {&#10;    constructor() {&#10;        this.stompClient = null;&#10;        this.subscriptions = new Map();&#10;        this.currentUserId = null; // Sẽ được set sau khi connect&#10;    }&#10;&#10;    /**&#10;     * Kết nối tới WebSocket với JWT token&#10;     */&#10;    connect(onConnectedCallback, onErrorCallback) {&#10;        const token = localStorage.getItem('authToken');&#10;        if (!token) {&#10;            console.error('No auth token found');&#10;            onErrorCallback?.('No authentication token');&#10;            return;&#10;        }&#10;&#10;        const socket = new SockJS(`${BASE_URL}/ws`, null, {&#10;            transports: ['websocket']&#10;        });&#10;        this.stompClient = Stomp.over(socket);&#10;        this.stompClient.debug = () =&gt; { };&#10;&#10;        this.stompClient.configure({&#10;            connectHeaders: {&#10;                Authorization: `Bearer ${token}`&#10;            },&#10;            reconnectDelay: 5000,&#10;&#10;            onConnect: (frame) =&gt; {&#10;                console.log('✅ WebSocket connected:', frame);&#10;&#10;                // Lấy userId từ token response hoặc từ user info API&#10;                this.fetchCurrentUserId().then(() =&gt; {&#10;                    onConnectedCallback?.();&#10;                });&#10;            },&#10;            onStompError: (frame) =&gt; {&#10;                console.error('STOMP error:', frame.headers['message'], frame.body);&#10;                onErrorCallback?.(frame.headers['message']);&#10;            },&#10;            onWebSocketError: (event) =&gt; {&#10;                console.error('WebSocket error:', event);&#10;                onErrorCallback?.('WebSocket connection error');&#10;            }&#10;        });&#10;&#10;        this.stompClient.activate();&#10;    }&#10;&#10;    /**&#10;     * Lấy current user ID từ JWT token&#10;     * Parse trực tiếp từ token thay vì gọi API để tránh lỗi timing&#10;     */&#10;    async fetchCurrentUserId() {&#10;        const token = localStorage.getItem('authToken');&#10;        if (!token) {&#10;            console.error('No auth token found');&#10;            return;&#10;        }&#10;&#10;        try {&#10;            // Parse userId từ JWT token (client-side)&#10;            const payload = JSON.parse(atob(token.split('.')[1]));&#10;&#10;            // JWT token của bạn có thể chứa userId hoặc sub (subject)&#10;            // Thử cả 2 trường hợp&#10;            this.currentUserId = payload.userId || payload.id || payload.sub;&#10;&#10;            console.log('✅ Current user ID from JWT:', this.currentUserId);&#10;&#10;            // Nếu không có userId trong token, thử gọi API&#10;            if (!this.currentUserId) {&#10;                try {&#10;                    const response = await api.get('/users/me');&#10;                    this.currentUserId = response.id;&#10;                    console.log('✅ Current user ID from API:', this.currentUserId);&#10;                } catch (error) {&#10;                    console.error('Failed to fetch user from API, using email as fallback');&#10;                    // Fallback: dùng email (sub) nếu không có userId&#10;                    this.currentUserId = payload.sub;&#10;                }&#10;            }&#10;        } catch (e) {&#10;            console.error('Failed to parse JWT token:', e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get current user ID&#10;     */&#10;    getCurrentUserId() {&#10;        return this.currentUserId;&#10;    }&#10;&#10;    disconnect() {&#10;        this.stompClient?.deactivate();&#10;        this.subscriptions.clear();&#10;        this.currentUserId = null;&#10;        console.log('WebSocket disconnected');&#10;    }&#10;&#10;    subscribe(destination, callback) {&#10;        if (this.subscriptions.has(destination)) return;&#10;        const sub = this.stompClient.subscribe(destination, msg =&gt; {&#10;            callback(JSON.parse(msg.body));&#10;        });&#10;        this.subscriptions.set(destination, sub);&#10;    }&#10;&#10;&#10;    unsubscribe(destination) {&#10;        const sub = this.subscriptions.get(destination);&#10;        sub?.unsubscribe();&#10;        this.subscriptions.delete(destination);&#10;    }&#10;&#10;    /**&#10;     * Subscribe to conversation updates&#10;     */&#10;    subscribeToConversation(conversationId, onMessage, onTyping, onUpdate) {&#10;        if (!this.stompClient?.connected) return;&#10;&#10;        const msgPath = `/topic/conversation/${conversationId}`;&#10;        if (onMessage) this.subscribe(msgPath, onMessage);&#10;&#10;        const typingPath = `/topic/conversation/${conversationId}/typing`;&#10;        if (onTyping) this.subscribe(typingPath, onTyping);&#10;&#10;        const updatePath = `/topic/conversation/${conversationId}/update`;&#10;        if (onUpdate) this.subscribe(updatePath, onUpdate);&#10;    }&#10;&#10;    /**&#10;     * Subscribe to user's private queue&#10;     */&#10;    subscribeToUserQueue(onUnread, onError) {&#10;        if (!this.stompClient?.connected) return;&#10;&#10;        this.subscribe('/user/queue/unread', onUnread);&#10;        this.subscribe('/user/queue/errors', (error) =&gt; {&#10;            onError?.(typeof error === 'string' ? error : JSON.stringify(error));&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Subscribe to user's private queue for conversation updates&#10;     */&#10;    subscribeToConversationUpdates(onUpdate, onError) {&#10;        if (!this.stompClient?.connected) return;&#10;&#10;        this.subscribe('/user/queue/conversation-update', onUpdate);&#10;        this.subscribe('/user/queue/errors', (error) =&gt; {&#10;            onError?.(typeof error === 'string' ? error : JSON.stringify(error));&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Gửi tin nhắn qua WebSocket&#10;     * Backend sẽ tự động lấy senderId từ JWT token&#10;     */&#10;    sendChatMessage({ conversationId, content, messageType = 'TEXT', recipientId }) {&#10;        this.stompClient?.publish({&#10;            destination: '/app/sendMessage',&#10;            body: JSON.stringify({&#10;                conversationId,&#10;                content,&#10;                messageType,&#10;                recipientId&#10;                // Không cần senderId - backend sẽ lấy từ SecurityContext&#10;            })&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Gửi typing status&#10;     * Backend sẽ tự động lấy userId từ JWT token&#10;     */&#10;    sendTypingStatus({ conversationId, isTyping }) {&#10;        console.log('WebSocket sendTypingStatus called:', { conversationId, isTyping });&#10;        if (!this.stompClient?.connected) {&#10;            console.error('STOMP client not connected, cannot send typing status');&#10;            return;&#10;        }&#10;        const token = localStorage.getItem('authToken');&#10;        console.log('Publishing typing status to /app/typing with token:', !!token);&#10;        try {&#10;            this.stompClient.publish({&#10;                destination: '/app/typing',&#10;                body: JSON.stringify({&#10;                    conversationId,&#10;                    isTyping&#10;                    // Không cần userId - backend sẽ lấy từ SecurityContext&#10;                })&#10;            });&#10;            console.log('Publish successful');&#10;        } catch (error) {&#10;            console.error('Publish failed:', error);&#10;        }&#10;    }&#10;}&#10;&#10;export const webSocketService = new WebSocketChatService();&#10;&#10;// Make ChatService available globally for location sharing&#10;// window.ChatService = ChatService;&#10;" />
              <option name="updatedContent" value="import { api } from './apiClient';&#10;import SockJS from 'sockjs-client';&#10;import { Stomp } from '@stomp/stompjs';&#10;&#10;const BASE_URL = &quot;http://localhost:8080&quot;;&#10;&#10;// =================================================================&#10;// PART 1: REST API SERVICE&#10;// =================================================================&#10;// Backend sẽ tự động lấy userId từ JWT token qua @AuthenticationPrincipal&#10;// Không cần truyền userId từ frontend&#10;// =================================================================&#10;&#10;export const ChatService = {&#10;&#10;    /**&#10;     * Lấy danh sách conversations của user hiện tại&#10;     * GET /api/conversations&#10;     * Backend tự động lấy userId từ JWT&#10;     */&#10;    getUserConversations: () =&gt;&#10;        api.get('/conversations'),&#10;&#10;    /**&#10;     * Lấy conversation cụ thể&#10;     * GET /api/conversations/{conversationId}&#10;     */&#10;    getConversation: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}`),&#10;&#10;    /**&#10;     * Lấy hoặc tạo conversation private với user khác&#10;     * GET /api/conversations/private/{otherUserId}&#10;     */&#10;    getOrCreatePrivateConversation: (otherUserId) =&gt;&#10;        api.get(`/conversations/private/${otherUserId}`),&#10;&#10;    /**&#10;     * Tạo conversation mới (nhóm hoặc private)&#10;     * POST /api/conversations&#10;     * @param {object} data - { memberIds: string[], isGroup: boolean, groupName?: string, groupAvatar?: string }&#10;     */&#10;    createConversation: (data) =&gt;&#10;        api.post('/conversations', data),&#10;&#10;    /**&#10;     * Cập nhật thông tin group chat&#10;     * PUT /api/conversations/{conversationId}/group-info&#10;     */&#10;    updateGroupInfo: (conversationId, { groupName, groupAvatar }) =&gt;&#10;        api.put(`/conversations/${conversationId}/group-info`, null, {&#10;            params: { groupName, groupAvatar }&#10;        }),&#10;&#10;    /**&#10;     * Lấy lịch sử tin nhắn của conversation (phân trang)&#10;     * GET /api/conversations/{conversationId}/messages&#10;     */&#10;    getMessages: (conversationId, { page = 0, size = 50 } = {}) =&gt;&#10;        api.get(`/conversations/${conversationId}/messages`, {&#10;            params: { page, size }&#10;        }),&#10;&#10;    /**&#10;     * Lấy tin nhắn mới (chưa đọc)&#10;     * GET /api/conversations/{conversationId}/messages/new&#10;     */&#10;    getNewMessages: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}/messages/new`),&#10;&#10;    /**&#10;     * Gửi tin nhắn qua REST API&#10;     * POST /api/conversations/{conversationId}/messages&#10;     */&#10;    sendMessage: (conversationId, messageData) =&gt;&#10;        api.post(`/conversations/${conversationId}/messages`, messageData),&#10;&#10;    /**&#10;     * Sửa tin nhắn&#10;     * PUT /api/messages/{messageId}&#10;     */&#10;    editMessage: (messageId, content) =&gt;&#10;        api.put(`/messages/${messageId}`, null, {&#10;            params: { content }&#10;        }),&#10;&#10;    /**&#10;     * Xóa tin nhắn&#10;     * DELETE /api/messages/{messageId}&#10;     */&#10;    deleteMessage: (messageId) =&gt;&#10;        api.delete(`/messages/${messageId}`),&#10;&#10;    /**&#10;     * Search tin nhắn trong conversation&#10;     * GET /api/conversations/{conversationId}/messages/search&#10;     */&#10;    searchMessages: (conversationId, query) =&gt;&#10;        api.get(`/conversations/${conversationId}/messages/search`, {&#10;            params: { query }&#10;        }),&#10;&#10;    /**&#10;     * Đánh dấu tin nhắn đã đọc&#10;     * POST /api/conversations/{conversationId}/read&#10;     */&#10;    markAsRead: (conversationId) =&gt;&#10;        api.post(`/conversations/${conversationId}/read`),&#10;&#10;    /**&#10;     * Lấy số tin nhắn chưa đọc&#10;     * GET /api/conversations/{conversationId}/unread-count&#10;     */&#10;    getUnreadCount: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}/unread-count`),&#10;&#10;    /**&#10;     * Lấy danh sách users đang typing&#10;     * GET /api/conversations/{conversationId}/typing&#10;     */&#10;    getTypingUsers: (conversationId) =&gt;&#10;        api.get(`/conversations/${conversationId}/typing`),&#10;&#10;    /**&#10;     * Search users/friends để chat&#10;     * GET /api/chat/search-users&#10;     */&#10;    searchFriendsToChat: (query) =&gt;&#10;        api.get('/chat/search-users', { params: { query } }),&#10;&#10;    /**&#10;     * Search users (general)&#10;     * GET /api/users/search&#10;     */&#10;    searchAllUsers: (query, limit = 20) =&gt;&#10;        api.get('/users/search', { params: { query, limit } }),&#10;&#10;    /**&#10;     * Thêm member vào group chat&#10;     * POST /api/conversations/{conversationId}/members/{memberId}&#10;     */&#10;    addMember: (conversationId, memberId) =&gt;&#10;        api.post(`/conversations/${conversationId}/members/${memberId}`),&#10;&#10;    /**&#10;     * Xóa member khỏi group chat&#10;     * DELETE /api/conversations/{conversationId}/members/{memberId}&#10;     */&#10;    removeMember: (conversationId, memberId) =&gt;&#10;        api.delete(`/conversations/${conversationId}/members/${memberId}`),&#10;&#10;    /**&#10;     * Rời khỏi group chat&#10;     * POST /api/conversations/{conversationId}/leave&#10;     */&#10;    leaveConversation: (conversationId) =&gt;&#10;        api.post(`/conversations/${conversationId}/leave`),&#10;};&#10;&#10;// =================================================================&#10;// PART 2: WEBSOCKET SERVICE&#10;// =================================================================&#10;&#10;class WebSocketChatService {&#10;    constructor() {&#10;        this.stompClient = null;&#10;        this.subscriptions = new Map(); // Map&lt;destination, subscription&gt;&#10;        this.callbacks = new Map(); // Map&lt;destination, Set&lt;callback&gt;&gt;&#10;        this.currentUserId = null; // Sẽ được set sau khi connect&#10;    }&#10;&#10;    /**&#10;     * Kết nối tới WebSocket với JWT token&#10;     */&#10;    connect(onConnectedCallback, onErrorCallback) {&#10;        const token = localStorage.getItem('authToken');&#10;        if (!token) {&#10;            console.error('No auth token found');&#10;            onErrorCallback?.('No authentication token');&#10;            return;&#10;        }&#10;&#10;        const socket = new SockJS(`${BASE_URL}/ws`, null, {&#10;            transports: ['websocket']&#10;        });&#10;        this.stompClient = Stomp.over(socket);&#10;        this.stompClient.debug = () =&gt; { };&#10;&#10;        this.stompClient.configure({&#10;            connectHeaders: {&#10;                Authorization: `Bearer ${token}`&#10;            },&#10;            reconnectDelay: 5000,&#10;&#10;            onConnect: (frame) =&gt; {&#10;                console.log('✅ WebSocket connected:', frame);&#10;&#10;                // Lấy userId từ token response hoặc từ user info API&#10;                this.fetchCurrentUserId().then(() =&gt; {&#10;                    onConnectedCallback?.();&#10;                });&#10;            },&#10;            onStompError: (frame) =&gt; {&#10;                console.error('STOMP error:', frame.headers['message'], frame.body);&#10;                onErrorCallback?.(frame.headers['message']);&#10;            },&#10;            onWebSocketError: (event) =&gt; {&#10;                console.error('WebSocket error:', event);&#10;                onErrorCallback?.('WebSocket connection error');&#10;            }&#10;        });&#10;&#10;        this.stompClient.activate();&#10;    }&#10;&#10;    /**&#10;     * Lấy current user ID từ JWT token&#10;     * Parse trực tiếp từ token thay vì gọi API để tránh lỗi timing&#10;     */&#10;    async fetchCurrentUserId() {&#10;        const token = localStorage.getItem('authToken');&#10;        if (!token) {&#10;            console.error('No auth token found');&#10;            return;&#10;        }&#10;&#10;        try {&#10;            // Parse userId từ JWT token (client-side)&#10;            const payload = JSON.parse(atob(token.split('.')[1]));&#10;&#10;            // JWT token của bạn có thể chứa userId hoặc sub (subject)&#10;            // Thử cả 2 trường hợp&#10;            this.currentUserId = payload.userId || payload.id || payload.sub;&#10;&#10;            console.log('✅ Current user ID from JWT:', this.currentUserId);&#10;&#10;            // Nếu không có userId trong token, thử gọi API&#10;            if (!this.currentUserId) {&#10;                try {&#10;                    const response = await api.get('/users/me');&#10;                    this.currentUserId = response.id;&#10;                    console.log('✅ Current user ID from API:', this.currentUserId);&#10;                } catch {&#10;                    console.error('Failed to fetch user from API, using email as fallback');&#10;                    // Fallback: dùng email (sub) nếu không có userId&#10;                    this.currentUserId = payload.sub;&#10;                }&#10;            }&#10;        } catch (e) {&#10;            console.error('Failed to parse JWT token:', e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get current user ID&#10;     */&#10;    getCurrentUserId() {&#10;        return this.currentUserId;&#10;    }&#10;&#10;    disconnect() {&#10;        this.stompClient?.deactivate();&#10;        this.subscriptions.clear();&#10;        this.callbacks.clear();&#10;        this.currentUserId = null;&#10;        console.log('WebSocket disconnected');&#10;    }&#10;&#10;    subscribe(destination, callback) {&#10;        // Add callback to callbacks set&#10;        if (!this.callbacks.has(destination)) {&#10;            this.callbacks.set(destination, new Set());&#10;        }&#10;        this.callbacks.get(destination).add(callback);&#10;&#10;        // Only subscribe to STOMP if not already subscribed&#10;        if (!this.subscriptions.has(destination)) {&#10;            const sub = this.stompClient.subscribe(destination, msg =&gt; {&#10;                const data = JSON.parse(msg.body);&#10;                // Call all registered callbacks for this destination&#10;                const callbacks = this.callbacks.get(destination);&#10;                if (callbacks) {&#10;                    callbacks.forEach(cb =&gt; cb(data));&#10;                }&#10;            });&#10;            this.subscriptions.set(destination, sub);&#10;            console.log(`✅ Subscribed to ${destination}`);&#10;        } else {&#10;            console.log(`⚡ Added callback to existing subscription: ${destination}`);&#10;        }&#10;    }&#10;&#10;    unsubscribe(destination, callback) {&#10;        // If callback provided, remove only that callback&#10;        if (callback &amp;&amp; this.callbacks.has(destination)) {&#10;            this.callbacks.get(destination).delete(callback);&#10;            &#10;            // If no more callbacks, unsubscribe from STOMP&#10;            if (this.callbacks.get(destination).size === 0) {&#10;                this.callbacks.delete(destination);&#10;                const sub = this.subscriptions.get(destination);&#10;                sub?.unsubscribe();&#10;                this.subscriptions.delete(destination);&#10;                console.log(` Unsubscribed from ${destination}`);&#10;            } else {&#10;                console.log(` Removed callback from ${destination}, ${this.callbacks.get(destination).size} remaining`);&#10;            }&#10;        } else {&#10;            // Remove all callbacks and unsubscribe&#10;            this.callbacks.delete(destination);&#10;            const sub = this.subscriptions.get(destination);&#10;            sub?.unsubscribe();&#10;            this.subscriptions.delete(destination);&#10;            console.log(` Unsubscribed from ${destination}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Subscribe to conversation updates&#10;     */&#10;    subscribeToConversation(conversationId, onMessage, onTyping, onUpdate) {&#10;        if (!this.stompClient?.connected) return;&#10;&#10;        const msgPath = `/topic/conversation/${conversationId}`;&#10;        if (onMessage) this.subscribe(msgPath, onMessage);&#10;&#10;        const typingPath = `/topic/conversation/${conversationId}/typing`;&#10;        if (onTyping) this.subscribe(typingPath, onTyping);&#10;&#10;        const updatePath = `/topic/conversation/${conversationId}/update`;&#10;        if (onUpdate) this.subscribe(updatePath, onUpdate);&#10;    }&#10;&#10;    /**&#10;     * Subscribe to user's private queue&#10;     */&#10;    subscribeToUserQueue(onUnread, onError) {&#10;        if (!this.stompClient?.connected) return;&#10;&#10;        this.subscribe('/user/queue/unread', onUnread);&#10;        this.subscribe('/user/queue/errors', (error) =&gt; {&#10;            onError?.(typeof error === 'string' ? error : JSON.stringify(error));&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Subscribe to user's private queue for conversation updates&#10;     */&#10;    subscribeToConversationUpdates(onUpdate, onError) {&#10;        if (!this.stompClient?.connected) return;&#10;&#10;        this.subscribe('/user/queue/conversation-update', onUpdate);&#10;        this.subscribe('/user/queue/errors', (error) =&gt; {&#10;            onError?.(typeof error === 'string' ? error : JSON.stringify(error));&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Gửi tin nhắn qua WebSocket&#10;     * Backend sẽ tự động lấy senderId từ JWT token&#10;     */&#10;    sendChatMessage({ conversationId, content, messageType = 'TEXT', recipientId }) {&#10;        this.stompClient?.publish({&#10;            destination: '/app/sendMessage',&#10;            body: JSON.stringify({&#10;                conversationId,&#10;                content,&#10;                messageType,&#10;                recipientId&#10;                // Không cần senderId - backend sẽ lấy từ SecurityContext&#10;            })&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Gửi typing status&#10;     * Backend sẽ tự động lấy userId từ JWT token&#10;     */&#10;    sendTypingStatus({ conversationId, isTyping }) {&#10;        console.log('WebSocket sendTypingStatus called:', { conversationId, isTyping });&#10;        if (!this.stompClient?.connected) {&#10;            console.error('STOMP client not connected, cannot send typing status');&#10;            return;&#10;        }&#10;        const token = localStorage.getItem('authToken');&#10;        console.log('Publishing typing status to /app/typing with token:', !!token);&#10;        try {&#10;            this.stompClient.publish({&#10;                destination: '/app/typing',&#10;                body: JSON.stringify({&#10;                    conversationId,&#10;                    isTyping&#10;                    // Không cần userId - backend sẽ lấy từ SecurityContext&#10;                })&#10;            });&#10;            console.log('Publish successful');&#10;        } catch (error) {&#10;            console.error('Publish failed:', error);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gửi mark as read request qua WebSocket&#10;     * Backend sẽ tự động lấy userId từ JWT token&#10;     */&#10;    sendMarkAsRead({ conversationId }) {&#10;        if (!this.stompClient?.connected) {&#10;            console.error('STOMP client not connected, cannot send mark as read');&#10;            return;&#10;        }&#10;        try {&#10;            this.stompClient.publish({&#10;                destination: '/app/markAsRead',&#10;                body: JSON.stringify({&#10;                    conversationId&#10;                    // Không cần userId - backend sẽ lấy từ SecurityContext&#10;                })&#10;            });&#10;            console.log('Mark as read sent for conversation:', conversationId);&#10;        } catch (error) {&#10;            console.error('Failed to send mark as read:', error);&#10;        }&#10;    }&#10;}&#10;&#10;export const webSocketService = new WebSocketChatService();&#10;&#10;// Make ChatService available globally for location sharing&#10;// window.ChatService = ChatService;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>