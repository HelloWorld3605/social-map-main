<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIX_SIDECHAT_RELOAD_ON_OPEN.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_SIDECHAT_RELOAD_ON_OPEN.md" />
              <option name="updatedContent" value="# ✅ FIX: Reload Conversations When SideChat Opens&#10;&#10;## Vấn Đề Đã Fix&#10;&#10;❌ **TRƯỚC:**&#10;```&#10;Timeline:&#10;T0: User B vào trang (SideChat chưa mở/mount)&#10;T1: User A gửi tin nhắn cho User B&#10;T2: Backend broadcast → nhưng User B chưa subscribe!&#10;T3: User B mở SideChat&#10;T4: SideChat load conversations từ cache/old data&#10;T5: ❌ Không thấy tin nhắn mới của User A&#10;T6: ❌ unreadCount = 0 (sai!)&#10;```&#10;&#10;✅ **SAU:**&#10;```&#10;Timeline:&#10;T0: User B vào trang (SideChat chưa mở/mount)&#10;T1: User A gửi tin nhắn cho User B&#10;T2: Backend lưu vào database + update lastMessage &amp; unreadCount&#10;T3: User B mở SideChat&#10;T4: ✅ SideChat RELOAD conversations từ API&#10;T5: ✅ GET /api/conversations → latest data from database&#10;T6: ✅ Thấy tin nhắn mới của User A&#10;T7: ✅ unreadCount = 1 (đúng!)&#10;```&#10;&#10;## Root Cause&#10;&#10;### Problem 1: Component Lifecycle Issue&#10;&#10;**OLD CODE:**&#10;```javascript&#10;// Load conversations ONLY on mount&#10;useEffect(() =&gt; {&#10;    console.log(' Loading conversations on mount');&#10;    loadConversations();&#10;}, [loadConversations]);&#10;```&#10;&#10;**Timeline:**&#10;```&#10;User B vào trang:&#10;  → SideChat component CHƯA mount (popup đóng)&#10;  → useEffect KHÔNG chạy&#10;  → loadConversations() KHÔNG được gọi&#10;  → Không có data!&#10;&#10;User A gửi tin nhắn:&#10;  → Backend lưu vào DB&#10;  → Backend broadcast via WebSocket&#10;  → User B chưa subscribe (component chưa mount)&#10;  → Message BỊ MISS!&#10;&#10;User B mở SideChat:&#10;  → Component mount lần đầu&#10;  → useEffect chạy → loadConversations()&#10;  → Load từ cache/old state&#10;  → ❌ Không có tin nhắn mới!&#10;```&#10;&#10;### Problem 2: WebSocket Miss Window&#10;&#10;```&#10;User B chưa subscribe → Messages sent during this time = LOST!&#10;&#10;Timeline:&#10;  T0: User B vào page&#10;  T1-T5: User A sends 5 messages&#10;  T6: User B mở SideChat&#10;  T7: Subscribe to WebSocket&#10;  T8: Only receive messages AFTER T7&#10;  &#10;  Result: 5 messages LOST! ❌&#10;```&#10;&#10;## Solution Applied&#10;&#10;### Add Reload on SideChat Open&#10;&#10;**NEW CODE:**&#10;```javascript&#10;// Load conversations on mount - CRITICAL: Load BEFORE subscribing&#10;useEffect(() =&gt; {&#10;    console.log(' Loading conversations on mount');&#10;    loadConversations();&#10;}, [loadConversations]);&#10;&#10;// ✅ Reload conversations when SideChat opens to get latest data&#10;useEffect(() =&gt; {&#10;    if (isChatOpen) {&#10;        console.log(' SideChat opened - reloading conversations to get latest messages');&#10;        loadConversations();&#10;    }&#10;}, [isChatOpen, loadConversations]);&#10;```&#10;&#10;**How It Works:**&#10;```&#10;User B mở SideChat:&#10;  → isChatOpen changes: false → true&#10;  → useEffect triggers&#10;  → loadConversations() được gọi&#10;  → GET /api/conversations&#10;  → Backend query database&#10;  → Return LATEST data (including messages sent while offline)&#10;  → ✅ User B sees all messages!&#10;```&#10;&#10;## Timeline Comparison&#10;&#10;### Before Fix (❌):&#10;&#10;```&#10;T0: User B vào page&#10;    - SideChat closed&#10;    - No component mount&#10;    - No data load&#10;    &#10;T1: User A → &quot;Hello&quot;&#10;    - Backend saves to DB&#10;    - lastMessage = &quot;Hello&quot;&#10;    - unreadCount = 1&#10;    - Broadcast via WebSocket&#10;    - User B not subscribed → MISSED!&#10;    &#10;T2: User A → &quot;How are you?&quot;&#10;    - Backend saves to DB&#10;    - lastMessage = &quot;How are you?&quot;&#10;    - unreadCount = 2&#10;    - Broadcast via WebSocket&#10;    - User B not subscribed → MISSED!&#10;    &#10;T3: User B opens SideChat&#10;    - Component mounts&#10;    - loadConversations() runs ONCE&#10;    - Gets old/cached data&#10;    - lastMessage = &quot;&quot; (old)&#10;    - unreadCount = 0 (old)&#10;    - ❌ User B sees NO new messages!&#10;    &#10;T4: User A → &quot;Are you there?&quot;&#10;    - Broadcast via WebSocket&#10;    - User B NOW subscribed&#10;    - ✅ Receives this message&#10;    - But LOST previous 2 messages! ❌&#10;```&#10;&#10;### After Fix (✅):&#10;&#10;```&#10;T0: User B vào page&#10;    - SideChat closed&#10;    - No component mount&#10;    &#10;T1: User A → &quot;Hello&quot;&#10;    - Backend saves to DB&#10;    - lastMessage = &quot;Hello&quot;&#10;    - unreadCount = 1&#10;    - Broadcast (User B not listening, but OK!)&#10;    &#10;T2: User A → &quot;How are you?&quot;&#10;    - Backend saves to DB&#10;    - lastMessage = &quot;How are you?&quot;&#10;    - unreadCount = 2&#10;    - Broadcast (User B not listening, but OK!)&#10;    &#10;T3: User B opens SideChat&#10;    - isChatOpen: false → true&#10;    - ✅ Triggers reload useEffect&#10;    - ✅ loadConversations() called&#10;    - ✅ GET /api/conversations&#10;    - ✅ Backend returns LATEST from DB:&#10;      {&#10;        lastMessage: &quot;How are you?&quot;,&#10;        unreadCount: 2&#10;      }&#10;    - ✅ User B sees all messages!&#10;    - ✅ Badge shows [2]&#10;    &#10;T4: User A → &quot;Are you there?&quot;&#10;    - Broadcast via WebSocket&#10;    - User B subscribed&#10;    - ✅ Real-time update&#10;    - unreadCount: 2 → 3&#10;```&#10;&#10;## Benefits&#10;&#10;### 1. No Lost Messages:&#10;```&#10;Before: Messages sent while offline = LOST ❌&#10;After: Messages fetched from DB when open ✅&#10;```&#10;&#10;### 2. Correct Unread Count:&#10;```&#10;Before: unreadCount = 0 (wrong) ❌&#10;After: unreadCount = actual count from DB ✅&#10;```&#10;&#10;### 3. Latest Last Message:&#10;```&#10;Before: lastMessage = old/empty ❌&#10;After: lastMessage = latest from DB ✅&#10;```&#10;&#10;### 4. Hybrid Approach:&#10;```&#10;When SideChat opens:&#10;  → Fetch from API (catch up on missed messages) ✅&#10;  &#10;When already open:&#10;  → WebSocket real-time updates ✅&#10;  &#10;Best of both worlds!&#10;```&#10;&#10;## API Call Flow&#10;&#10;### When User Opens SideChat:&#10;&#10;```&#10;Frontend:&#10;  isChatOpen: false → true&#10;  ↓&#10;  useEffect triggers&#10;  ↓&#10;  loadConversations() called&#10;  ↓&#10;  await ChatService.getUserConversations()&#10;  ↓&#10;  GET /api/conversations&#10;  &#10;Backend:&#10;  Query database for user's conversations&#10;  ↓&#10;  Include latest lastMessage, lastMessageAt, unreadCount&#10;  ↓&#10;  Return: [&#10;    {&#10;      id: &quot;conv1&quot;,&#10;      lastMessageContent: &quot;How are you?&quot;,&#10;      lastMessageAt: &quot;2024-01-01T10:05:00&quot;,&#10;      unreadCount: 2&#10;    },&#10;    // ...more conversations&#10;  ]&#10;  &#10;Frontend:&#10;  Receives response&#10;  ↓&#10;  setConversations(data)&#10;  ↓&#10;  UI updates with latest data ✅&#10;```&#10;&#10;## Code Changes&#10;&#10;### SideChat.jsx:&#10;&#10;```diff&#10;  // Load conversations on mount&#10;  useEffect(() =&gt; {&#10;      console.log(' Loading conversations on mount');&#10;      loadConversations();&#10;  }, [loadConversations]);&#10;&#10;+ // ✅ Reload conversations when SideChat opens&#10;+ useEffect(() =&gt; {&#10;+     if (isChatOpen) {&#10;+         console.log(' SideChat opened - reloading conversations');&#10;+         loadConversations();&#10;+     }&#10;+ }, [isChatOpen, loadConversations]);&#10;```&#10;&#10;**Total:** 7 lines added&#10;&#10;## Performance Considerations&#10;&#10;### Concern: Extra API Call?&#10;&#10;**Answer:** Yes, but necessary!&#10;&#10;```&#10;Scenario 1: User opens SideChat frequently&#10;  → API call each time&#10;  → But user expects fresh data&#10;  → Acceptable!&#10;&#10;Scenario 2: User keeps SideChat open&#10;  → Only 1 API call on initial open&#10;  → Then WebSocket real-time updates&#10;  → Efficient!&#10;&#10;Scenario 3: User rarely opens SideChat&#10;  → API call when opened&#10;  → Gets all missed messages at once&#10;  → Better than losing messages!&#10;```&#10;&#10;### Optimization Options (Future):&#10;&#10;```javascript&#10;// Option 1: Cache with timestamp&#10;const lastFetchTime = useRef(null);&#10;if (Date.now() - lastFetchTime.current &gt; 30000) {&#10;    // Only reload if &gt; 30 seconds since last fetch&#10;    loadConversations();&#10;}&#10;&#10;// Option 2: Check if subscribed&#10;if (!wsConnectedRef.current) {&#10;    // Only reload if WebSocket not connected&#10;    loadConversations();&#10;}&#10;```&#10;&#10;## Testing&#10;&#10;### Test 1: Basic Flow&#10;```&#10;1. User B vào page (không mở SideChat)&#10;2. User A gửi 3 messages&#10;3. User B mở SideChat&#10;&#10;Expected:&#10;  ✅ SideChat shows all 3 messages&#10;  ✅ lastMessage = message thứ 3&#10;  ✅ unreadCount = 3&#10;  ✅ Badge [3]&#10;```&#10;&#10;### Test 2: Multiple Messages&#10;```&#10;1. User B vào page&#10;2. User A gửi &quot;Hello&quot;&#10;3. Wait 1 second&#10;4. User A gửi &quot;How are you?&quot;&#10;5. Wait 1 second&#10;6. User A gửi &quot;Are you there?&quot;&#10;7. User B mở SideChat&#10;&#10;Expected:&#10;  ✅ lastMessage = &quot;Are you there?&quot;&#10;  ✅ unreadCount = 3&#10;  ✅ All messages visible when open chat&#10;```&#10;&#10;### Test 3: Real-time After Open&#10;```&#10;1. User B mở SideChat&#10;2. User A gửi new message&#10;&#10;Expected:&#10;  ✅ Message appears instantly (WebSocket)&#10;  ✅ lastMessage updates&#10;  ✅ unreadCount increments&#10;```&#10;&#10;### Test 4: Close and Reopen&#10;```&#10;1. User B mở SideChat (loads data)&#10;2. User B đóng SideChat&#10;3. User A gửi message (User B miss it)&#10;4. User B mở lại SideChat&#10;&#10;Expected:&#10;  ✅ Reload triggered&#10;  ✅ New message appears&#10;  ✅ unreadCount correct&#10;```&#10;&#10;## Console Logs&#10;&#10;### When User Opens SideChat:&#10;&#10;```javascript&#10; SideChat opened - reloading conversations to get latest messages&#10; Loading conversations...&#10;✅ Loaded 5 conversations with latest data&#10;```&#10;&#10;### Data Structure:&#10;&#10;```javascript&#10;[&#10;  {&#10;    id: &quot;conv123&quot;,&#10;    otherUser: {&#10;      userId: &quot;userA&quot;,&#10;      username: &quot;User A&quot;,&#10;      avatar: &quot;...&quot;&#10;    },&#10;    lastMessageContent: &quot;How are you?&quot;,  // ✅ Latest from DB&#10;    lastMessageAt: &quot;2024-01-01T10:05:00&quot;,&#10;    unreadCount: 2,  // ✅ Correct count&#10;    typingUsers: []&#10;  },&#10;  // ...more conversations&#10;]&#10;```&#10;&#10;## Edge Cases Handled&#10;&#10;### 1. First Time Opening:&#10;```&#10;Component mounts → load on mount ✅&#10;isChatOpen changes → reload ✅&#10;Total: 2 API calls (one redundant but safe)&#10;```&#10;&#10;### 2. Already Open:&#10;```&#10;isChatOpen stays true → no reload ✅&#10;WebSocket handles updates ✅&#10;```&#10;&#10;### 3. Rapid Open/Close:&#10;```&#10;Each open → reload&#10;Gets latest data each time ✅&#10;```&#10;&#10;### 4. No WebSocket Connection:&#10;```&#10;SideChat opens → API call ✅&#10;Gets data even without WebSocket ✅&#10;```&#10;&#10;## Summary&#10;&#10;### Problem:&#10;- ❌ Messages sent before SideChat opens = LOST&#10;- ❌ unreadCount wrong&#10;- ❌ lastMessage old/missing&#10;&#10;### Solution:&#10;- ✅ Reload conversations when SideChat opens&#10;- ✅ Fetch latest from database&#10;- ✅ Hybrid: API on open + WebSocket while open&#10;&#10;### Result:&#10;- ✅ No lost messages&#10;- ✅ Correct unread count&#10;- ✅ Latest last message&#10;- ✅ Real-time updates when open&#10;&#10; **Perfect! User B now sees all messages when opening SideChat!**&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map-fe/src/components/Chat/ChatWindow.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/components/Chat/ChatWindow.jsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;import './ChatWindows.css';&#10;&#10;export default function ChatWindow({&#10;    conversation,&#10;    minimized,&#10;    isActive,&#10;    currentUserId,&#10;    onClose,&#10;    onMinimize,&#10;    onNewMessage,&#10;    onMarkAsRead,&#10;    onWindowClick,&#10;    unreadCount = 0&#10;}) {&#10;    const [messages, setMessages] = useState([]);&#10;    const [inputValue, setInputValue] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [hasMore, setHasMore] = useState(true);&#10;    const [currentPage, setCurrentPage] = useState(0);&#10;    const [typingUsers, setTypingUsers] = useState([]);&#10;    const [isSending, setIsSending] = useState(false);&#10;&#10;    const messagesEndRef = useRef(null);&#10;    const messagesContainerRef = useRef(null);&#10;    const lastScrollHeightRef = useRef(0);&#10;    const isLoadingMoreRef = useRef(false);&#10;    const inputRef = useRef(null);&#10;    const navigate = useNavigate();&#10;&#10;    // Track if user is currently typing to avoid unnecessary cleanup messages&#10;    const isTypingRef = useRef(false);&#10;&#10;    // Get display info&#10;    const getDisplayInfo = useCallback(() =&gt; {&#10;        if (!conversation) return { name: '', avatar: '', status: '' };&#10;&#10;        if (conversation.isGroup) {&#10;            return {&#10;                name: conversation.groupName || 'Nhóm',&#10;                avatar: conversation.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conversation.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.isOnline ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    }, [conversation, currentUserId]);&#10;&#10;    const displayInfo = getDisplayInfo();&#10;&#10;    // Load initial messages&#10;    const loadMessages = useCallback(async (page = 0) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        try {&#10;            setIsLoading(true);&#10;            const response = await ChatService.getMessages(conversation.id, { page, size: 20 });&#10;&#10;            if (page === 0) {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    }&#10;                    return msg;&#10;                }).reverse();&#10;                setMessages(processedMessages);&#10;            } else {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    } // ✅ thêm dấu đóng if&#10;                    return msg;&#10;                }).reverse();&#10;&#10;                setMessages(prev =&gt; [...processedMessages, ...prev]);&#10;            }&#10;&#10;            setHasMore(!response.last);&#10;            setCurrentPage(page);&#10;        } catch (error) {&#10;            console.error('Failed to load messages:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;            isLoadingMoreRef.current = false;&#10;        }&#10;    }, [conversation?.id]);&#10;&#10;    // Load more messages on scroll&#10;    const handleScroll = useCallback(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (!container || isLoadingMoreRef.current || !hasMore) return;&#10;&#10;        if (container.scrollTop === 0) {&#10;            isLoadingMoreRef.current = true;&#10;            lastScrollHeightRef.current = container.scrollHeight;&#10;            loadMessages(currentPage + 1);&#10;        }&#10;    }, [currentPage, hasMore, loadMessages]);&#10;&#10;    // Maintain scroll position after loading more&#10;    useEffect(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (container &amp;&amp; lastScrollHeightRef.current &gt; 0) {&#10;            const newScrollHeight = container.scrollHeight;&#10;            container.scrollTop = newScrollHeight - lastScrollHeightRef.current;&#10;            lastScrollHeightRef.current = 0;&#10;        }&#10;    }, [messages]);&#10;&#10;    // Scroll to bottom for new messages&#10;    const scrollToBottom = useCallback((smooth = false) =&gt; {&#10;        if (messagesContainerRef.current) {&#10;            messagesContainerRef.current.scrollTo({&#10;                top: messagesContainerRef.current.scrollHeight,&#10;                behavior: smooth ? 'smooth' : 'auto'&#10;            });&#10;        }&#10;    }, []);&#10;&#10;    // Load messages on conversation change&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id) {&#10;            setMessages([]);&#10;            setCurrentPage(0);&#10;            setHasMore(true);&#10;            loadMessages(0);&#10;        }&#10;    }, [conversation?.id, loadMessages]);&#10;&#10;    // Track previous isActive state to detect actual changes&#10;    // ✅ IMPORTANT: Start with false so first active=true will be detected as transition&#10;    const prevIsActiveRef = useRef(false);&#10;&#10;    // Mark as read ONLY when isActive changes to true (not just when window opens)&#10;    useEffect(() =&gt; {&#10;        const wasActive = prevIsActiveRef.current;&#10;        const isNowActive = isActive;&#10;&#10;        console.log(' Mark as read check:', {&#10;            conversationId: conversation?.id,&#10;            minimized,&#10;            wasActive,&#10;            isNowActive,&#10;            isActiveChanged: wasActive !== isNowActive,&#10;            shouldMark: conversation?.id &amp;&amp; !minimized &amp;&amp; isNowActive &amp;&amp; !wasActive&#10;        });&#10;&#10;        // Only mark as read when:&#10;        // 1. Window becomes active (wasActive = false → isNowActive = true)&#10;        // 2. AND window is not minimized&#10;        if (conversation?.id &amp;&amp; !minimized &amp;&amp; isNowActive &amp;&amp; !wasActive) {&#10;            console.log('✅ Marking as read (window became active):', conversation.id);&#10;            ChatService.markAsRead(conversation.id).catch(console.error);&#10;            if (onMarkAsRead) {&#10;                onMarkAsRead(conversation.id);&#10;            }&#10;        } else {&#10;            console.log('⏭️ Skipping mark as read:', {&#10;                hasId: !!conversation?.id,&#10;                minimized,&#10;                wasActive,&#10;                isNowActive,&#10;                reason: !isNowActive ? 'not active' : wasActive ? 'already was active' : 'minimized'&#10;            });&#10;        }&#10;&#10;        // Update previous state&#10;        prevIsActiveRef.current = isNowActive;&#10;    }, [conversation?.id, minimized, isActive, onMarkAsRead]);&#10;&#10;    // Subscribe to WebSocket updates&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Create callbacks with stable references for cleanup&#10;        const messageCallback = (message) =&gt; {&#10;            console.log(' ChatWindow received new message:', message);&#10;            // New message&#10;            let processedMessage = message;&#10;&#10;            // Handle location messages&#10;            if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                try {&#10;                    const locationData = JSON.parse(message.content.substring(9));&#10;                    processedMessage = {&#10;                        ...message,&#10;                        content: locationData,&#10;                        isLocation: true&#10;                    };&#10;                } catch (e) {&#10;                    console.error('Failed to parse location message:', e);&#10;                }&#10;            }&#10;&#10;            setMessages(prev =&gt; [...prev, processedMessage]);&#10;            scrollToBottom(true);&#10;&#10;            // Notify parent&#10;            if (onNewMessage) {&#10;                onNewMessage(processedMessage);&#10;            }&#10;&#10;            // Auto mark as read if window is ACTIVE, not minimized, and message is from others&#10;            console.log(' Auto mark check:', {&#10;                conversationId: conversation.id,&#10;                isActive,&#10;                minimized,&#10;                isFromOthers: message.senderId !== currentUserId,&#10;                senderId: message.senderId,&#10;                currentUserId,&#10;                shouldAutoMark: isActive &amp;&amp; !minimized &amp;&amp; message.senderId !== currentUserId&#10;            });&#10;&#10;            if (isActive &amp;&amp; !minimized &amp;&amp; message.senderId !== currentUserId) {&#10;                console.log('✅ Auto-marking as read (window ACTIVE, not minimized, message from others)');&#10;                console.log('⚠️ VERIFY: Is this window actually active? Check visual state!');&#10;                // Send via WebSocket for real-time&#10;                webSocketService.sendMarkAsRead({ conversationId: conversation.id });&#10;                // Also call REST API as backup&#10;                ChatService.markAsRead(conversation.id).catch(console.error);&#10;                // Update parent state&#10;                if (onMarkAsRead) {&#10;                    onMarkAsRead(conversation.id);&#10;                }&#10;            } else {&#10;                console.log('⏭️ Skipping auto mark as read - window not active or message from self');&#10;            }&#10;        };&#10;&#10;        const typingCallback = (typingDTO) =&gt; {&#10;            // Typing indicator&#10;            console.log(' ChatWindow received typing from WebSocket:', typingDTO, 'currentUserId:', currentUserId);&#10;&#10;            // Handle both 'typing' and 'isTyping' field names from backend&#10;            const isTyping = typingDTO.typing ?? typingDTO.isTyping ?? false;&#10;&#10;            if (typingDTO.userId !== currentUserId) {&#10;                if (isTyping) {&#10;                    // User started typing&#10;                    const user = conversation.isGroup&#10;                        ? conversation.members?.find(m =&gt; m.userId === typingDTO.userId)&#10;                        : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                    const avatar = user?.avatarUrl || '/channels/myprofile.jpg';&#10;                    const name = user?.fullName || typingDTO.username || 'User';&#10;&#10;                    setTypingUsers(prev =&gt; {&#10;                        const alreadyTyping = prev.some(u =&gt; u.userId === typingDTO.userId);&#10;                        if (alreadyTyping) {&#10;                            console.log(`⏭️ User ${typingDTO.userId} already in typingUsers, skipping`);&#10;                            return prev;&#10;                        }&#10;                        const newUsers = [...prev, { userId: typingDTO.userId, avatar, name }];&#10;                        console.log(`✍️ Added user ${typingDTO.userId} (${name}) to typingUsers:`, newUsers);&#10;                        return newUsers;&#10;                    });&#10;                } else {&#10;                    // User stopped typing&#10;                    setTypingUsers(prev =&gt; {&#10;                        const newUsers = prev.filter(u =&gt; u.userId !== typingDTO.userId);&#10;                        console.log(`⏹️ Removed user ${typingDTO.userId} from typingUsers. Before:`, prev.length, 'After:', newUsers.length);&#10;                        return newUsers;&#10;                    });&#10;                }&#10;&#10;                // Dispatch event to update SideChat (if needed)&#10;                console.log(' ChatWindow dispatching typingStatus event');&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conversation.id, isTyping: isTyping, userId: typingDTO.userId }&#10;                }));&#10;            } else {&#10;                console.log('⏭️ Skipping typing from self (currentUser)');&#10;            }&#10;        };&#10;&#10;        const updateCallback = (updatedMessage) =&gt; {&#10;            // Message edited/deleted&#10;            setMessages(prev =&gt; prev.map(msg =&gt;&#10;                msg.id === updatedMessage.id ? updatedMessage : msg&#10;            ));&#10;        };&#10;&#10;        // Subscribe with callback references&#10;        console.log(' ChatWindow subscribing to conversation:', conversation.id);&#10;        webSocketService.subscribeToConversation(&#10;            conversation.id,&#10;            messageCallback,&#10;            typingCallback,&#10;            updateCallback&#10;        );&#10;&#10;        return () =&gt; {&#10;            // Cleanup: Send typing stopped ONLY if user was typing&#10;            if (isTypingRef.current) {&#10;                console.log(' ChatWindow cleanup: user was typing, sending stopped');&#10;                webSocketService.sendTypingStatus({&#10;                    conversationId: conversation.id,&#10;                    isTyping: false&#10;                });&#10;                isTypingRef.current = false;&#10;            }&#10;&#10;            // Unsubscribe ONLY ChatWindow's callbacks (not SideChat's!)&#10;            console.log(' ChatWindow cleanup: unsubscribing callbacks for', conversation.id);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}`, messageCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/typing`, typingCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/update`, updateCallback);&#10;        };&#10;    }, [conversation?.id, currentUserId, isActive, minimized, onMarkAsRead]); // ✅ FIXED: Add deps to prevent stale closure&#10;&#10;    // Handle page reload/close - cleanup typing indicator&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        const handleBeforeUnload = () =&gt; {&#10;            // Only send if user was actually typing&#10;            if (isTypingRef.current) {&#10;                console.log('⚠️ Page unloading, user was typing, sending stopped');&#10;                if (webSocketService?.stompClient?.connected) {&#10;                    webSocketService.sendTypingStatus({&#10;                        conversationId: conversation.id,&#10;                        isTyping: false&#10;                    });&#10;                }&#10;            }&#10;        };&#10;&#10;        window.addEventListener('beforeunload', handleBeforeUnload);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('beforeunload', handleBeforeUnload);&#10;        };&#10;    }, [conversation?.id]);&#10;&#10;    // Send typing indicator&#10;    const sendTypingIndicator = useCallback((isTyping) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Track typing state&#10;        isTypingRef.current = isTyping;&#10;&#10;        console.log('⌨️ sendTypingIndicator called:', {&#10;            isTyping,&#10;            conversationId: conversation.id,&#10;            wsConnected: webSocketService?.stompClient?.connected&#10;        });&#10;&#10;        webSocketService.sendTypingStatus({&#10;            conversationId: conversation.id,&#10;            isTyping&#10;        });&#10;&#10;        console.log('✅ Typing status sent to backend');&#10;    }, [conversation?.id]);&#10;&#10;    // Handle input change&#10;    const handleInputChange = useCallback((e) =&gt; {&#10;        const newValue = e.target.value;&#10;        console.log('handleInputChange: newValue:', JSON.stringify(newValue), 'trim:', newValue.trim(), 'length:', newValue.length);&#10;        setInputValue(newValue);&#10;&#10;        // Send typing indicator based on whether there's text&#10;        const shouldType = newValue.length &gt; 0;&#10;        console.log('shouldType:', shouldType);&#10;        if (shouldType) {&#10;            sendTypingIndicator(true);&#10;        } else {&#10;            sendTypingIndicator(false);&#10;        }&#10;    }, [sendTypingIndicator]);&#10;&#10;    // Send message&#10;    const handleSend = useCallback(async () =&gt; {&#10;        const messageText = inputValue.trim();&#10;        if (!messageText || isSending || !conversation?.id) return;&#10;&#10;        try {&#10;            setIsSending(true);&#10;&#10;            // Send via REST API - backend will save to DB and broadcast via WebSocket&#10;            await ChatService.sendMessage(conversation.id, {&#10;                content: messageText,&#10;                messageType: 'TEXT'&#10;            });&#10;&#10;            setInputValue('');&#10;            sendTypingIndicator(false);&#10;&#10;            // Focus back to input&#10;            setTimeout(() =&gt; inputRef.current?.focus(), 0);&#10;        } catch (error) {&#10;            console.error('Failed to send message:', error);&#10;        } finally {&#10;            setIsSending(false);&#10;        }&#10;    }, [inputValue, isSending, conversation?.id, sendTypingIndicator]);&#10;&#10;    // Handle key press&#10;    const handleKeyPress = useCallback((e) =&gt; {&#10;        if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {&#10;            e.preventDefault();&#10;            handleSend();&#10;        }&#10;    }, [handleSend]);&#10;&#10;    // Linkify text&#10;    const linkify = (text) =&gt; {&#10;        if (!text) return '';&#10;        const urlRegex = /(https?:\/\/[^\s]+)/g;&#10;        return text.replace(urlRegex, (url) =&gt; {&#10;            return `&lt;a href=&quot;${url}&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;message-link&quot;&gt;${url}&lt;/a&gt;`;&#10;        });&#10;    };&#10;&#10;    // Format message time (short version)&#10;    const formatTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        const now = new Date();&#10;        const diffInHours = (now - date) / (1000 * 60 * 60);&#10;&#10;        if (diffInHours &lt; 24) {&#10;            return date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });&#10;        } else {&#10;            return date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;        }&#10;    };&#10;&#10;    // Format detailed time for tooltip&#10;    const formatDetailedTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        return date.toLocaleString('vi-VN', {&#10;            weekday: 'long',&#10;            year: 'numeric',&#10;            month: 'long',&#10;            day: 'numeric',&#10;            hour: '2-digit',&#10;            minute: '2-digit'&#10;        });&#10;    };&#10;&#10;    // Check if should show timestamp separator between messages&#10;    const shouldShowTimestamp = (currentMsg, prevMsg) =&gt; {&#10;        if (!prevMsg) return true; // First message&#10;&#10;        const currentTime = new Date(currentMsg.createdAt || currentMsg.timestamp);&#10;        const prevTime = new Date(prevMsg.createdAt || prevMsg.timestamp);&#10;&#10;        // Show timestamp if messages are more than 5 minutes apart&#10;        const diffInMinutes = (currentTime - prevTime) / (1000 * 60);&#10;        return diffInMinutes &gt; 5;&#10;    };&#10;&#10;    return (&#10;        &lt;div&#10;            className={`chat-window ${minimized ? 'minimized' : 'open'} ${isActive ? 'active' : ''}`}&#10;            data-conversation-id={conversation?.id}&#10;            data-friend-id={conversation?.id}&#10;            onClick={onWindowClick}&#10;        &gt;&#10;            &lt;div className={`chat-window-header ${unreadCount &gt; 0 ? 'unread' : ''}`} onClick={onMinimize}&gt;&#10;                &lt;img&#10;                    src={displayInfo.avatar}&#10;                    alt=&quot;Avatar&quot;&#10;                    className=&quot;chat-window-avatar&quot;&#10;                    onClick={(e) =&gt; {&#10;                        e.stopPropagation();&#10;                        if (!conversation.isGroup) {&#10;                            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                            if (otherUser?.userId) {&#10;                                navigate(`/profile/${otherUser.userId}`);&#10;                            }&#10;                        }&#10;                    }}&#10;                /&gt;&#10;                &lt;div className=&quot;chat-window-info&quot;&gt;&#10;                    &lt;div className=&quot;chat-window-name&quot;&gt;{displayInfo.name}&lt;/div&gt;&#10;                    &lt;div className=&quot;chat-window-status&quot;&gt;{displayInfo.status}&lt;/div&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;chat-window-controls&quot;&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-minimize&quot;&#10;                        title=&quot;Thu nhỏ&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onMinimize();&#10;                        }}&#10;                    &gt;&#10;                        −&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-close&quot;&#10;                        title=&quot;Đóng&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onClose();&#10;                        }}&#10;                    &gt;&#10;                        ×&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div&#10;                className=&quot;chat-window-messages&quot;&#10;                ref={messagesContainerRef}&#10;                onScroll={handleScroll}&#10;            &gt;&#10;                {isLoading &amp;&amp; currentPage === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-loading&quot;&gt;Đang tải tin nhắn...&lt;/div&gt;&#10;                )}&#10;&#10;                {hasMore &amp;&amp; !isLoading &amp;&amp; currentPage &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;load-more-messages&quot;&gt;&#10;                        &lt;button onClick={() =&gt; loadMessages(currentPage + 1)}&gt;&#10;                            Tải thêm tin nhắn&#10;                        &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {messages.map((msg, index) =&gt; {&#10;                    const isSent = msg.senderId === currentUserId;&#10;                    const showAvatar = !isSent &amp;&amp; (index === 0 || messages[index - 1].senderId !== msg.senderId);&#10;                    const showTimestamp = shouldShowTimestamp(msg, messages[index - 1]);&#10;&#10;                    return (&#10;                        &lt;React.Fragment key={msg.id || index}&gt;&#10;                            {/* Timestamp Separator */}&#10;                            {showTimestamp &amp;&amp; (&#10;                                &lt;div className=&quot;message-timestamp-separator&quot;&gt;&#10;                                    &lt;span&gt;{formatTime(msg.createdAt || msg.timestamp)}&lt;/span&gt;&#10;                                &lt;/div&gt;&#10;                            )}&#10;&#10;                            {/* Message */}&#10;                            &lt;div&#10;                                className={`chat-window-message ${isSent ? 'sent' : 'received'}`}&#10;                                title={formatDetailedTime(msg.createdAt || msg.timestamp)}&#10;                            &gt;&#10;                                {showAvatar &amp;&amp; !isSent &amp;&amp; (&#10;                                    &lt;img&#10;                                        src={msg.senderAvatar || displayInfo.avatar}&#10;                                        alt=&quot;Avatar&quot;&#10;                                        className=&quot;chat-window-message-avatar&quot;&#10;                                    /&gt;&#10;                                )}&#10;                                {!showAvatar &amp;&amp; !isSent &amp;&amp; &lt;div className=&quot;chat-window-message-avatar-spacer&quot; /&gt;}&#10;&#10;                                &lt;div className=&quot;chat-window-message-content&quot;&gt;&#10;                                    {!isSent &amp;&amp; showAvatar &amp;&amp; (&#10;                                        &lt;div className=&quot;chat-window-message-sender&quot;&gt;{msg.senderName}&lt;/div&gt;&#10;                                    )}&#10;                                    {msg.isLocation ? (&#10;                                        &lt;div className=&quot;location-message-card&quot;&gt;&#10;                                            &lt;div className=&quot;location-card-image&quot;&gt;&#10;                                                &lt;img src={msg.content.image} alt={msg.content.name} /&gt;&#10;                                                &lt;div className=&quot;location-card-overlay&quot;&gt;&lt;/div&gt;&#10;                                            &lt;/div&gt;&#10;                                            &lt;div className=&quot;location-card-content&quot;&gt;&#10;                                                &lt;div className=&quot;location-card-title&quot;&gt;{msg.content.name}&lt;/div&gt;&#10;                                                &lt;div className=&quot;location-card-description&quot;&gt;{msg.content.description}&lt;/div&gt;&#10;                                                &lt;button&#10;                                                    className=&quot;location-card-button&quot;&#10;                                                    onClick={() =&gt; window.focusLocation?.(msg.content.coordinates[0], msg.content.coordinates[1], msg.content.name)}&#10;                                                &gt;&#10;                                                    ️ Xem trên bản đồ&#10;                                                &lt;/button&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/div&gt;&#10;                                    ) : (&#10;                                        &lt;div&#10;                                            className=&quot;chat-window-message-text&quot;&#10;                                            dangerouslySetInnerHTML={{ __html: linkify(msg.content) }}&#10;                                        /&gt;&#10;                                    )}&#10;                                    {msg.edited &amp;&amp; (&#10;                                        &lt;div className=&quot;chat-window-message-time&quot;&gt;&#10;                                            &lt;span className=&quot;edited-indicator&quot;&gt;(đã chỉnh sửa)&lt;/span&gt;&#10;                                        &lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/React.Fragment&gt;&#10;                    );&#10;                })}&#10;&#10;                {typingUsers.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-window-message received typing-indicator-message&quot;&gt;&#10;                        {console.log('rendering typing indicator, typingUsers length:', typingUsers.length, 'users:', typingUsers.map(u =&gt; u.userId))}&#10;                        &lt;img src={typingUsers[0].avatar} alt=&quot;Avatar&quot; className=&quot;chat-window-message-avatar&quot; /&gt;&#10;                        &lt;div className=&quot;typing-indicator&quot;&gt;&#10;                            &lt;div className=&quot;typing-dots&quot;&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div ref={messagesEndRef} /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className=&quot;chat-window-input-container&quot;&gt;&#10;                &lt;input&#10;                    type=&quot;text&quot;&#10;                    placeholder=&quot;Aa&quot;&#10;                    className=&quot;chat-window-input&quot;&#10;                    value={inputValue}&#10;                    onInput={handleInputChange}&#10;                    onKeyPress={handleKeyPress}&#10;                    onFocus={() =&gt; { if (inputValue.length &gt; 0) sendTypingIndicator(true); }}&#10;                    onBlur={() =&gt; sendTypingIndicator(false)}&#10;                    disabled={isSending}&#10;                    ref={inputRef}&#10;                /&gt;&#10;                &lt;button&#10;                    className=&quot;chat-window-send&quot;&#10;                    onClick={handleSend}&#10;                    disabled={!inputValue.trim() || isSending}&#10;                &gt;&#10;                    {isSending ? '...' : '→'}&#10;                &lt;/button&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useRef, useCallback } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;import './ChatWindows.css';&#10;&#10;export default function ChatWindow({&#10;    conversation,&#10;    minimized,&#10;    isActive,&#10;    currentUserId,&#10;    onClose,&#10;    onMinimize,&#10;    onNewMessage,&#10;    onMarkAsRead,&#10;    onWindowClick,&#10;    unreadCount = 0&#10;}) {&#10;    const [messages, setMessages] = useState([]);&#10;    const [inputValue, setInputValue] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [hasMore, setHasMore] = useState(true);&#10;    const [currentPage, setCurrentPage] = useState(0);&#10;    const [typingUsers, setTypingUsers] = useState([]);&#10;    const [isSending, setIsSending] = useState(false);&#10;&#10;    const messagesEndRef = useRef(null);&#10;    const messagesContainerRef = useRef(null);&#10;    const lastScrollHeightRef = useRef(0);&#10;    const isLoadingMoreRef = useRef(false);&#10;    const inputRef = useRef(null);&#10;    const navigate = useNavigate();&#10;&#10;    // Track if user is currently typing to avoid unnecessary cleanup messages&#10;    const isTypingRef = useRef(false);&#10;&#10;    // Get display info&#10;    const getDisplayInfo = useCallback(() =&gt; {&#10;        if (!conversation) return { name: '', avatar: '', status: '' };&#10;&#10;        if (conversation.isGroup) {&#10;            return {&#10;                name: conversation.groupName || 'Nhóm',&#10;                avatar: conversation.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conversation.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.isOnline ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    }, [conversation, currentUserId]);&#10;&#10;    const displayInfo = getDisplayInfo();&#10;&#10;    // Load initial messages&#10;    const loadMessages = useCallback(async (page = 0) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        try {&#10;            setIsLoading(true);&#10;            const response = await ChatService.getMessages(conversation.id, { page, size: 20 });&#10;&#10;            if (page === 0) {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    }&#10;                    return msg;&#10;                }).reverse();&#10;                setMessages(processedMessages);&#10;            } else {&#10;                const processedMessages = response.content.map(msg =&gt; {&#10;                    if (msg.content &amp;&amp; msg.content.startsWith('LOCATION:')) {&#10;                        try {&#10;                            const locationData = JSON.parse(msg.content.substring(9));&#10;                            return {&#10;                                ...msg,&#10;                                content: locationData,&#10;                                isLocation: true&#10;                            };&#10;                        } catch (e) {&#10;                            console.error('Failed to parse location message:', e);&#10;                            return msg;&#10;                        }&#10;                    } // ✅ thêm dấu đóng if&#10;                    return msg;&#10;                }).reverse();&#10;&#10;                setMessages(prev =&gt; [...processedMessages, ...prev]);&#10;            }&#10;&#10;            setHasMore(!response.last);&#10;            setCurrentPage(page);&#10;        } catch (error) {&#10;            console.error('Failed to load messages:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;            isLoadingMoreRef.current = false;&#10;        }&#10;    }, [conversation?.id]);&#10;&#10;    // Load more messages on scroll&#10;    const handleScroll = useCallback(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (!container || isLoadingMoreRef.current || !hasMore) return;&#10;&#10;        if (container.scrollTop === 0) {&#10;            isLoadingMoreRef.current = true;&#10;            lastScrollHeightRef.current = container.scrollHeight;&#10;            loadMessages(currentPage + 1);&#10;        }&#10;    }, [currentPage, hasMore, loadMessages]);&#10;&#10;    // Maintain scroll position after loading more&#10;    useEffect(() =&gt; {&#10;        const container = messagesContainerRef.current;&#10;        if (container &amp;&amp; lastScrollHeightRef.current &gt; 0) {&#10;            const newScrollHeight = container.scrollHeight;&#10;            container.scrollTop = newScrollHeight - lastScrollHeightRef.current;&#10;            lastScrollHeightRef.current = 0;&#10;        }&#10;    }, [messages]);&#10;&#10;    // Scroll to bottom for new messages&#10;    const scrollToBottom = useCallback((smooth = false) =&gt; {&#10;        if (messagesContainerRef.current) {&#10;            messagesContainerRef.current.scrollTo({&#10;                top: messagesContainerRef.current.scrollHeight,&#10;                behavior: smooth ? 'smooth' : 'auto'&#10;            });&#10;        }&#10;    }, []);&#10;&#10;    // Load messages on conversation change&#10;    useEffect(() =&gt; {&#10;        if (conversation?.id) {&#10;            setMessages([]);&#10;            setCurrentPage(0);&#10;            setHasMore(true);&#10;            loadMessages(0);&#10;        }&#10;    }, [conversation?.id, loadMessages]);&#10;&#10;    // Track previous isActive state to detect actual changes&#10;    // ✅ IMPORTANT: Start with false so first active=true will be detected as transition&#10;    const prevIsActiveRef = useRef(false);&#10;&#10;    // Mark as read ONLY when isActive changes to true (not just when window opens)&#10;    useEffect(() =&gt; {&#10;        const wasActive = prevIsActiveRef.current;&#10;        const isNowActive = isActive;&#10;&#10;        console.log(' Mark as read check:', {&#10;            conversationId: conversation?.id,&#10;            minimized,&#10;            wasActive,&#10;            isNowActive,&#10;            isActiveChanged: wasActive !== isNowActive,&#10;            shouldMark: conversation?.id &amp;&amp; !minimized &amp;&amp; isNowActive &amp;&amp; !wasActive&#10;        });&#10;&#10;        // Only mark as read when:&#10;        // 1. Window becomes active (wasActive = false → isNowActive = true)&#10;        // 2. AND window is not minimized&#10;        if (conversation?.id &amp;&amp; !minimized &amp;&amp; isNowActive &amp;&amp; !wasActive) {&#10;            console.log('✅ Marking as read (window became active):', conversation.id);&#10;            ChatService.markAsRead(conversation.id).catch(console.error);&#10;            if (onMarkAsRead) {&#10;                onMarkAsRead(conversation.id);&#10;            }&#10;        } else {&#10;            console.log('⏭️ Skipping mark as read:', {&#10;                hasId: !!conversation?.id,&#10;                minimized,&#10;                wasActive,&#10;                isNowActive,&#10;                reason: !isNowActive ? 'not active' : wasActive ? 'already was active' : 'minimized'&#10;            });&#10;        }&#10;&#10;        // Update previous state&#10;        prevIsActiveRef.current = isNowActive;&#10;    }, [conversation?.id, minimized, isActive, onMarkAsRead]);&#10;&#10;    // Subscribe to WebSocket updates&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Create callbacks with stable references for cleanup&#10;        const messageCallback = (message) =&gt; {&#10;            console.log(' ChatWindow received new message:', message);&#10;            // New message&#10;            let processedMessage = message;&#10;&#10;            // Handle location messages&#10;            if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                try {&#10;                    const locationData = JSON.parse(message.content.substring(9));&#10;                    processedMessage = {&#10;                        ...message,&#10;                        content: locationData,&#10;                        isLocation: true&#10;                    };&#10;                } catch (e) {&#10;                    console.error('Failed to parse location message:', e);&#10;                }&#10;            }&#10;&#10;            setMessages(prev =&gt; [...prev, processedMessage]);&#10;            scrollToBottom(true);&#10;&#10;            // Notify parent&#10;            if (onNewMessage) {&#10;                onNewMessage(processedMessage);&#10;            }&#10;&#10;            // Auto mark as read if window is ACTIVE, not minimized, and message is from others&#10;            console.log(' Auto mark check:', {&#10;                conversationId: conversation.id,&#10;                isActive,&#10;                minimized,&#10;                isFromOthers: message.senderId !== currentUserId,&#10;                senderId: message.senderId,&#10;                currentUserId,&#10;                shouldAutoMark: isActive &amp;&amp; !minimized &amp;&amp; message.senderId !== currentUserId&#10;            });&#10;&#10;            if (isActive &amp;&amp; !minimized &amp;&amp; message.senderId !== currentUserId) {&#10;                console.log('✅ Auto-marking as read (window ACTIVE, not minimized, message from others)');&#10;                console.log('⚠️ VERIFY: Is this window actually active? Check visual state!');&#10;                // Send via WebSocket for real-time&#10;                webSocketService.sendMarkAsRead({ conversationId: conversation.id });&#10;                // Also call REST API as backup&#10;                ChatService.markAsRead(conversation.id).catch(console.error);&#10;                // Update parent state&#10;                if (onMarkAsRead) {&#10;                    onMarkAsRead(conversation.id);&#10;                }&#10;            } else {&#10;                console.log('⏭️ Skipping auto mark as read - window not active or message from self');&#10;            }&#10;        };&#10;&#10;        const typingCallback = (typingDTO) =&gt; {&#10;            // Typing indicator&#10;            console.log(' ChatWindow received typing from WebSocket:', typingDTO, 'currentUserId:', currentUserId);&#10;&#10;            // Handle both 'typing' and 'isTyping' field names from backend&#10;            const isTyping = typingDTO.typing ?? typingDTO.isTyping ?? false;&#10;&#10;            if (typingDTO.userId !== currentUserId) {&#10;                if (isTyping) {&#10;                    // User started typing&#10;                    const user = conversation.isGroup&#10;                        ? conversation.members?.find(m =&gt; m.userId === typingDTO.userId)&#10;                        : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                    const avatar = user?.avatarUrl || '/channels/myprofile.jpg';&#10;                    const name = user?.fullName || typingDTO.username || 'User';&#10;&#10;                    setTypingUsers(prev =&gt; {&#10;                        const alreadyTyping = prev.some(u =&gt; u.userId === typingDTO.userId);&#10;                        if (alreadyTyping) {&#10;                            console.log(`⏭️ User ${typingDTO.userId} already in typingUsers, skipping`);&#10;                            return prev;&#10;                        }&#10;                        const newUsers = [...prev, { userId: typingDTO.userId, avatar, name }];&#10;                        console.log(`✍️ Added user ${typingDTO.userId} (${name}) to typingUsers:`, newUsers);&#10;                        return newUsers;&#10;                    });&#10;                } else {&#10;                    // User stopped typing&#10;                    setTypingUsers(prev =&gt; {&#10;                        const newUsers = prev.filter(u =&gt; u.userId !== typingDTO.userId);&#10;                        console.log(`⏹️ Removed user ${typingDTO.userId} from typingUsers. Before:`, prev.length, 'After:', newUsers.length);&#10;                        return newUsers;&#10;                    });&#10;                }&#10;&#10;                // Dispatch event to update SideChat (if needed)&#10;                console.log(' ChatWindow dispatching typingStatus event');&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conversation.id, isTyping: isTyping, userId: typingDTO.userId }&#10;                }));&#10;            } else {&#10;                console.log('⏭️ Skipping typing from self (currentUser)');&#10;            }&#10;        };&#10;&#10;        const updateCallback = (updatedMessage) =&gt; {&#10;            // Message edited/deleted&#10;            setMessages(prev =&gt; prev.map(msg =&gt;&#10;                msg.id === updatedMessage.id ? updatedMessage : msg&#10;            ));&#10;        };&#10;&#10;        // Subscribe with callback references&#10;        console.log(' ChatWindow subscribing to conversation:', conversation.id);&#10;        webSocketService.subscribeToConversation(&#10;            conversation.id,&#10;            messageCallback,&#10;            typingCallback,&#10;            updateCallback&#10;        );&#10;&#10;        // ✅ IMPORTANT: Fetch current typing users after subscribing&#10;        // This ensures we see typing status from users who started typing BEFORE we subscribed&#10;        const fetchTypingUsers = async () =&gt; {&#10;            try {&#10;                const typingUserIds = await ChatService.getTypingUsers(conversation.id);&#10;                console.log(' Fetched current typing users:', typingUserIds);&#10;                &#10;                if (typingUserIds &amp;&amp; typingUserIds.length &gt; 0) {&#10;                    // Filter out current user and map to typing user objects&#10;                    const typingUsersData = typingUserIds&#10;                        .filter(userId =&gt; userId !== currentUserId)&#10;                        .map(userId =&gt; {&#10;                            const user = conversation.isGroup&#10;                                ? conversation.members?.find(m =&gt; m.userId === userId)&#10;                                : conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                            return {&#10;                                userId: userId,&#10;                                avatar: user?.avatarUrl || '/channels/myprofile.jpg',&#10;                                name: user?.fullName || 'User'&#10;                            };&#10;                        });&#10;                    &#10;                    if (typingUsersData.length &gt; 0) {&#10;                        console.log('✍️ Setting initial typing users:', typingUsersData);&#10;                        setTypingUsers(typingUsersData);&#10;                    }&#10;                }&#10;            } catch (error) {&#10;                console.error('Failed to fetch typing users:', error);&#10;            }&#10;        };&#10;        &#10;        fetchTypingUsers();&#10;&#10;        return () =&gt; {&#10;            // Cleanup: Send typing stopped ONLY if user was typing&#10;            if (isTypingRef.current) {&#10;                console.log(' ChatWindow cleanup: user was typing, sending stopped');&#10;                webSocketService.sendTypingStatus({&#10;                    conversationId: conversation.id,&#10;                    isTyping: false&#10;                });&#10;                isTypingRef.current = false;&#10;            }&#10;&#10;            // Unsubscribe ONLY ChatWindow's callbacks (not SideChat's!)&#10;            console.log(' ChatWindow cleanup: unsubscribing callbacks for', conversation.id);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}`, messageCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/typing`, typingCallback);&#10;            webSocketService.unsubscribe(`/topic/conversation/${conversation.id}/update`, updateCallback);&#10;        };&#10;    }, [conversation?.id, currentUserId, isActive, minimized, onMarkAsRead]); // ✅ FIXED: Add deps to prevent stale closure&#10;&#10;    // Handle page reload/close - cleanup typing indicator&#10;    useEffect(() =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        const handleBeforeUnload = () =&gt; {&#10;            // Only send if user was actually typing&#10;            if (isTypingRef.current) {&#10;                console.log('⚠️ Page unloading, user was typing, sending stopped');&#10;                if (webSocketService?.stompClient?.connected) {&#10;                    webSocketService.sendTypingStatus({&#10;                        conversationId: conversation.id,&#10;                        isTyping: false&#10;                    });&#10;                }&#10;            }&#10;        };&#10;&#10;        window.addEventListener('beforeunload', handleBeforeUnload);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('beforeunload', handleBeforeUnload);&#10;        };&#10;    }, [conversation?.id]);&#10;&#10;    // Send typing indicator&#10;    const sendTypingIndicator = useCallback((isTyping) =&gt; {&#10;        if (!conversation?.id) return;&#10;&#10;        // Track typing state&#10;        isTypingRef.current = isTyping;&#10;&#10;        console.log('⌨️ sendTypingIndicator called:', {&#10;            isTyping,&#10;            conversationId: conversation.id,&#10;            wsConnected: webSocketService?.stompClient?.connected&#10;        });&#10;&#10;        webSocketService.sendTypingStatus({&#10;            conversationId: conversation.id,&#10;            isTyping&#10;        });&#10;&#10;        console.log('✅ Typing status sent to backend');&#10;    }, [conversation?.id]);&#10;&#10;    // Handle input change&#10;    const handleInputChange = useCallback((e) =&gt; {&#10;        const newValue = e.target.value;&#10;        console.log('handleInputChange: newValue:', JSON.stringify(newValue), 'trim:', newValue.trim(), 'length:', newValue.length);&#10;        setInputValue(newValue);&#10;&#10;        // Send typing indicator based on whether there's text&#10;        const shouldType = newValue.length &gt; 0;&#10;        console.log('shouldType:', shouldType);&#10;        if (shouldType) {&#10;            sendTypingIndicator(true);&#10;        } else {&#10;            sendTypingIndicator(false);&#10;        }&#10;    }, [sendTypingIndicator]);&#10;&#10;    // Send message&#10;    const handleSend = useCallback(async () =&gt; {&#10;        const messageText = inputValue.trim();&#10;        if (!messageText || isSending || !conversation?.id) return;&#10;&#10;        try {&#10;            setIsSending(true);&#10;&#10;            // Send via REST API - backend will save to DB and broadcast via WebSocket&#10;            await ChatService.sendMessage(conversation.id, {&#10;                content: messageText,&#10;                messageType: 'TEXT'&#10;            });&#10;&#10;            setInputValue('');&#10;            sendTypingIndicator(false);&#10;&#10;            // Focus back to input&#10;            setTimeout(() =&gt; inputRef.current?.focus(), 0);&#10;        } catch (error) {&#10;            console.error('Failed to send message:', error);&#10;        } finally {&#10;            setIsSending(false);&#10;        }&#10;    }, [inputValue, isSending, conversation?.id, sendTypingIndicator]);&#10;&#10;    // Handle key press&#10;    const handleKeyPress = useCallback((e) =&gt; {&#10;        if (e.key === 'Enter' &amp;&amp; !e.shiftKey) {&#10;            e.preventDefault();&#10;            handleSend();&#10;        }&#10;    }, [handleSend]);&#10;&#10;    // Linkify text&#10;    const linkify = (text) =&gt; {&#10;        if (!text) return '';&#10;        const urlRegex = /(https?:\/\/[^\s]+)/g;&#10;        return text.replace(urlRegex, (url) =&gt; {&#10;            return `&lt;a href=&quot;${url}&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; class=&quot;message-link&quot;&gt;${url}&lt;/a&gt;`;&#10;        });&#10;    };&#10;&#10;    // Format message time (short version)&#10;    const formatTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        const now = new Date();&#10;        const diffInHours = (now - date) / (1000 * 60 * 60);&#10;&#10;        if (diffInHours &lt; 24) {&#10;            return date.toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });&#10;        } else {&#10;            return date.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;        }&#10;    };&#10;&#10;    // Format detailed time for tooltip&#10;    const formatDetailedTime = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;        const date = new Date(timestamp);&#10;        return date.toLocaleString('vi-VN', {&#10;            weekday: 'long',&#10;            year: 'numeric',&#10;            month: 'long',&#10;            day: 'numeric',&#10;            hour: '2-digit',&#10;            minute: '2-digit'&#10;        });&#10;    };&#10;&#10;    // Check if should show timestamp separator between messages&#10;    const shouldShowTimestamp = (currentMsg, prevMsg) =&gt; {&#10;        if (!prevMsg) return true; // First message&#10;&#10;        const currentTime = new Date(currentMsg.createdAt || currentMsg.timestamp);&#10;        const prevTime = new Date(prevMsg.createdAt || prevMsg.timestamp);&#10;&#10;        // Show timestamp if messages are more than 5 minutes apart&#10;        const diffInMinutes = (currentTime - prevTime) / (1000 * 60);&#10;        return diffInMinutes &gt; 5;&#10;    };&#10;&#10;    return (&#10;        &lt;div&#10;            className={`chat-window ${minimized ? 'minimized' : 'open'} ${isActive ? 'active' : ''}`}&#10;            data-conversation-id={conversation?.id}&#10;            data-friend-id={conversation?.id}&#10;            onClick={onWindowClick}&#10;        &gt;&#10;            &lt;div className={`chat-window-header ${unreadCount &gt; 0 ? 'unread' : ''}`} onClick={onMinimize}&gt;&#10;                &lt;img&#10;                    src={displayInfo.avatar}&#10;                    alt=&quot;Avatar&quot;&#10;                    className=&quot;chat-window-avatar&quot;&#10;                    onClick={(e) =&gt; {&#10;                        e.stopPropagation();&#10;                        if (!conversation.isGroup) {&#10;                            const otherUser = conversation.otherUser || conversation.members?.find(m =&gt; m.userId !== currentUserId);&#10;                            if (otherUser?.userId) {&#10;                                navigate(`/profile/${otherUser.userId}`);&#10;                            }&#10;                        }&#10;                    }}&#10;                /&gt;&#10;                &lt;div className=&quot;chat-window-info&quot;&gt;&#10;                    &lt;div className=&quot;chat-window-name&quot;&gt;{displayInfo.name}&lt;/div&gt;&#10;                    &lt;div className=&quot;chat-window-status&quot;&gt;{displayInfo.status}&lt;/div&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;chat-window-controls&quot;&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-minimize&quot;&#10;                        title=&quot;Thu nhỏ&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onMinimize();&#10;                        }}&#10;                    &gt;&#10;                        −&#10;                    &lt;/button&gt;&#10;                    &lt;button&#10;                        className=&quot;chat-window-close&quot;&#10;                        title=&quot;Đóng&quot;&#10;                        onClick={(e) =&gt; {&#10;                            e.stopPropagation();&#10;                            onClose();&#10;                        }}&#10;                    &gt;&#10;                        ×&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div&#10;                className=&quot;chat-window-messages&quot;&#10;                ref={messagesContainerRef}&#10;                onScroll={handleScroll}&#10;            &gt;&#10;                {isLoading &amp;&amp; currentPage === 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-loading&quot;&gt;Đang tải tin nhắn...&lt;/div&gt;&#10;                )}&#10;&#10;                {hasMore &amp;&amp; !isLoading &amp;&amp; currentPage &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;load-more-messages&quot;&gt;&#10;                        &lt;button onClick={() =&gt; loadMessages(currentPage + 1)}&gt;&#10;                            Tải thêm tin nhắn&#10;                        &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {messages.map((msg, index) =&gt; {&#10;                    const isSent = msg.senderId === currentUserId;&#10;                    const showAvatar = !isSent &amp;&amp; (index === 0 || messages[index - 1].senderId !== msg.senderId);&#10;                    const showTimestamp = shouldShowTimestamp(msg, messages[index - 1]);&#10;&#10;                    return (&#10;                        &lt;React.Fragment key={msg.id || index}&gt;&#10;                            {/* Timestamp Separator */}&#10;                            {showTimestamp &amp;&amp; (&#10;                                &lt;div className=&quot;message-timestamp-separator&quot;&gt;&#10;                                    &lt;span&gt;{formatTime(msg.createdAt || msg.timestamp)}&lt;/span&gt;&#10;                                &lt;/div&gt;&#10;                            )}&#10;&#10;                            {/* Message */}&#10;                            &lt;div&#10;                                className={`chat-window-message ${isSent ? 'sent' : 'received'}`}&#10;                                title={formatDetailedTime(msg.createdAt || msg.timestamp)}&#10;                            &gt;&#10;                                {showAvatar &amp;&amp; !isSent &amp;&amp; (&#10;                                    &lt;img&#10;                                        src={msg.senderAvatar || displayInfo.avatar}&#10;                                        alt=&quot;Avatar&quot;&#10;                                        className=&quot;chat-window-message-avatar&quot;&#10;                                    /&gt;&#10;                                )}&#10;                                {!showAvatar &amp;&amp; !isSent &amp;&amp; &lt;div className=&quot;chat-window-message-avatar-spacer&quot; /&gt;}&#10;&#10;                                &lt;div className=&quot;chat-window-message-content&quot;&gt;&#10;                                    {!isSent &amp;&amp; showAvatar &amp;&amp; (&#10;                                        &lt;div className=&quot;chat-window-message-sender&quot;&gt;{msg.senderName}&lt;/div&gt;&#10;                                    )}&#10;                                    {msg.isLocation ? (&#10;                                        &lt;div className=&quot;location-message-card&quot;&gt;&#10;                                            &lt;div className=&quot;location-card-image&quot;&gt;&#10;                                                &lt;img src={msg.content.image} alt={msg.content.name} /&gt;&#10;                                                &lt;div className=&quot;location-card-overlay&quot;&gt;&lt;/div&gt;&#10;                                            &lt;/div&gt;&#10;                                            &lt;div className=&quot;location-card-content&quot;&gt;&#10;                                                &lt;div className=&quot;location-card-title&quot;&gt;{msg.content.name}&lt;/div&gt;&#10;                                                &lt;div className=&quot;location-card-description&quot;&gt;{msg.content.description}&lt;/div&gt;&#10;                                                &lt;button&#10;                                                    className=&quot;location-card-button&quot;&#10;                                                    onClick={() =&gt; window.focusLocation?.(msg.content.coordinates[0], msg.content.coordinates[1], msg.content.name)}&#10;                                                &gt;&#10;                                                    ️ Xem trên bản đồ&#10;                                                &lt;/button&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/div&gt;&#10;                                    ) : (&#10;                                        &lt;div&#10;                                            className=&quot;chat-window-message-text&quot;&#10;                                            dangerouslySetInnerHTML={{ __html: linkify(msg.content) }}&#10;                                        /&gt;&#10;                                    )}&#10;                                    {msg.edited &amp;&amp; (&#10;                                        &lt;div className=&quot;chat-window-message-time&quot;&gt;&#10;                                            &lt;span className=&quot;edited-indicator&quot;&gt;(đã chỉnh sửa)&lt;/span&gt;&#10;                                        &lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/React.Fragment&gt;&#10;                    );&#10;                })}&#10;&#10;                {typingUsers.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;chat-window-message received typing-indicator-message&quot;&gt;&#10;                        {console.log('rendering typing indicator, typingUsers length:', typingUsers.length, 'users:', typingUsers.map(u =&gt; u.userId))}&#10;                        &lt;img src={typingUsers[0].avatar} alt=&quot;Avatar&quot; className=&quot;chat-window-message-avatar&quot; /&gt;&#10;                        &lt;div className=&quot;typing-indicator&quot;&gt;&#10;                            &lt;div className=&quot;typing-dots&quot;&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                                &lt;div className=&quot;typing-dot&quot;&gt;&lt;/div&gt;&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div ref={messagesEndRef} /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;div className=&quot;chat-window-input-container&quot;&gt;&#10;                &lt;input&#10;                    type=&quot;text&quot;&#10;                    placeholder=&quot;Aa&quot;&#10;                    className=&quot;chat-window-input&quot;&#10;                    value={inputValue}&#10;                    onInput={handleInputChange}&#10;                    onKeyPress={handleKeyPress}&#10;                    onFocus={() =&gt; { if (inputValue.length &gt; 0) sendTypingIndicator(true); }}&#10;                    onBlur={() =&gt; sendTypingIndicator(false)}&#10;                    disabled={isSending}&#10;                    ref={inputRef}&#10;                /&gt;&#10;                &lt;button&#10;                    className=&quot;chat-window-send&quot;&#10;                    onClick={handleSend}&#10;                    disabled={!inputValue.trim() || isSending}&#10;                &gt;&#10;                    {isSending ? '...' : '→'}&#10;                &lt;/button&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map-fe/src/components/Chat/SideChat.jsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map-fe/src/components/Chat/SideChat.jsx" />
              <option name="originalContent" value="import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';&#10;import './Chat.css';&#10;import './ChatWindows.css';&#10;import './LocationMessage.css';&#10;import ChatWindow from './ChatWindow';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;&#10;export default function SideChat() {&#10;    const [isChatOpen, setIsChatOpen] = useState(false);&#10;    const [activeFriend, setActiveFriend] = useState(null);&#10;    const [openChatWindows, setOpenChatWindows] = useState(new Map());&#10;    const [activeChatWindow, setActiveChatWindow] = useState(null); // Track active window (Facebook-style)&#10;    const [conversations, setConversations] = useState([]);&#10;    const [searchQuery, setSearchQuery] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isConnected, setIsConnected] = useState(false);&#10;    const [currentUserId, setCurrentUserId] = useState(null);&#10;    const wsConnectedRef = useRef(false);&#10;    const conversationIdsRef = useRef(new Set()); // Track conversation IDs to detect new conversations&#10;    const activeChatWindowRef = useRef(null); // Track active window with ref for immediate access&#10;&#10;    // Load conversations from backend&#10;    const loadConversations = useCallback(async () =&gt; {&#10;        try {&#10;            setIsLoading(true);&#10;            const data = await ChatService.getUserConversations();&#10;            // Parse location messages in lastMessage&#10;            const processedData = data.map(conv =&gt; {&#10;                if (conv.lastMessageContent?.startsWith('LOCATION:')) {&#10;                    return {&#10;                        ...conv,&#10;                        lastMessageContent: 'Vị trí'&#10;                    };&#10;                }&#10;                return conv;&#10;            }).map(conv =&gt; ({ ...conv, typingUsers: [] })); // Add typingUsers array&#10;            setConversations(processedData);&#10;        } catch (error) {&#10;            console.error('Failed to load conversations:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, []);&#10;&#10;    // Connect to WebSocket&#10;    useEffect(() =&gt; {&#10;        const conversationIdsRefCurrent = conversationIdsRef.current; // Copy ref for cleanup&#10;&#10;        if (!wsConnectedRef.current) {&#10;            webSocketService.connect(&#10;                () =&gt; {&#10;                    console.log('✅ WebSocket connected');&#10;                    setIsConnected(true);&#10;                    wsConnectedRef.current = true;&#10;&#10;                    // Lấy userId từ WebSocket service (đã được fetch từ backend)&#10;                    const userId = webSocketService.getCurrentUserId();&#10;                    setCurrentUserId(userId);&#10;&#10;                    // Subscribe to user queue for unread counts&#10;                    webSocketService.subscribeToUserQueue(&#10;                        (unreadDTO) =&gt; {&#10;                            console.log(' Received unread count update:', unreadDTO);&#10;                            // Update unread count for conversation&#10;                            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                                if (conv.id === unreadDTO.conversationId) {&#10;                                    console.log(` Updating unread count for conv ${conv.id}: ${conv.unreadCount} → ${unreadDTO.count}`);&#10;                                    return { ...conv, unreadCount: unreadDTO.count };&#10;                                }&#10;                                return conv;&#10;                            }));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('WebSocket error:', error);&#10;                        }&#10;                    );&#10;&#10;                    // Subscribe to conversation updates&#10;                    webSocketService.subscribeToConversationUpdates(&#10;                        (updateDTO) =&gt; {&#10;                            console.log(' Received conversation update:', updateDTO);&#10;                            // Update conversation with new last message and unread count&#10;                            let lastMessageContent = updateDTO.lastMessageContent;&#10;                            if (updateDTO.lastMessageContent?.startsWith('LOCATION:')) {&#10;                                lastMessageContent = 'Vị trí';&#10;                            }&#10;&#10;                            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                                if (conv.id === updateDTO.conversationId) {&#10;                                    console.log(` Updating conversation ${conv.id} with unread count: ${updateDTO.unreadCount}`);&#10;                                    return {&#10;                                        ...conv,&#10;                                        lastMessageContent: lastMessageContent,&#10;                                        lastMessageSenderId: updateDTO.lastMessageSenderId,&#10;                                        lastMessageAt: updateDTO.lastMessageAt,&#10;                                        unreadCount: updateDTO.unreadCount&#10;                                    };&#10;                                }&#10;                                return conv;&#10;                            }));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('Conversation update error:', error);&#10;                        }&#10;                    );&#10;                },&#10;                (error) =&gt; {&#10;                    console.error('WebSocket connection failed:', error);&#10;                    setIsConnected(false);&#10;                    wsConnectedRef.current = false;&#10;                }&#10;            );&#10;        }&#10;&#10;        return () =&gt; {&#10;            if (wsConnectedRef.current) {&#10;                webSocketService.disconnect();&#10;                wsConnectedRef.current = false;&#10;                // Clear subscription tracking to force re-subscribe on next connect&#10;                conversationIdsRefCurrent.clear();&#10;                console.log(' WebSocket disconnected, cleared subscription tracking');&#10;            }&#10;        };&#10;    }, []);&#10;&#10;    // Load conversations on mount - CRITICAL: Load BEFORE subscribing&#10;    useEffect(() =&gt; {&#10;        console.log(' Loading conversations on mount');&#10;        loadConversations();&#10;    }, [loadConversations]);&#10;&#10;    // ✅ Reload conversations when SideChat opens to get latest data&#10;    useEffect(() =&gt; {&#10;        if (isChatOpen) {&#10;            console.log(' SideChat opened - reloading conversations to get latest messages');&#10;            loadConversations();&#10;        }&#10;    }, [isChatOpen, loadConversations]);&#10;&#10;    // Subscribe to all conversations for both messages and typing&#10;    // Only re-run when isConnected changes, NOT when conversations state updates&#10;    useEffect(() =&gt; {&#10;        if (!isConnected) return;&#10;&#10;        console.log(' Subscribe effect running (on connection change):', {&#10;            isConnected,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        // This effect should NOT re-run when conversations state changes&#10;        // We'll use a separate effect to handle new conversations&#10;&#10;        // Cleanup when component unmounts or connection changes&#10;        return () =&gt; {&#10;            console.log(' Cleaning up all subscriptions due to unmount/disconnect');&#10;            // Clear all tracked IDs to force re-subscribe on reconnect&#10;            conversationIdsRef.current.clear();&#10;        };&#10;    }, [isConnected]);&#10;&#10;    // Separate effect to subscribe to NEW conversations when they appear&#10;    useEffect(() =&gt; {&#10;        console.log(' Effect 2 triggered:', {&#10;            isConnected,&#10;            conversationsLength: conversations.length,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        if (!isConnected) {&#10;            console.log('⏸️ Waiting for connection...');&#10;            return;&#10;        }&#10;&#10;        if (conversations.length === 0) {&#10;            console.log('⏸️ No conversations yet, waiting...');&#10;            return;&#10;        }&#10;&#10;        console.log('✅ Ready to subscribe! Processing conversations...');&#10;&#10;        let subscribedCount = 0;&#10;        let skippedCount = 0;&#10;&#10;        conversations.forEach(conv =&gt; {&#10;            // Only subscribe to NEW conversations (not already in ref)&#10;            if (conversationIdsRef.current.has(conv.id)) {&#10;                // Already subscribed, do nothing&#10;                console.log(`⏭️ Skipping ${conv.id} (already subscribed)`);&#10;                skippedCount++;&#10;                return;&#10;            }&#10;&#10;            console.log(` New conversation detected: ${conv.id}, will subscribe`);&#10;&#10;            // Create message callback with closure over conv.id&#10;            const messageCallback = (message) =&gt; {&#10;                console.log(' SideChat received new message for conv', conv.id, ':', message);&#10;&#10;                // Process location messages&#10;                let lastMessageContent = message.content;&#10;                if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                    lastMessageContent = 'Vị trí';&#10;                } else if (message.isLocation) {&#10;                    lastMessageContent = 'Vị trí';&#10;                }&#10;&#10;                // Update conversation's last message&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        console.log(`✏️ Updating last message for conv ${conv.id}:`, lastMessageContent);&#10;&#10;                        // Increment unread count if message is from someone else&#10;                        const isFromOthers = message.senderId !== currentUserId;&#10;                        const newUnreadCount = isFromOthers ? (c.unreadCount || 0) + 1 : c.unreadCount;&#10;&#10;                        if (isFromOthers) {&#10;                            console.log(` Incrementing unread count for conv ${conv.id}: ${c.unreadCount} → ${newUnreadCount}`);&#10;                        }&#10;&#10;                        return {&#10;                            ...c,&#10;                            lastMessageContent: lastMessageContent,&#10;                            lastMessageSenderId: message.senderId,&#10;                            lastMessageAt: message.createdAt || message.timestamp || new Date().toISOString(),&#10;                            unreadCount: newUnreadCount&#10;                        };&#10;                    }&#10;                    return c;&#10;                }));&#10;            };&#10;&#10;            // Create typing callback&#10;            const typingCallback = (typingDTO) =&gt; {&#10;                console.log(' SideChat received typing from WebSocket:', typingDTO);&#10;&#10;                // Handle both 'typing' and 'isTyping' field names from backend&#10;                const isTyping = typingDTO.typing ?? typingDTO.isTyping ?? false;&#10;&#10;                // Update typingUsers directly for THIS conversation&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        let newTypingUsers = [...(c.typingUsers || [])];&#10;                        let hasChanged = false;&#10;&#10;                        if (isTyping) {&#10;                            // User started typing&#10;                            if (!newTypingUsers.includes(typingDTO.userId)) {&#10;                                newTypingUsers.push(typingDTO.userId);&#10;                                hasChanged = true;&#10;                                console.log(`✍️ User ${typingDTO.userId} started typing in conv ${conv.id}`);&#10;                            }&#10;                        } else {&#10;                            // User stopped typing&#10;                            const beforeLength = newTypingUsers.length;&#10;                            newTypingUsers = newTypingUsers.filter(id =&gt; id !== typingDTO.userId);&#10;                            hasChanged = beforeLength !== newTypingUsers.length;&#10;                            if (hasChanged) {&#10;                                console.log(`⏹️ User ${typingDTO.userId} stopped typing in conv ${conv.id}`);&#10;                            }&#10;                        }&#10;&#10;                        // Only update if actually changed to prevent unnecessary re-renders&#10;                        if (hasChanged) {&#10;                            console.log(` Updated typingUsers for conv ${conv.id}:`, newTypingUsers);&#10;                            return { ...c, typingUsers: newTypingUsers };&#10;                        }&#10;                        return c; // No change, return same reference&#10;                    }&#10;                    return c;&#10;                }));&#10;&#10;                // Also dispatch event for ChatWindow to handle&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conv.id, isTyping: isTyping, userId: typingDTO.userId }&#10;                }));&#10;            };&#10;&#10;            // Subscribe to messages AND typing for this conversation&#10;            webSocketService.subscribeToConversation(&#10;                conv.id,&#10;                messageCallback,&#10;                typingCallback,&#10;                null&#10;            );&#10;&#10;            // Mark as subscribed (IMPORTANT: callbacks will persist via WebSocketService)&#10;            conversationIdsRef.current.add(conv.id);&#10;            subscribedCount++;&#10;&#10;            console.log(` SideChat subscribed to conversation ${conv.id}`);&#10;        });&#10;&#10;        console.log(` Subscribe summary: ${subscribedCount} new, ${skippedCount} skipped, ${conversationIdsRef.current.size} total tracked`);&#10;&#10;        // NO cleanup function here - subscriptions persist across state updates&#10;        // Cleanup only happens in the isConnected effect above&#10;    }, [conversations, isConnected]);&#10;&#10;    // Listen for openChatWindow event from Profile Page&#10;    useEffect(() =&gt; {&#10;        const handleOpenChatWindow = (event) =&gt; {&#10;            const { conversation, minimized } = event.detail;&#10;&#10;            if (!conversation) return;&#10;&#10;            // Add to conversations list if not exists&#10;            setConversations(prev =&gt; {&#10;                const exists = prev.find(c =&gt; c.id === conversation.id);&#10;                if (!exists) {&#10;                    return [conversation, ...prev];&#10;                }&#10;                return prev;&#10;            });&#10;&#10;            // Open chat window&#10;            setOpenChatWindows(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                newMap.set(conversation.id, { ...conversation, minimized: minimized || false });&#10;                return newMap;&#10;            });&#10;&#10;            setActiveFriend(conversation.id);&#10;        };&#10;&#10;        window.addEventListener('openChatWindow', handleOpenChatWindow);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('openChatWindow', handleOpenChatWindow);&#10;        };&#10;    }, []);&#10;&#10;    // Listen for typing status updates from ChatWindow&#10;    useEffect(() =&gt; {&#10;        const handleTypingStatus = (event) =&gt; {&#10;            const { conversationId, isTyping, userId } = event.detail;&#10;            console.log('SideChat handling typingStatus:', { conversationId, isTyping, userId });&#10;            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                if (conv.id === conversationId) {&#10;                    let newTypingUsers = [...conv.typingUsers];&#10;                    if (isTyping) {&#10;                        if (!newTypingUsers.includes(userId)) {&#10;                            newTypingUsers.push(userId);&#10;                        }&#10;                    } else {&#10;                        newTypingUsers = newTypingUsers.filter(id =&gt; id !== userId);&#10;                    }&#10;                    console.log('Updated typingUsers for conv', conv.id, ':', newTypingUsers);&#10;                    return { ...conv, typingUsers: newTypingUsers };&#10;                }&#10;                return conv;&#10;            }));&#10;        };&#10;&#10;        window.addEventListener('typingStatus', handleTypingStatus);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('typingStatus', handleTypingStatus);&#10;        };&#10;    }, []);&#10;&#10;    const handleChatToggle = useCallback(() =&gt; {&#10;        setIsChatOpen(prev =&gt; !prev);&#10;    }, []);&#10;&#10;    const handleCloseChatPopup = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleOverlayClick = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleFriendClick = useCallback(async (conversation) =&gt; {&#10;        setActiveFriend(conversation.id);&#10;        setIsChatOpen(false);&#10;&#10;        // Set as active chat window (Facebook-style) - both state and ref&#10;        console.log(' Setting active chat window (handleFriendClick):', conversation.id);&#10;        setActiveChatWindow(conversation.id);&#10;        activeChatWindowRef.current = conversation.id; // Immediate update via ref&#10;&#10;        // Open chat window (mark as read will be handled by ChatWindow when it becomes active)&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            if (!newMap.has(conversation.id)) {&#10;                newMap.set(conversation.id, { ...conversation, minimized: false });&#10;            } else {&#10;                const existing = newMap.get(conversation.id);&#10;                newMap.set(conversation.id, { ...existing, minimized: false });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleCloseChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            newMap.delete(conversationId);&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleMinimizeChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            const chatWindow = newMap.get(conversationId);&#10;            if (chatWindow) {&#10;                const willBeMinimized = !chatWindow.minimized;&#10;&#10;                // ✅ IMPORTANT: ANY minimized window should NOT be active&#10;                if (willBeMinimized) {&#10;                    // Minimizing - always clear active if this window is active&#10;                    if (activeChatWindow === conversationId) {&#10;                        console.log(' Minimizing window, clearing active state:', conversationId);&#10;                        setActiveChatWindow(null);&#10;                        activeChatWindowRef.current = null;&#10;                    } else {&#10;                        console.log(' Minimizing inactive window:', conversationId);&#10;                    }&#10;                } else {&#10;                    // Un-minimizing - set as active&#10;                    console.log(' Un-minimizing window, setting as active:', conversationId);&#10;                    setActiveChatWindow(conversationId);&#10;                    activeChatWindowRef.current = conversationId;&#10;                }&#10;&#10;                newMap.set(conversationId, { ...chatWindow, minimized: willBeMinimized });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, [activeChatWindow]);&#10;&#10;    // Handle chat window click to set as active (Facebook-style)&#10;    const handleChatWindowClick = useCallback((conversationId) =&gt; {&#10;        console.log(' Setting active chat window (handleChatWindowClick):', conversationId);&#10;        setActiveChatWindow(conversationId);&#10;        activeChatWindowRef.current = conversationId; // Immediate update via ref&#10;    }, []);&#10;&#10;    // Handle mark as read callback from ChatWindow&#10;    const handleMarkAsRead = useCallback((conversationId) =&gt; {&#10;        console.log(' Mark as read callback for:', conversationId);&#10;        setConversations(prev =&gt; prev.map(conv =&gt;&#10;            conv.id === conversationId ? { ...conv, unreadCount: 0 } : conv&#10;        ));&#10;    }, []);&#10;&#10;    // Handle new messages from WebSocket&#10;    const handleNewMessage = useCallback((conversationId, message) =&gt; {&#10;        let lastMessageContent = message.content;&#10;        if (message.content?.startsWith('LOCATION:')) {&#10;            lastMessageContent = 'Vị trí';&#10;        }&#10;&#10;        setConversations(prev =&gt; prev.map(conv =&gt; {&#10;            if (conv.id === conversationId) {&#10;                return {&#10;                    ...conv,&#10;                    lastMessageContent: lastMessageContent,&#10;                    lastMessageTime: message.createdAt || message.timestamp,&#10;                    lastMessageSender: message.senderName,&#10;                };&#10;            }&#10;            return conv;&#10;        }));&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        const chatToggle = document.getElementById('chatToggle');&#10;        if (chatToggle) {&#10;            chatToggle.addEventListener('click', handleChatToggle);&#10;            return () =&gt; chatToggle.removeEventListener('click', handleChatToggle);&#10;        }&#10;    }, [handleChatToggle]);&#10;&#10;    useEffect(() =&gt; {&#10;        const handleEscape = (e) =&gt; {&#10;            if (e.key === 'Escape' &amp;&amp; isChatOpen) {&#10;                setIsChatOpen(false);&#10;            }&#10;        };&#10;&#10;        document.addEventListener('keydown', handleEscape);&#10;        return () =&gt; document.removeEventListener('keydown', handleEscape);&#10;    }, [isChatOpen]);&#10;&#10;    // Sort conversations by lastMessageAt (newest first) - REAL-TIME SORTING&#10;    const sortedConversations = useMemo(() =&gt; {&#10;        return [...conversations].sort((a, b) =&gt; {&#10;            // Handle null/undefined lastMessageAt&#10;            if (!a.lastMessageAt &amp;&amp; !b.lastMessageAt) return 0;&#10;            if (!a.lastMessageAt) return 1; // a goes to bottom&#10;            if (!b.lastMessageAt) return -1; // b goes to bottom&#10;&#10;            // Compare dates - newest first (descending order)&#10;            const dateA = new Date(a.lastMessageAt);&#10;            const dateB = new Date(b.lastMessageAt);&#10;            return dateB - dateA;&#10;        });&#10;    }, [conversations]);&#10;&#10;    // Filter conversations based on search query&#10;    const filteredConversations = sortedConversations.filter(conv =&gt; {&#10;        const displayName = conv.isGroup ? conv.groupName : conv.otherUser?.displayName || '';&#10;        return displayName.toLowerCase().includes(searchQuery.toLowerCase());&#10;    });&#10;&#10;    // Get display info for conversation&#10;    const getConversationDisplay = (conv) =&gt; {&#10;        if (conv.isGroup) {&#10;            return {&#10;                name: conv.groupName || 'Nhóm',&#10;                avatar: conv.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conv.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conv.otherUser || conv.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.online ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    };&#10;&#10;    // Format last message display with truncation&#10;    const getLastMessageDisplay = (conv) =&gt; {&#10;        if (conv.typingUsers &amp;&amp; conv.typingUsers.length &gt; 0) {&#10;            return (&#10;                &lt;span className=&quot;typing-indicator-text&quot;&gt;&#10;                    &lt;span className=&quot;typing-dots-inline&quot;&gt;&#10;                        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&#10;                    &lt;/span&gt;&#10;                    {' '}đang nhập&#10;                &lt;/span&gt;&#10;            );&#10;        }&#10;&#10;        if (conv.lastMessageContent) {&#10;            const prefix = conv.lastMessageSenderId === currentUserId ? 'Bạn: ' : '';&#10;            const maxLength = 30; // Maximum characters to display&#10;&#10;            let displayContent = conv.lastMessageContent;&#10;            if (displayContent.length &gt; maxLength) {&#10;                displayContent = displayContent.substring(0, maxLength) + '...';&#10;            }&#10;&#10;            return `${prefix}${displayContent}`;&#10;        }&#10;&#10;        return 'Bắt đầu trò chuyện';&#10;    };&#10;&#10;    // Format time ago like Facebook (e.g., &quot;6 giờ&quot;, &quot;2 phút&quot;, &quot;vừa xong&quot;)&#10;    const formatTimeAgo = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;&#10;        const now = new Date();&#10;        const messageTime = new Date(timestamp);&#10;        const diffInSeconds = Math.floor((now - messageTime) / 1000);&#10;&#10;        if (diffInSeconds &lt; 60) {&#10;            return 'vừa xong';&#10;        }&#10;&#10;        const diffInMinutes = Math.floor(diffInSeconds / 60);&#10;        if (diffInMinutes &lt; 60) {&#10;            return `${diffInMinutes} phút`;&#10;        }&#10;&#10;        const diffInHours = Math.floor(diffInMinutes / 60);&#10;        if (diffInHours &lt; 24) {&#10;            return `${diffInHours} giờ`;&#10;        }&#10;&#10;        const diffInDays = Math.floor(diffInHours / 24);&#10;        if (diffInDays &lt; 7) {&#10;            return `${diffInDays} ngày`;&#10;        }&#10;&#10;        const diffInWeeks = Math.floor(diffInDays / 7);&#10;        if (diffInWeeks &lt; 4) {&#10;            return `${diffInWeeks} tuần`;&#10;        }&#10;&#10;        // For messages older than 4 weeks, show date&#10;        return messageTime.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            {/* Chat Popup Overlay */}&#10;            &lt;div&#10;                className={`chat-popup-overlay ${isChatOpen ? 'is-active' : ''}`}&#10;                id=&quot;chatPopupOverlay&quot;&#10;                onClick={handleOverlayClick}&#10;                role=&quot;button&quot;&#10;                tabIndex={0}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleOverlayClick()}&#10;                aria-label=&quot;Close chat&quot;&#10;            /&gt;&#10;&#10;            {/* Side Chat */}&#10;            &lt;div className={`side-chat ${isChatOpen ? 'is-active' : ''}`} id=&quot;sideChat&quot;&gt;&#10;                &lt;div className=&quot;chat-header&quot;&gt;&#10;                    &lt;h3&gt;Đoạn chat&lt;/h3&gt;&#10;                    &lt;button className=&quot;chat-close-btn&quot; id=&quot;chatCloseBtn&quot; onClick={handleCloseChatPopup}&gt;×&lt;/button&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Search Box */}&#10;                &lt;div className=&quot;chat-search-box&quot;&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        placeholder=&quot;Tìm kiếm đoạn chat...&quot;&#10;                        value={searchQuery}&#10;                        onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;                        className=&quot;chat-search-input&quot;&#10;                    /&gt;&#10;                    {searchQuery &amp;&amp; (&#10;                        &lt;button&#10;                            className=&quot;chat-search-clear&quot;&#10;                            onClick={() =&gt; setSearchQuery('')}&#10;                        &gt;&#10;                            ×&#10;                        &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;chat-friends-list&quot;&gt;&#10;                    {isLoading ? (&#10;                        &lt;div className=&quot;chat-loading&quot;&gt;Đang tải...&lt;/div&gt;&#10;                    ) : filteredConversations.length === 0 ? (&#10;                        &lt;div className=&quot;chat-empty&quot;&gt;Không có đoạn chat nào&lt;/div&gt;&#10;                    ) : (&#10;                        filteredConversations.map((conv) =&gt; {&#10;                            const display = getConversationDisplay(conv);&#10;                            const hasUnread = conv.unreadCount &gt; 0;&#10;                            const showBlueDot = hasUnread &amp;&amp; conv.unreadCount &lt;= 5; // Show dot for 1-5 unread&#10;&#10;                            return (&#10;                                &lt;div&#10;                                    key={conv.id}&#10;                                    className={`friend-item ${activeFriend === conv.id ? 'active' : ''} ${hasUnread ? 'unread' : ''} ${showBlueDot ? 'has-dot' : ''}`}&#10;                                    onClick={() =&gt; handleFriendClick(conv)}&#10;                                    role=&quot;button&quot;&#10;                                    tabIndex={0}&#10;                                    onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleFriendClick(conv)}&#10;                                    data-friend={conv.id}&#10;                                &gt;&#10;                                    {/* Blue Dot Indicator for new messages */}&#10;                                    {showBlueDot &amp;&amp; &lt;div className=&quot;unread-dot&quot;&gt;&lt;/div&gt;}&#10;&#10;                                    &lt;img src={display.avatar} alt=&quot;Avatar&quot; className=&quot;friend-avatar&quot; /&gt;&#10;                                    &lt;div className=&quot;friend-info&quot;&gt;&#10;                                        &lt;div className=&quot;friend-name&quot;&gt;{display.name}&lt;/div&gt;&#10;                                        &lt;div className=&quot;friend-status&quot;&gt;&#10;                                            {getLastMessageDisplay(conv)}&#10;                                            {/* Only show timestamp if NOT typing and has last message */}&#10;                                            {!conv.typingUsers?.length &amp;&amp; conv.lastMessageAt &amp;&amp; conv.lastMessageContent &amp;&amp; (&#10;                                                &lt;span className=&quot;message-time&quot;&gt; · {formatTimeAgo(conv.lastMessageAt)}&lt;/span&gt;&#10;                                            )}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                    {hasUnread &amp;&amp; (&#10;                                        &lt;div className={`unread-count ${conv.unreadCount &gt; 99 ? 'large' : ''}`}&gt;&#10;                                            {conv.unreadCount &gt; 99 ? '99+' : conv.unreadCount}&#10;                                        &lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            );&#10;                        })&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {!isConnected &amp;&amp; (&#10;                    &lt;div className=&quot;chat-connection-status&quot;&gt;&#10;                        &lt;span className=&quot;connection-indicator offline&quot;&gt;●&lt;/span&gt;&#10;                        {' '}Đang kết nối lại...&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Chat Windows Container */}&#10;            &lt;div className=&quot;chat-windows-container&quot; id=&quot;chatWindowsContainer&quot;&gt;&#10;                {Array.from(openChatWindows.entries()).map(([conversationId, chatData]) =&gt; {&#10;                    const conversation = conversations.find(c =&gt; c.id === conversationId) || chatData;&#10;&#10;                    // ✅ IMPORTANT: Minimized windows should NEVER be active&#10;                    const isActive = chatData.minimized ? false : (activeChatWindow === conversationId);&#10;&#10;                    // DEBUG: Log render to verify isActive state&#10;                    console.log(' Rendering ChatWindow:', {&#10;                        conversationId: conversationId.substring(0, 8) + '...',&#10;                        isActive,&#10;                        activeChatWindow: activeChatWindow ? activeChatWindow.substring(0, 8) + '...' : 'null',&#10;                        minimized: chatData.minimized&#10;                    });&#10;&#10;                    return (&#10;                        &lt;ChatWindow&#10;                            key={conversationId}&#10;                            conversation={conversation}&#10;                            minimized={chatData.minimized}&#10;                            isActive={isActive}&#10;                            currentUserId={currentUserId}&#10;                            unreadCount={conversation.unreadCount || 0}&#10;                            onClose={() =&gt; handleCloseChatWindow(conversationId)}&#10;                            onMinimize={() =&gt; handleMinimizeChatWindow(conversationId)}&#10;                            onNewMessage={(message) =&gt; handleNewMessage(conversationId, message)}&#10;                            onMarkAsRead={handleMarkAsRead}&#10;                            onWindowClick={() =&gt; handleChatWindowClick(conversationId)}&#10;                        /&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';&#10;import './Chat.css';&#10;import './ChatWindows.css';&#10;import './LocationMessage.css';&#10;import ChatWindow from './ChatWindow';&#10;import { ChatService, webSocketService } from '../../services/ChatService';&#10;&#10;export default function SideChat() {&#10;    const [isChatOpen, setIsChatOpen] = useState(false);&#10;    const [activeFriend, setActiveFriend] = useState(null);&#10;    const [openChatWindows, setOpenChatWindows] = useState(new Map());&#10;    const [activeChatWindow, setActiveChatWindow] = useState(null); // Track active window (Facebook-style)&#10;    const [conversations, setConversations] = useState([]);&#10;    const [searchQuery, setSearchQuery] = useState('');&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isConnected, setIsConnected] = useState(false);&#10;    const [currentUserId, setCurrentUserId] = useState(null);&#10;    const wsConnectedRef = useRef(false);&#10;    const conversationIdsRef = useRef(new Set()); // Track conversation IDs to detect new conversations&#10;    const activeChatWindowRef = useRef(null); // Track active window with ref for immediate access&#10;&#10;    // Load conversations from backend&#10;    const loadConversations = useCallback(async () =&gt; {&#10;        try {&#10;            setIsLoading(true);&#10;            const data = await ChatService.getUserConversations();&#10;            // Parse location messages in lastMessage&#10;            const processedData = data.map(conv =&gt; {&#10;                if (conv.lastMessageContent?.startsWith('LOCATION:')) {&#10;                    return {&#10;                        ...conv,&#10;                        lastMessageContent: 'Vị trí'&#10;                    };&#10;                }&#10;                return conv;&#10;            }).map(conv =&gt; ({ ...conv, typingUsers: [] })); // Add typingUsers array&#10;            setConversations(processedData);&#10;        } catch (error) {&#10;            console.error('Failed to load conversations:', error);&#10;        } finally {&#10;            setIsLoading(false);&#10;        }&#10;    }, []);&#10;&#10;    // Connect to WebSocket&#10;    useEffect(() =&gt; {&#10;        const conversationIdsRefCurrent = conversationIdsRef.current; // Copy ref for cleanup&#10;&#10;        if (!wsConnectedRef.current) {&#10;            webSocketService.connect(&#10;                () =&gt; {&#10;                    console.log('✅ WebSocket connected');&#10;                    setIsConnected(true);&#10;                    wsConnectedRef.current = true;&#10;&#10;                    // Lấy userId từ WebSocket service (đã được fetch từ backend)&#10;                    const userId = webSocketService.getCurrentUserId();&#10;                    setCurrentUserId(userId);&#10;&#10;                    // Subscribe to user queue for unread counts&#10;                    webSocketService.subscribeToUserQueue(&#10;                        (unreadDTO) =&gt; {&#10;                            console.log(' Received unread count update:', unreadDTO);&#10;                            // Update unread count for conversation&#10;                            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                                if (conv.id === unreadDTO.conversationId) {&#10;                                    console.log(` Updating unread count for conv ${conv.id}: ${conv.unreadCount} → ${unreadDTO.count}`);&#10;                                    return { ...conv, unreadCount: unreadDTO.count };&#10;                                }&#10;                                return conv;&#10;                            }));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('WebSocket error:', error);&#10;                        }&#10;                    );&#10;&#10;                    // Subscribe to conversation updates&#10;                    webSocketService.subscribeToConversationUpdates(&#10;                        (updateDTO) =&gt; {&#10;                            console.log(' Received conversation update:', updateDTO);&#10;                            // Update conversation with new last message and unread count&#10;                            let lastMessageContent = updateDTO.lastMessageContent;&#10;                            if (updateDTO.lastMessageContent?.startsWith('LOCATION:')) {&#10;                                lastMessageContent = 'Vị trí';&#10;                            }&#10;&#10;                            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                                if (conv.id === updateDTO.conversationId) {&#10;                                    console.log(` Updating conversation ${conv.id} with unread count: ${updateDTO.unreadCount}`);&#10;                                    return {&#10;                                        ...conv,&#10;                                        lastMessageContent: lastMessageContent,&#10;                                        lastMessageSenderId: updateDTO.lastMessageSenderId,&#10;                                        lastMessageAt: updateDTO.lastMessageAt,&#10;                                        unreadCount: updateDTO.unreadCount&#10;                                    };&#10;                                }&#10;                                return conv;&#10;                            }));&#10;                        },&#10;                        (error) =&gt; {&#10;                            console.error('Conversation update error:', error);&#10;                        }&#10;                    );&#10;                },&#10;                (error) =&gt; {&#10;                    console.error('WebSocket connection failed:', error);&#10;                    setIsConnected(false);&#10;                    wsConnectedRef.current = false;&#10;                }&#10;            );&#10;        }&#10;&#10;        return () =&gt; {&#10;            if (wsConnectedRef.current) {&#10;                webSocketService.disconnect();&#10;                wsConnectedRef.current = false;&#10;                // Clear subscription tracking to force re-subscribe on next connect&#10;                conversationIdsRefCurrent.clear();&#10;                console.log(' WebSocket disconnected, cleared subscription tracking');&#10;            }&#10;        };&#10;    }, []);&#10;&#10;    // Load conversations on mount - CRITICAL: Load BEFORE subscribing&#10;    useEffect(() =&gt; {&#10;        console.log(' Loading conversations on mount');&#10;        loadConversations();&#10;    }, [loadConversations]);&#10;&#10;    // ✅ Reload conversations when SideChat opens to get latest data&#10;    useEffect(() =&gt; {&#10;        if (isChatOpen) {&#10;            console.log(' SideChat opened - reloading conversations to get latest messages');&#10;            loadConversations();&#10;        }&#10;    }, [isChatOpen, loadConversations]);&#10;&#10;    // Subscribe to all conversations for both messages and typing&#10;    // Only re-run when isConnected changes, NOT when conversations state updates&#10;    useEffect(() =&gt; {&#10;        if (!isConnected) return;&#10;&#10;        console.log(' Subscribe effect running (on connection change):', {&#10;            isConnected,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        // This effect should NOT re-run when conversations state changes&#10;        // We'll use a separate effect to handle new conversations&#10;&#10;        // Cleanup when component unmounts or connection changes&#10;        return () =&gt; {&#10;            console.log(' Cleaning up all subscriptions due to unmount/disconnect');&#10;            // Clear all tracked IDs to force re-subscribe on reconnect&#10;            conversationIdsRef.current.clear();&#10;        };&#10;    }, [isConnected]);&#10;&#10;    // Separate effect to subscribe to NEW conversations when they appear&#10;    useEffect(() =&gt; {&#10;        console.log(' Effect 2 triggered:', {&#10;            isConnected,&#10;            conversationsLength: conversations.length,&#10;            currentUserId,&#10;            trackedIds: Array.from(conversationIdsRef.current)&#10;        });&#10;&#10;        if (!isConnected) {&#10;            console.log('⏸️ Waiting for connection...');&#10;            return;&#10;        }&#10;&#10;        if (conversations.length === 0) {&#10;            console.log('⏸️ No conversations yet, waiting...');&#10;            return;&#10;        }&#10;&#10;        if (!currentUserId) {&#10;            console.log('⏸️ Waiting for currentUserId...');&#10;            return;&#10;        }&#10;&#10;        console.log('✅ Ready to subscribe! Processing conversations...');&#10;&#10;        let subscribedCount = 0;&#10;        let skippedCount = 0;&#10;&#10;        conversations.forEach(conv =&gt; {&#10;            // Only subscribe to NEW conversations (not already in ref)&#10;            if (conversationIdsRef.current.has(conv.id)) {&#10;                // Already subscribed, do nothing&#10;                console.log(`⏭️ Skipping ${conv.id} (already subscribed)`);&#10;                skippedCount++;&#10;                return;&#10;            }&#10;&#10;            console.log(` New conversation detected: ${conv.id}, will subscribe`);&#10;&#10;            // Create message callback with closure over conv.id&#10;            const messageCallback = (message) =&gt; {&#10;                console.log(' SideChat received new message for conv', conv.id, ':', message);&#10;&#10;                // Process location messages&#10;                let lastMessageContent = message.content;&#10;                if (message.content &amp;&amp; message.content.startsWith('LOCATION:')) {&#10;                    lastMessageContent = 'Vị trí';&#10;                } else if (message.isLocation) {&#10;                    lastMessageContent = 'Vị trí';&#10;                }&#10;&#10;                // Update conversation's last message&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        console.log(`✏️ Updating last message for conv ${conv.id}:`, lastMessageContent);&#10;&#10;                        // Increment unread count if message is from someone else&#10;                        const isFromOthers = message.senderId !== currentUserId;&#10;                        const newUnreadCount = isFromOthers ? (c.unreadCount || 0) + 1 : c.unreadCount;&#10;&#10;                        if (isFromOthers) {&#10;                            console.log(` Incrementing unread count for conv ${conv.id}: ${c.unreadCount} → ${newUnreadCount}`);&#10;                        }&#10;&#10;                        return {&#10;                            ...c,&#10;                            lastMessageContent: lastMessageContent,&#10;                            lastMessageSenderId: message.senderId,&#10;                            lastMessageAt: message.createdAt || message.timestamp || new Date().toISOString(),&#10;                            unreadCount: newUnreadCount&#10;                        };&#10;                    }&#10;                    return c;&#10;                }));&#10;            };&#10;&#10;            // Create typing callback&#10;            const typingCallback = (typingDTO) =&gt; {&#10;                console.log(' SideChat received typing from WebSocket:', typingDTO);&#10;&#10;                // Handle both 'typing' and 'isTyping' field names from backend&#10;                const isTyping = typingDTO.typing ?? typingDTO.isTyping ?? false;&#10;&#10;                // Update typingUsers directly for THIS conversation&#10;                setConversations(prev =&gt; prev.map(c =&gt; {&#10;                    if (c.id === conv.id) {&#10;                        let newTypingUsers = [...(c.typingUsers || [])];&#10;                        let hasChanged = false;&#10;&#10;                        if (isTyping) {&#10;                            // User started typing&#10;                            if (!newTypingUsers.includes(typingDTO.userId)) {&#10;                                newTypingUsers.push(typingDTO.userId);&#10;                                hasChanged = true;&#10;                                console.log(`✍️ User ${typingDTO.userId} started typing in conv ${conv.id}`);&#10;                            }&#10;                        } else {&#10;                            // User stopped typing&#10;                            const beforeLength = newTypingUsers.length;&#10;                            newTypingUsers = newTypingUsers.filter(id =&gt; id !== typingDTO.userId);&#10;                            hasChanged = beforeLength !== newTypingUsers.length;&#10;                            if (hasChanged) {&#10;                                console.log(`⏹️ User ${typingDTO.userId} stopped typing in conv ${conv.id}`);&#10;                            }&#10;                        }&#10;&#10;                        // Only update if actually changed to prevent unnecessary re-renders&#10;                        if (hasChanged) {&#10;                            console.log(` Updated typingUsers for conv ${conv.id}:`, newTypingUsers);&#10;                            return { ...c, typingUsers: newTypingUsers };&#10;                        }&#10;                        return c; // No change, return same reference&#10;                    }&#10;                    return c;&#10;                }));&#10;&#10;                // Also dispatch event for ChatWindow to handle&#10;                window.dispatchEvent(new CustomEvent('typingStatus', {&#10;                    detail: { conversationId: conv.id, isTyping: isTyping, userId: typingDTO.userId }&#10;                }));&#10;            };&#10;&#10;            // Subscribe to messages AND typing for this conversation&#10;            webSocketService.subscribeToConversation(&#10;                conv.id,&#10;                messageCallback,&#10;                typingCallback,&#10;                null&#10;            );&#10;&#10;            // Mark as subscribed (IMPORTANT: callbacks will persist via WebSocketService)&#10;            conversationIdsRef.current.add(conv.id);&#10;            subscribedCount++;&#10;&#10;            console.log(` SideChat subscribed to conversation ${conv.id}`);&#10;&#10;            // ✅ IMPORTANT: Fetch current typing users after subscribing&#10;            // This ensures we see typing status from users who started typing BEFORE we subscribed&#10;            ChatService.getTypingUsers(conv.id)&#10;                .then(typingUserIds =&gt; {&#10;                    console.log(` Fetched current typing users for conv ${conv.id}:`, typingUserIds);&#10;&#10;                    if (typingUserIds &amp;&amp; typingUserIds.length &gt; 0) {&#10;                        setConversations(prev =&gt; prev.map(c =&gt; {&#10;                            if (c.id === conv.id) {&#10;                                // Filter out duplicates and current user&#10;                                const uniqueTypingUsers = [...new Set([...(c.typingUsers || []), ...typingUserIds])]&#10;                                    .filter(userId =&gt; userId !== currentUserId);&#10;&#10;                                console.log(`✍️ Setting initial typing users for conv ${conv.id}:`, uniqueTypingUsers);&#10;                                return { ...c, typingUsers: uniqueTypingUsers };&#10;                            }&#10;                            return c;&#10;                        }));&#10;                    }&#10;                })&#10;                .catch(error =&gt; {&#10;                    console.error(`Failed to fetch typing users for conv ${conv.id}:`, error);&#10;                });&#10;        });&#10;&#10;        console.log(` Subscribe summary: ${subscribedCount} new, ${skippedCount} skipped, ${conversationIdsRef.current.size} total tracked`);&#10;&#10;        // NO cleanup function here - subscriptions persist across state updates&#10;        // Cleanup only happens in the isConnected effect above&#10;    }, [conversations, isConnected, currentUserId]); // ✅ Add currentUserId to deps&#10;&#10;    // Listen for openChatWindow event from Profile Page&#10;    useEffect(() =&gt; {&#10;        const handleOpenChatWindow = (event) =&gt; {&#10;            const { conversation, minimized } = event.detail;&#10;&#10;            if (!conversation) return;&#10;&#10;            // Add to conversations list if not exists&#10;            setConversations(prev =&gt; {&#10;                const exists = prev.find(c =&gt; c.id === conversation.id);&#10;                if (!exists) {&#10;                    return [conversation, ...prev];&#10;                }&#10;                return prev;&#10;            });&#10;&#10;            // Open chat window&#10;            setOpenChatWindows(prev =&gt; {&#10;                const newMap = new Map(prev);&#10;                newMap.set(conversation.id, { ...conversation, minimized: minimized || false });&#10;                return newMap;&#10;            });&#10;&#10;            setActiveFriend(conversation.id);&#10;        };&#10;&#10;        window.addEventListener('openChatWindow', handleOpenChatWindow);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('openChatWindow', handleOpenChatWindow);&#10;        };&#10;    }, []);&#10;&#10;    // Listen for typing status updates from ChatWindow&#10;    useEffect(() =&gt; {&#10;        const handleTypingStatus = (event) =&gt; {&#10;            const { conversationId, isTyping, userId } = event.detail;&#10;            console.log('SideChat handling typingStatus:', { conversationId, isTyping, userId });&#10;            setConversations(prev =&gt; prev.map(conv =&gt; {&#10;                if (conv.id === conversationId) {&#10;                    let newTypingUsers = [...conv.typingUsers];&#10;                    if (isTyping) {&#10;                        if (!newTypingUsers.includes(userId)) {&#10;                            newTypingUsers.push(userId);&#10;                        }&#10;                    } else {&#10;                        newTypingUsers = newTypingUsers.filter(id =&gt; id !== userId);&#10;                    }&#10;                    console.log('Updated typingUsers for conv', conv.id, ':', newTypingUsers);&#10;                    return { ...conv, typingUsers: newTypingUsers };&#10;                }&#10;                return conv;&#10;            }));&#10;        };&#10;&#10;        window.addEventListener('typingStatus', handleTypingStatus);&#10;&#10;        return () =&gt; {&#10;            window.removeEventListener('typingStatus', handleTypingStatus);&#10;        };&#10;    }, []);&#10;&#10;    const handleChatToggle = useCallback(() =&gt; {&#10;        setIsChatOpen(prev =&gt; !prev);&#10;    }, []);&#10;&#10;    const handleCloseChatPopup = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleOverlayClick = useCallback(() =&gt; {&#10;        setIsChatOpen(false);&#10;    }, []);&#10;&#10;    const handleFriendClick = useCallback(async (conversation) =&gt; {&#10;        setActiveFriend(conversation.id);&#10;        setIsChatOpen(false);&#10;&#10;        // Set as active chat window (Facebook-style) - both state and ref&#10;        console.log(' Setting active chat window (handleFriendClick):', conversation.id);&#10;        setActiveChatWindow(conversation.id);&#10;        activeChatWindowRef.current = conversation.id; // Immediate update via ref&#10;&#10;        // Open chat window (mark as read will be handled by ChatWindow when it becomes active)&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            if (!newMap.has(conversation.id)) {&#10;                newMap.set(conversation.id, { ...conversation, minimized: false });&#10;            } else {&#10;                const existing = newMap.get(conversation.id);&#10;                newMap.set(conversation.id, { ...existing, minimized: false });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleCloseChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            newMap.delete(conversationId);&#10;            return newMap;&#10;        });&#10;    }, []);&#10;&#10;    const handleMinimizeChatWindow = useCallback((conversationId) =&gt; {&#10;        setOpenChatWindows(prev =&gt; {&#10;            const newMap = new Map(prev);&#10;            const chatWindow = newMap.get(conversationId);&#10;            if (chatWindow) {&#10;                const willBeMinimized = !chatWindow.minimized;&#10;&#10;                // ✅ IMPORTANT: ANY minimized window should NOT be active&#10;                if (willBeMinimized) {&#10;                    // Minimizing - always clear active if this window is active&#10;                    if (activeChatWindow === conversationId) {&#10;                        console.log(' Minimizing window, clearing active state:', conversationId);&#10;                        setActiveChatWindow(null);&#10;                        activeChatWindowRef.current = null;&#10;                    } else {&#10;                        console.log(' Minimizing inactive window:', conversationId);&#10;                    }&#10;                } else {&#10;                    // Un-minimizing - set as active&#10;                    console.log(' Un-minimizing window, setting as active:', conversationId);&#10;                    setActiveChatWindow(conversationId);&#10;                    activeChatWindowRef.current = conversationId;&#10;                }&#10;&#10;                newMap.set(conversationId, { ...chatWindow, minimized: willBeMinimized });&#10;            }&#10;            return newMap;&#10;        });&#10;    }, [activeChatWindow]);&#10;&#10;    // Handle chat window click to set as active (Facebook-style)&#10;    const handleChatWindowClick = useCallback((conversationId) =&gt; {&#10;        console.log(' Setting active chat window (handleChatWindowClick):', conversationId);&#10;        setActiveChatWindow(conversationId);&#10;        activeChatWindowRef.current = conversationId; // Immediate update via ref&#10;    }, []);&#10;&#10;    // Handle mark as read callback from ChatWindow&#10;    const handleMarkAsRead = useCallback((conversationId) =&gt; {&#10;        console.log(' Mark as read callback for:', conversationId);&#10;        setConversations(prev =&gt; prev.map(conv =&gt;&#10;            conv.id === conversationId ? { ...conv, unreadCount: 0 } : conv&#10;        ));&#10;    }, []);&#10;&#10;    // Handle new messages from WebSocket&#10;    const handleNewMessage = useCallback((conversationId, message) =&gt; {&#10;        let lastMessageContent = message.content;&#10;        if (message.content?.startsWith('LOCATION:')) {&#10;            lastMessageContent = 'Vị trí';&#10;        }&#10;&#10;        setConversations(prev =&gt; prev.map(conv =&gt; {&#10;            if (conv.id === conversationId) {&#10;                return {&#10;                    ...conv,&#10;                    lastMessageContent: lastMessageContent,&#10;                    lastMessageTime: message.createdAt || message.timestamp,&#10;                    lastMessageSender: message.senderName,&#10;                };&#10;            }&#10;            return conv;&#10;        }));&#10;    }, []);&#10;&#10;    useEffect(() =&gt; {&#10;        const chatToggle = document.getElementById('chatToggle');&#10;        if (chatToggle) {&#10;            chatToggle.addEventListener('click', handleChatToggle);&#10;            return () =&gt; chatToggle.removeEventListener('click', handleChatToggle);&#10;        }&#10;    }, [handleChatToggle]);&#10;&#10;    useEffect(() =&gt; {&#10;        const handleEscape = (e) =&gt; {&#10;            if (e.key === 'Escape' &amp;&amp; isChatOpen) {&#10;                setIsChatOpen(false);&#10;            }&#10;        };&#10;&#10;        document.addEventListener('keydown', handleEscape);&#10;        return () =&gt; document.removeEventListener('keydown', handleEscape);&#10;    }, [isChatOpen]);&#10;&#10;    // Sort conversations by lastMessageAt (newest first) - REAL-TIME SORTING&#10;    const sortedConversations = useMemo(() =&gt; {&#10;        return [...conversations].sort((a, b) =&gt; {&#10;            // Handle null/undefined lastMessageAt&#10;            if (!a.lastMessageAt &amp;&amp; !b.lastMessageAt) return 0;&#10;            if (!a.lastMessageAt) return 1; // a goes to bottom&#10;            if (!b.lastMessageAt) return -1; // b goes to bottom&#10;&#10;            // Compare dates - newest first (descending order)&#10;            const dateA = new Date(a.lastMessageAt);&#10;            const dateB = new Date(b.lastMessageAt);&#10;            return dateB - dateA;&#10;        });&#10;    }, [conversations]);&#10;&#10;    // Filter conversations based on search query&#10;    const filteredConversations = sortedConversations.filter(conv =&gt; {&#10;        const displayName = conv.isGroup ? conv.groupName : conv.otherUser?.displayName || '';&#10;        return displayName.toLowerCase().includes(searchQuery.toLowerCase());&#10;    });&#10;&#10;    // Get display info for conversation&#10;    const getConversationDisplay = (conv) =&gt; {&#10;        if (conv.isGroup) {&#10;            return {&#10;                name: conv.groupName || 'Nhóm',&#10;                avatar: conv.groupAvatar || '/channels/myprofile.jpg',&#10;                status: `${conv.members?.length || 0} thành viên`,&#10;            };&#10;        } else {&#10;            const otherUser = conv.otherUser || conv.members?.find(m =&gt; m.userId !== currentUserId);&#10;            return {&#10;                name: otherUser?.fullName || 'User',&#10;                avatar: otherUser?.avatarUrl || '/channels/myprofile.jpg',&#10;                status: otherUser?.online ? 'Đang hoạt động' : 'Không hoạt động',&#10;            };&#10;        }&#10;    };&#10;&#10;    // Format last message display with truncation&#10;    const getLastMessageDisplay = (conv) =&gt; {&#10;        if (conv.typingUsers &amp;&amp; conv.typingUsers.length &gt; 0) {&#10;            return (&#10;                &lt;span className=&quot;typing-indicator-text&quot;&gt;&#10;                    &lt;span className=&quot;typing-dots-inline&quot;&gt;&#10;                        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&#10;                    &lt;/span&gt;&#10;                    {' '}đang nhập&#10;                &lt;/span&gt;&#10;            );&#10;        }&#10;&#10;        if (conv.lastMessageContent) {&#10;            const prefix = conv.lastMessageSenderId === currentUserId ? 'Bạn: ' : '';&#10;            const maxLength = 30; // Maximum characters to display&#10;&#10;            let displayContent = conv.lastMessageContent;&#10;            if (displayContent.length &gt; maxLength) {&#10;                displayContent = displayContent.substring(0, maxLength) + '...';&#10;            }&#10;&#10;            return `${prefix}${displayContent}`;&#10;        }&#10;&#10;        return 'Bắt đầu trò chuyện';&#10;    };&#10;&#10;    // Format time ago like Facebook (e.g., &quot;6 giờ&quot;, &quot;2 phút&quot;, &quot;vừa xong&quot;)&#10;    const formatTimeAgo = (timestamp) =&gt; {&#10;        if (!timestamp) return '';&#10;&#10;        const now = new Date();&#10;        const messageTime = new Date(timestamp);&#10;        const diffInSeconds = Math.floor((now - messageTime) / 1000);&#10;&#10;        if (diffInSeconds &lt; 60) {&#10;            return 'vừa xong';&#10;        }&#10;&#10;        const diffInMinutes = Math.floor(diffInSeconds / 60);&#10;        if (diffInMinutes &lt; 60) {&#10;            return `${diffInMinutes} phút`;&#10;        }&#10;&#10;        const diffInHours = Math.floor(diffInMinutes / 60);&#10;        if (diffInHours &lt; 24) {&#10;            return `${diffInHours} giờ`;&#10;        }&#10;&#10;        const diffInDays = Math.floor(diffInHours / 24);&#10;        if (diffInDays &lt; 7) {&#10;            return `${diffInDays} ngày`;&#10;        }&#10;&#10;        const diffInWeeks = Math.floor(diffInDays / 7);&#10;        if (diffInWeeks &lt; 4) {&#10;            return `${diffInWeeks} tuần`;&#10;        }&#10;&#10;        // For messages older than 4 weeks, show date&#10;        return messageTime.toLocaleDateString('vi-VN', { day: '2-digit', month: '2-digit' });&#10;    };&#10;&#10;    return (&#10;        &lt;&gt;&#10;            {/* Chat Popup Overlay */}&#10;            &lt;div&#10;                className={`chat-popup-overlay ${isChatOpen ? 'is-active' : ''}`}&#10;                id=&quot;chatPopupOverlay&quot;&#10;                onClick={handleOverlayClick}&#10;                role=&quot;button&quot;&#10;                tabIndex={0}&#10;                onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleOverlayClick()}&#10;                aria-label=&quot;Close chat&quot;&#10;            /&gt;&#10;&#10;            {/* Side Chat */}&#10;            &lt;div className={`side-chat ${isChatOpen ? 'is-active' : ''}`} id=&quot;sideChat&quot;&gt;&#10;                &lt;div className=&quot;chat-header&quot;&gt;&#10;                    &lt;h3&gt;Đoạn chat&lt;/h3&gt;&#10;                    &lt;button className=&quot;chat-close-btn&quot; id=&quot;chatCloseBtn&quot; onClick={handleCloseChatPopup}&gt;×&lt;/button&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Search Box */}&#10;                &lt;div className=&quot;chat-search-box&quot;&gt;&#10;                    &lt;input&#10;                        type=&quot;text&quot;&#10;                        placeholder=&quot;Tìm kiếm đoạn chat...&quot;&#10;                        value={searchQuery}&#10;                        onChange={(e) =&gt; setSearchQuery(e.target.value)}&#10;                        className=&quot;chat-search-input&quot;&#10;                    /&gt;&#10;                    {searchQuery &amp;&amp; (&#10;                        &lt;button&#10;                            className=&quot;chat-search-clear&quot;&#10;                            onClick={() =&gt; setSearchQuery('')}&#10;                        &gt;&#10;                            ×&#10;                        &lt;/button&gt;&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;chat-friends-list&quot;&gt;&#10;                    {isLoading ? (&#10;                        &lt;div className=&quot;chat-loading&quot;&gt;Đang tải...&lt;/div&gt;&#10;                    ) : filteredConversations.length === 0 ? (&#10;                        &lt;div className=&quot;chat-empty&quot;&gt;Không có đoạn chat nào&lt;/div&gt;&#10;                    ) : (&#10;                        filteredConversations.map((conv) =&gt; {&#10;                            const display = getConversationDisplay(conv);&#10;                            const hasUnread = conv.unreadCount &gt; 0;&#10;                            const showBlueDot = hasUnread &amp;&amp; conv.unreadCount &lt;= 5; // Show dot for 1-5 unread&#10;&#10;                            return (&#10;                                &lt;div&#10;                                    key={conv.id}&#10;                                    className={`friend-item ${activeFriend === conv.id ? 'active' : ''} ${hasUnread ? 'unread' : ''} ${showBlueDot ? 'has-dot' : ''}`}&#10;                                    onClick={() =&gt; handleFriendClick(conv)}&#10;                                    role=&quot;button&quot;&#10;                                    tabIndex={0}&#10;                                    onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handleFriendClick(conv)}&#10;                                    data-friend={conv.id}&#10;                                &gt;&#10;                                    {/* Blue Dot Indicator for new messages */}&#10;                                    {showBlueDot &amp;&amp; &lt;div className=&quot;unread-dot&quot;&gt;&lt;/div&gt;}&#10;&#10;                                    &lt;img src={display.avatar} alt=&quot;Avatar&quot; className=&quot;friend-avatar&quot; /&gt;&#10;                                    &lt;div className=&quot;friend-info&quot;&gt;&#10;                                        &lt;div className=&quot;friend-name&quot;&gt;{display.name}&lt;/div&gt;&#10;                                        &lt;div className=&quot;friend-status&quot;&gt;&#10;                                            {getLastMessageDisplay(conv)}&#10;                                            {/* Only show timestamp if NOT typing and has last message */}&#10;                                            {!conv.typingUsers?.length &amp;&amp; conv.lastMessageAt &amp;&amp; conv.lastMessageContent &amp;&amp; (&#10;                                                &lt;span className=&quot;message-time&quot;&gt; · {formatTimeAgo(conv.lastMessageAt)}&lt;/span&gt;&#10;                                            )}&#10;                                        &lt;/div&gt;&#10;                                    &lt;/div&gt;&#10;                                    {hasUnread &amp;&amp; (&#10;                                        &lt;div className={`unread-count ${conv.unreadCount &gt; 99 ? 'large' : ''}`}&gt;&#10;                                            {conv.unreadCount &gt; 99 ? '99+' : conv.unreadCount}&#10;                                        &lt;/div&gt;&#10;                                    )}&#10;                                &lt;/div&gt;&#10;                            );&#10;                        })&#10;                    )}&#10;                &lt;/div&gt;&#10;&#10;                {!isConnected &amp;&amp; (&#10;                    &lt;div className=&quot;chat-connection-status&quot;&gt;&#10;                        &lt;span className=&quot;connection-indicator offline&quot;&gt;●&lt;/span&gt;&#10;                        {' '}Đang kết nối lại...&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;&#10;            {/* Chat Windows Container */}&#10;            &lt;div className=&quot;chat-windows-container&quot; id=&quot;chatWindowsContainer&quot;&gt;&#10;                {Array.from(openChatWindows.entries()).map(([conversationId, chatData]) =&gt; {&#10;                    const conversation = conversations.find(c =&gt; c.id === conversationId) || chatData;&#10;&#10;                    // ✅ IMPORTANT: Minimized windows should NEVER be active&#10;                    const isActive = chatData.minimized ? false : (activeChatWindow === conversationId);&#10;&#10;                    // DEBUG: Log render to verify isActive state&#10;                    console.log(' Rendering ChatWindow:', {&#10;                        conversationId: conversationId.substring(0, 8) + '...',&#10;                        isActive,&#10;                        activeChatWindow: activeChatWindow ? activeChatWindow.substring(0, 8) + '...' : 'null',&#10;                        minimized: chatData.minimized&#10;                    });&#10;&#10;                    return (&#10;                        &lt;ChatWindow&#10;                            key={conversationId}&#10;                            conversation={conversation}&#10;                            minimized={chatData.minimized}&#10;                            isActive={isActive}&#10;                            currentUserId={currentUserId}&#10;                            unreadCount={conversation.unreadCount || 0}&#10;                            onClose={() =&gt; handleCloseChatWindow(conversationId)}&#10;                            onMinimize={() =&gt; handleMinimizeChatWindow(conversationId)}&#10;                            onNewMessage={(message) =&gt; handleNewMessage(conversationId, message)}&#10;                            onMarkAsRead={handleMarkAsRead}&#10;                            onWindowClick={() =&gt; handleChatWindowClick(conversationId)}&#10;                        /&gt;&#10;                    );&#10;                })}&#10;            &lt;/div&gt;&#10;        &lt;/&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/social-map/src/main/java/com/mapsocial/controller/ChatController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/social-map/src/main/java/com/mapsocial/controller/ChatController.java" />
              <option name="originalContent" value="package com.mapsocial.controller;&#10;&#10;&#10;import com.mapsocial.dto.ChatMessageDTO;&#10;import com.mapsocial.dto.ConversationUpdateDTO;&#10;import com.mapsocial.dto.TypingDTO;&#10;import com.mapsocial.dto.UnreadCountDTO;&#10;import com.mapsocial.dto.request.CreateConversationRequest;&#10;import com.mapsocial.dto.request.MarkAsReadRequest;&#10;import com.mapsocial.dto.request.SendMessageRequest;&#10;import com.mapsocial.dto.response.ConversationDTO;&#10;import com.mapsocial.dto.response.MessageDTO;&#10;import com.mapsocial.dto.response.UserSearchDTO;&#10;import com.mapsocial.entity.User;&#10;import com.mapsocial.exception.ChatException;&#10;import com.mapsocial.repository.UserRepository;&#10;import com.mapsocial.service.chat.ChatService;&#10;import com.mapsocial.service.impl.CustomUserDetailsService.UserPrincipal;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.messaging.handler.annotation.MessageMapping;&#10;import org.springframework.messaging.handler.annotation.Payload;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.security.core.annotation.AuthenticationPrincipal;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@Controller&#10;@RequiredArgsConstructor&#10;public class ChatController {&#10;&#10;    private final ChatService chatService;&#10;    private final SimpMessagingTemplate messagingTemplate;&#10;    private final UserRepository userRepository;&#10;&#10;    // ========== WEBSOCKET ENDPOINTS ==========&#10;&#10;    /**&#10;     * WebSocket endpoint - Gửi tin nhắn realtime&#10;     */&#10;    @MessageMapping(&quot;/sendMessage&quot;)&#10;    public void sendMessage(@Payload ChatMessageDTO chatMessage,&#10;                            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        try {&#10;            if (userPrincipal == null || userPrincipal.getUser() == null) {&#10;                throw new ChatException(&quot;Authentication required. Please reconnect with valid token.&quot;);&#10;            }&#10;&#10;            String senderId = userPrincipal.getUser().getId().toString();&#10;            String conversationId = chatMessage.getConversationId();&#10;&#10;            if (conversationId == null || conversationId.isEmpty()) {&#10;                if (chatMessage.getRecipientId() == null || chatMessage.getRecipientId().isEmpty()) {&#10;                    throw new ChatException(&quot;RecipientId là bắt buộc để tạo cuộc trò chuyện mới&quot;);&#10;                }&#10;&#10;                ConversationDTO conversation = chatService.getOrCreatePrivateConversation(&#10;                        senderId,&#10;                        chatMessage.getRecipientId()&#10;                );&#10;                conversationId = conversation.getId();&#10;                chatMessage.setConversationId(conversationId);&#10;            }&#10;&#10;            // Gửi message&#10;            SendMessageRequest request = SendMessageRequest.builder()&#10;                    .conversationId(conversationId)&#10;                    .content(chatMessage.getContent())&#10;                    .type(chatMessage.getMessageType())&#10;                    .build();&#10;&#10;            MessageDTO savedMessage = chatService.sendMessage(senderId, request);&#10;&#10;            // Broadcast message tới topic conversation&#10;            messagingTemplate.convertAndSend(&#10;                    &quot;/topic/conversation/&quot; + conversationId,&#10;                    savedMessage&#10;            );&#10;&#10;            // Gửi cập nhật unread count cho các thành viên&#10;            final String finalSenderId = senderId;&#10;            final String finalConversationId = conversationId; // &lt;--- thêm dòng này&#10;&#10;            ConversationDTO conv = chatService.getConversationById(conversationId, finalSenderId);&#10;&#10;            conv.getMembers().forEach(member -&gt; {&#10;                if (!member.getUserId().equals(finalSenderId)) {&#10;                    int unreadCount = chatService.getUnreadCount(finalConversationId, member.getUserId());&#10;&#10;                    // Tạo DTO cập nhật&#10;                    UnreadCountDTO unreadDTO = new UnreadCountDTO(finalConversationId, unreadCount);&#10;                    ConversationUpdateDTO updateDTO = new ConversationUpdateDTO(&#10;                            finalConversationId,&#10;                            conv.getLastMessageContent(),&#10;                            conv.getLastMessageSenderId(),&#10;                            conv.getLastMessageAt(),&#10;                            unreadCount&#10;                    );&#10;&#10;                    // Gửi tới từng user qua hàng đợi riêng&#10;                    messagingTemplate.convertAndSendToUser(member.getUserId(), &quot;/queue/unread&quot;, unreadDTO);&#10;                    messagingTemplate.convertAndSendToUser(member.getUserId(), &quot;/queue/conversation-update&quot;, updateDTO);&#10;                }&#10;            });&#10;&#10;&#10;        } catch (Exception e) {&#10;            if (userPrincipal != null &amp;&amp; userPrincipal.getUser() != null) {&#10;                String userId = userPrincipal.getUser().getId().toString();&#10;                messagingTemplate.convertAndSendToUser(&#10;                        userId,&#10;                        &quot;/queue/errors&quot;,&#10;                        &quot;Error: &quot; + e.getMessage()&#10;                );&#10;            }&#10;            System.err.println(&quot;Error in sendMessage: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * WebSocket endpoint - Mark messages as read&#10;     */&#10;    @MessageMapping(&quot;/markAsRead&quot;)&#10;    public void handleMarkAsRead(@Payload MarkAsReadRequest request,&#10;                                 @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        try {&#10;            if (userPrincipal == null || userPrincipal.getUser() == null) {&#10;                System.err.println(&quot;No authenticated user in markAsRead&quot;);&#10;                return;&#10;            }&#10;&#10;            String userId = userPrincipal.getUser().getId().toString();&#10;            System.out.println(&quot; Mark as read: conversationId=&quot; + request.getConversationId() + &quot; userId=&quot; + userId);&#10;&#10;            chatService.markMessagesAsRead(request.getConversationId(), userId);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error in markAsRead: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * WebSocket endpoint - Typing indicator&#10;     */&#10;    @MessageMapping(&quot;/typing&quot;)&#10;    public void handleTyping(@Payload TypingDTO typingDTO,&#10;                             @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        System.out.println(&quot;handleTyping called with typingDTO: &quot; + typingDTO + &quot; userPrincipal: &quot; + userPrincipal);&#10;        try {&#10;            if (userPrincipal == null || userPrincipal.getUser() == null) return;&#10;&#10;            String userId = userPrincipal.getUser().getId().toString();&#10;            String username = userPrincipal.getUser().getDisplayName();&#10;&#10;            chatService.setTypingStatus(&#10;                    typingDTO.getConversationId(),&#10;                    userId,&#10;                    typingDTO.isTyping()&#10;            );&#10;&#10;            TypingDTO authenticatedTypingDTO = new TypingDTO(&#10;                    typingDTO.getConversationId(),&#10;                    userId,&#10;                    username,&#10;                    typingDTO.isTyping()&#10;            );&#10;&#10;            System.out.println(&quot;Backend sending typing: &quot; + authenticatedTypingDTO);&#10;            messagingTemplate.convertAndSend(&#10;                    &quot;/topic/conversation/&quot; + typingDTO.getConversationId() + &quot;/typing&quot;,&#10;                    authenticatedTypingDTO&#10;            );&#10;        } catch (Exception ignored) {}&#10;    }&#10;&#10;    // ========== REST API ENDPOINTS ==========&#10;&#10;    @GetMapping(&quot;/api/conversations&quot;)&#10;    public ResponseEntity&lt;List&lt;ConversationDTO&gt;&gt; getUserConversations(&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        List&lt;ConversationDTO&gt; conversations = chatService.getUserConversations(userId);&#10;        return ResponseEntity.ok(conversations);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; getConversation(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.getConversationById(conversationId, userId);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/private/{otherUserId}&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; getOrCreatePrivateConversation(&#10;            @PathVariable String otherUserId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.getOrCreatePrivateConversation(userId, otherUserId);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @PostMapping(&quot;/api/conversations&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; createConversation(&#10;            @Valid @RequestBody CreateConversationRequest request,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.createConversation(request, userId);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @PutMapping(&quot;/api/conversations/{conversationId}/group-info&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; updateGroupInfo(&#10;            @PathVariable String conversationId,&#10;            @RequestParam(required = false) String groupName,&#10;            @RequestParam(required = false) String groupAvatar,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.updateGroupInfo(conversationId, userId, groupName, groupAvatar);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}/messages&quot;)&#10;    public ResponseEntity&lt;Page&lt;MessageDTO&gt;&gt; getMessages(&#10;            @PathVariable String conversationId,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;50&quot;) int size,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        Pageable pageable = PageRequest.of(page, size);&#10;        Page&lt;MessageDTO&gt; messages = chatService.getMessages(conversationId, userId, pageable);&#10;        return ResponseEntity.ok(messages);&#10;    }&#10;&#10;    @PostMapping(&quot;/api/conversations/{conversationId}/messages&quot;)&#10;    public ResponseEntity&lt;MessageDTO&gt; sendMessageREST(&#10;            @PathVariable String conversationId,&#10;            @Valid @RequestBody SendMessageRequest request,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        request.setConversationId(conversationId);&#10;        MessageDTO message = chatService.sendMessage(userId, request);&#10;&#10;        messagingTemplate.convertAndSend(&quot;/topic/conversation/&quot; + conversationId, message);&#10;        return ResponseEntity.ok(message);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/api/messages/{messageId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteMessage(&#10;            @PathVariable String messageId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        chatService.deleteMessage(messageId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}/unread-count&quot;)&#10;    public ResponseEntity&lt;Integer&gt; getUnreadCount(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        int count = chatService.getUnreadCount(conversationId, userId);&#10;        return ResponseEntity.ok(count);&#10;    }&#10;&#10;    @PostMapping(&quot;/api/conversations/{conversationId}/read&quot;)&#10;    public ResponseEntity&lt;Void&gt; markAsRead(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        chatService.markMessagesAsRead(conversationId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/api/users/search&quot;)&#10;    public ResponseEntity&lt;List&lt;UserSearchDTO&gt;&gt; searchUsers(&#10;            @RequestParam String query,&#10;            @RequestParam(defaultValue = &quot;20&quot;) int limit) {&#10;        List&lt;User&gt; users = userRepository.findByDisplayNameContainingIgnoreCaseOrEmailContainingIgnoreCase(&#10;                query, query, PageRequest.of(0, limit)&#10;        );&#10;&#10;        List&lt;UserSearchDTO&gt; result = users.stream()&#10;                .map(user -&gt; UserSearchDTO.builder()&#10;                        .id(user.getId().toString())&#10;                        .displayName(user.getDisplayName())&#10;                        .email(user.getEmail())&#10;                        .avatarUrl(user.getAvatarUrl())&#10;                        .build())&#10;                .collect(Collectors.toList());&#10;&#10;        return ResponseEntity.ok(result);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.mapsocial.controller;&#10;&#10;&#10;import com.mapsocial.dto.ChatMessageDTO;&#10;import com.mapsocial.dto.ConversationUpdateDTO;&#10;import com.mapsocial.dto.TypingDTO;&#10;import com.mapsocial.dto.UnreadCountDTO;&#10;import com.mapsocial.dto.request.CreateConversationRequest;&#10;import com.mapsocial.dto.request.MarkAsReadRequest;&#10;import com.mapsocial.dto.request.SendMessageRequest;&#10;import com.mapsocial.dto.response.ConversationDTO;&#10;import com.mapsocial.dto.response.MessageDTO;&#10;import com.mapsocial.dto.response.UserSearchDTO;&#10;import com.mapsocial.entity.User;&#10;import com.mapsocial.exception.ChatException;&#10;import com.mapsocial.repository.UserRepository;&#10;import com.mapsocial.service.chat.ChatService;&#10;import com.mapsocial.service.impl.CustomUserDetailsService.UserPrincipal;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.messaging.handler.annotation.MessageMapping;&#10;import org.springframework.messaging.handler.annotation.Payload;&#10;import org.springframework.messaging.simp.SimpMessagingTemplate;&#10;import org.springframework.security.core.annotation.AuthenticationPrincipal;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@Controller&#10;@RequiredArgsConstructor&#10;public class ChatController {&#10;&#10;    private final ChatService chatService;&#10;    private final SimpMessagingTemplate messagingTemplate;&#10;    private final UserRepository userRepository;&#10;&#10;    // ========== WEBSOCKET ENDPOINTS ==========&#10;&#10;    /**&#10;     * WebSocket endpoint - Gửi tin nhắn realtime&#10;     */&#10;    @MessageMapping(&quot;/sendMessage&quot;)&#10;    public void sendMessage(@Payload ChatMessageDTO chatMessage,&#10;                            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        try {&#10;            if (userPrincipal == null || userPrincipal.getUser() == null) {&#10;                throw new ChatException(&quot;Authentication required. Please reconnect with valid token.&quot;);&#10;            }&#10;&#10;            String senderId = userPrincipal.getUser().getId().toString();&#10;            String conversationId = chatMessage.getConversationId();&#10;&#10;            if (conversationId == null || conversationId.isEmpty()) {&#10;                if (chatMessage.getRecipientId() == null || chatMessage.getRecipientId().isEmpty()) {&#10;                    throw new ChatException(&quot;RecipientId là bắt buộc để tạo cuộc trò chuyện mới&quot;);&#10;                }&#10;&#10;                ConversationDTO conversation = chatService.getOrCreatePrivateConversation(&#10;                        senderId,&#10;                        chatMessage.getRecipientId()&#10;                );&#10;                conversationId = conversation.getId();&#10;                chatMessage.setConversationId(conversationId);&#10;            }&#10;&#10;            // Gửi message&#10;            SendMessageRequest request = SendMessageRequest.builder()&#10;                    .conversationId(conversationId)&#10;                    .content(chatMessage.getContent())&#10;                    .type(chatMessage.getMessageType())&#10;                    .build();&#10;&#10;            MessageDTO savedMessage = chatService.sendMessage(senderId, request);&#10;&#10;            // Broadcast message tới topic conversation&#10;            messagingTemplate.convertAndSend(&#10;                    &quot;/topic/conversation/&quot; + conversationId,&#10;                    savedMessage&#10;            );&#10;&#10;            // Gửi cập nhật unread count cho các thành viên&#10;            final String finalSenderId = senderId;&#10;            final String finalConversationId = conversationId; // &lt;--- thêm dòng này&#10;&#10;            ConversationDTO conv = chatService.getConversationById(conversationId, finalSenderId);&#10;&#10;            conv.getMembers().forEach(member -&gt; {&#10;                if (!member.getUserId().equals(finalSenderId)) {&#10;                    int unreadCount = chatService.getUnreadCount(finalConversationId, member.getUserId());&#10;&#10;                    // Tạo DTO cập nhật&#10;                    UnreadCountDTO unreadDTO = new UnreadCountDTO(finalConversationId, unreadCount);&#10;                    ConversationUpdateDTO updateDTO = new ConversationUpdateDTO(&#10;                            finalConversationId,&#10;                            conv.getLastMessageContent(),&#10;                            conv.getLastMessageSenderId(),&#10;                            conv.getLastMessageAt(),&#10;                            unreadCount&#10;                    );&#10;&#10;                    // Gửi tới từng user qua hàng đợi riêng&#10;                    messagingTemplate.convertAndSendToUser(member.getUserId(), &quot;/queue/unread&quot;, unreadDTO);&#10;                    messagingTemplate.convertAndSendToUser(member.getUserId(), &quot;/queue/conversation-update&quot;, updateDTO);&#10;                }&#10;            });&#10;&#10;&#10;        } catch (Exception e) {&#10;            if (userPrincipal != null &amp;&amp; userPrincipal.getUser() != null) {&#10;                String userId = userPrincipal.getUser().getId().toString();&#10;                messagingTemplate.convertAndSendToUser(&#10;                        userId,&#10;                        &quot;/queue/errors&quot;,&#10;                        &quot;Error: &quot; + e.getMessage()&#10;                );&#10;            }&#10;            System.err.println(&quot;Error in sendMessage: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * WebSocket endpoint - Mark messages as read&#10;     */&#10;    @MessageMapping(&quot;/markAsRead&quot;)&#10;    public void handleMarkAsRead(@Payload MarkAsReadRequest request,&#10;                                 @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        try {&#10;            if (userPrincipal == null || userPrincipal.getUser() == null) {&#10;                System.err.println(&quot;No authenticated user in markAsRead&quot;);&#10;                return;&#10;            }&#10;&#10;            String userId = userPrincipal.getUser().getId().toString();&#10;            System.out.println(&quot; Mark as read: conversationId=&quot; + request.getConversationId() + &quot; userId=&quot; + userId);&#10;&#10;            chatService.markMessagesAsRead(request.getConversationId(), userId);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error in markAsRead: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * WebSocket endpoint - Typing indicator&#10;     */&#10;    @MessageMapping(&quot;/typing&quot;)&#10;    public void handleTyping(@Payload TypingDTO typingDTO,&#10;                             @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        System.out.println(&quot;handleTyping called with typingDTO: &quot; + typingDTO + &quot; userPrincipal: &quot; + userPrincipal);&#10;        try {&#10;            if (userPrincipal == null || userPrincipal.getUser() == null) return;&#10;&#10;            String userId = userPrincipal.getUser().getId().toString();&#10;            String username = userPrincipal.getUser().getDisplayName();&#10;&#10;            chatService.setTypingStatus(&#10;                    typingDTO.getConversationId(),&#10;                    userId,&#10;                    typingDTO.isTyping()&#10;            );&#10;&#10;            TypingDTO authenticatedTypingDTO = new TypingDTO(&#10;                    typingDTO.getConversationId(),&#10;                    userId,&#10;                    username,&#10;                    typingDTO.isTyping()&#10;            );&#10;&#10;            System.out.println(&quot;Backend sending typing: &quot; + authenticatedTypingDTO);&#10;            messagingTemplate.convertAndSend(&#10;                    &quot;/topic/conversation/&quot; + typingDTO.getConversationId() + &quot;/typing&quot;,&#10;                    authenticatedTypingDTO&#10;            );&#10;        } catch (Exception ignored) {}&#10;    }&#10;&#10;    // ========== REST API ENDPOINTS ==========&#10;&#10;    @GetMapping(&quot;/api/conversations&quot;)&#10;    public ResponseEntity&lt;List&lt;ConversationDTO&gt;&gt; getUserConversations(&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        List&lt;ConversationDTO&gt; conversations = chatService.getUserConversations(userId);&#10;        return ResponseEntity.ok(conversations);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; getConversation(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.getConversationById(conversationId, userId);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/private/{otherUserId}&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; getOrCreatePrivateConversation(&#10;            @PathVariable String otherUserId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.getOrCreatePrivateConversation(userId, otherUserId);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @PostMapping(&quot;/api/conversations&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; createConversation(&#10;            @Valid @RequestBody CreateConversationRequest request,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.createConversation(request, userId);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @PutMapping(&quot;/api/conversations/{conversationId}/group-info&quot;)&#10;    public ResponseEntity&lt;ConversationDTO&gt; updateGroupInfo(&#10;            @PathVariable String conversationId,&#10;            @RequestParam(required = false) String groupName,&#10;            @RequestParam(required = false) String groupAvatar,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        ConversationDTO conversation = chatService.updateGroupInfo(conversationId, userId, groupName, groupAvatar);&#10;        return ResponseEntity.ok(conversation);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}/messages&quot;)&#10;    public ResponseEntity&lt;Page&lt;MessageDTO&gt;&gt; getMessages(&#10;            @PathVariable String conversationId,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;50&quot;) int size,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        Pageable pageable = PageRequest.of(page, size);&#10;        Page&lt;MessageDTO&gt; messages = chatService.getMessages(conversationId, userId, pageable);&#10;        return ResponseEntity.ok(messages);&#10;    }&#10;&#10;    @PostMapping(&quot;/api/conversations/{conversationId}/messages&quot;)&#10;    public ResponseEntity&lt;MessageDTO&gt; sendMessageREST(&#10;            @PathVariable String conversationId,&#10;            @Valid @RequestBody SendMessageRequest request,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        request.setConversationId(conversationId);&#10;        MessageDTO message = chatService.sendMessage(userId, request);&#10;&#10;        messagingTemplate.convertAndSend(&quot;/topic/conversation/&quot; + conversationId, message);&#10;        return ResponseEntity.ok(message);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/api/messages/{messageId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteMessage(&#10;            @PathVariable String messageId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        chatService.deleteMessage(messageId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}/unread-count&quot;)&#10;    public ResponseEntity&lt;Integer&gt; getUnreadCount(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        int count = chatService.getUnreadCount(conversationId, userId);&#10;        return ResponseEntity.ok(count);&#10;    }&#10;&#10;    @GetMapping(&quot;/api/conversations/{conversationId}/typing&quot;)&#10;    public ResponseEntity&lt;List&lt;String&gt;&gt; getTypingUsers(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        // Verify user is member of conversation&#10;        if (!chatService.isMemberOfConversation(conversationId, userId)) {&#10;            return ResponseEntity.status(403).build();&#10;        }&#10;        List&lt;String&gt; typingUserIds = chatService.getTypingUsers(conversationId);&#10;        return ResponseEntity.ok(typingUserIds);&#10;    }&#10;&#10;    @PostMapping(&quot;/api/conversations/{conversationId}/read&quot;)&#10;    public ResponseEntity&lt;Void&gt; markAsRead(&#10;            @PathVariable String conversationId,&#10;            @AuthenticationPrincipal UserPrincipal userPrincipal) {&#10;        String userId = userPrincipal.getUser().getId().toString();&#10;        chatService.markMessagesAsRead(conversationId, userId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/api/users/search&quot;)&#10;    public ResponseEntity&lt;List&lt;UserSearchDTO&gt;&gt; searchUsers(&#10;            @RequestParam String query,&#10;            @RequestParam(defaultValue = &quot;20&quot;) int limit) {&#10;        List&lt;User&gt; users = userRepository.findByDisplayNameContainingIgnoreCaseOrEmailContainingIgnoreCase(&#10;                query, query, PageRequest.of(0, limit)&#10;        );&#10;&#10;        List&lt;UserSearchDTO&gt; result = users.stream()&#10;                .map(user -&gt; UserSearchDTO.builder()&#10;                        .id(user.getId().toString())&#10;                        .displayName(user.getDisplayName())&#10;                        .email(user.getEmail())&#10;                        .avatarUrl(user.getAvatarUrl())&#10;                        .build())&#10;                .collect(Collectors.toList());&#10;&#10;        return ResponseEntity.ok(result);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>